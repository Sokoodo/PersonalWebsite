{"ast":null,"code":"(function () {\n  var e = window.AmCharts;\n  e.AmRectangularChart = e.Class({\n    inherits: e.AmCoordinateChart,\n    construct: function (a) {\n      e.AmRectangularChart.base.construct.call(this, a);\n      this.theme = a;\n      this.createEvents(\"zoomed\", \"changed\");\n      this.marginRight = this.marginBottom = this.marginTop = this.marginLeft = 20;\n      this.depth3D = this.angle = 0;\n      this.plotAreaFillColors = \"#FFFFFF\";\n      this.plotAreaFillAlphas = 0;\n      this.plotAreaBorderColor = \"#000000\";\n      this.plotAreaBorderAlpha = 0;\n      this.maxZoomFactor = 20;\n      this.zoomOutButtonImageSize = 19;\n      this.zoomOutButtonImage = \"lens\";\n      this.zoomOutText = \"Show all\";\n      this.zoomOutButtonColor = \"#e5e5e5\";\n      this.zoomOutButtonAlpha = 0;\n      this.zoomOutButtonRollOverAlpha = 1;\n      this.zoomOutButtonPadding = 8;\n      this.trendLines = [];\n      this.autoMargins = !0;\n      this.marginsUpdated = !1;\n      this.autoMarginOffset = 10;\n      e.applyTheme(this, a, \"AmRectangularChart\");\n    },\n    initChart: function () {\n      e.AmRectangularChart.base.initChart.call(this);\n      this.updateDxy();\n      !this.marginsUpdated && this.autoMargins && (this.resetMargins(), this.drawGraphs = !1);\n      this.processScrollbars();\n      this.updateMargins();\n      this.updatePlotArea();\n      this.updateScrollbars();\n      this.updateTrendLines();\n      this.updateChartCursor();\n      this.updateValueAxes();\n      this.scrollbarOnly || this.updateGraphs();\n    },\n    drawChart: function () {\n      e.AmRectangularChart.base.drawChart.call(this);\n      this.drawPlotArea();\n\n      if (e.ifArray(this.chartData)) {\n        var a = this.chartCursor;\n        a && a.draw();\n      }\n    },\n    resetMargins: function () {\n      var a = {},\n          b;\n\n      if (\"xy\" == this.type) {\n        var c = this.xAxes,\n            d = this.yAxes;\n\n        for (b = 0; b < c.length; b++) {\n          var g = c[b];\n          g.ignoreAxisWidth || (g.setOrientation(!0), g.fixAxisPosition(), a[g.position] = !0);\n        }\n\n        for (b = 0; b < d.length; b++) c = d[b], c.ignoreAxisWidth || (c.setOrientation(!1), c.fixAxisPosition(), a[c.position] = !0);\n      } else {\n        d = this.valueAxes;\n\n        for (b = 0; b < d.length; b++) c = d[b], c.ignoreAxisWidth || (c.setOrientation(this.rotate), c.fixAxisPosition(), a[c.position] = !0);\n\n        (b = this.categoryAxis) && !b.ignoreAxisWidth && (b.setOrientation(!this.rotate), b.fixAxisPosition(), b.fixAxisPosition(), a[b.position] = !0);\n      }\n\n      a.left && (this.marginLeft = 0);\n      a.right && (this.marginRight = 0);\n      a.top && (this.marginTop = 0);\n      a.bottom && (this.marginBottom = 0);\n      this.fixMargins = a;\n    },\n    measureMargins: function () {\n      var a = this.valueAxes,\n          b,\n          c = this.autoMarginOffset,\n          d = this.fixMargins,\n          g = this.realWidth,\n          h = this.realHeight,\n          f = c,\n          e = c,\n          l = g;\n      b = h;\n      var m;\n\n      for (m = 0; m < a.length; m++) a[m].handleSynchronization(), b = this.getAxisBounds(a[m], f, l, e, b), f = Math.round(b.l), l = Math.round(b.r), e = Math.round(b.t), b = Math.round(b.b);\n\n      if (a = this.categoryAxis) b = this.getAxisBounds(a, f, l, e, b), f = Math.round(b.l), l = Math.round(b.r), e = Math.round(b.t), b = Math.round(b.b);\n      d.left && f < c && (this.marginLeft = Math.round(-f + c), !isNaN(this.minMarginLeft) && this.marginLeft < this.minMarginLeft && (this.marginLeft = this.minMarginLeft));\n      d.right && l >= g - c && (this.marginRight = Math.round(l - g + c), !isNaN(this.minMarginRight) && this.marginRight < this.minMarginRight && (this.marginRight = this.minMarginRight));\n      d.top && e < c + this.titleHeight && (this.marginTop = Math.round(this.marginTop - e + c + this.titleHeight), !isNaN(this.minMarginTop) && this.marginTop < this.minMarginTop && (this.marginTop = this.minMarginTop));\n      d.bottom && b > h - c && (this.marginBottom = Math.round(this.marginBottom + b - h + c), !isNaN(this.minMarginBottom) && this.marginBottom < this.minMarginBottom && (this.marginBottom = this.minMarginBottom));\n      this.initChart();\n    },\n    getAxisBounds: function (a, b, c, d, g) {\n      if (!a.ignoreAxisWidth) {\n        var h = a.labelsSet,\n            f = a.tickLength;\n        a.inside && (f = 0);\n        if (h) switch (h = a.getBBox(), a.position) {\n          case \"top\":\n            a = h.y;\n            d > a && (d = a);\n            break;\n\n          case \"bottom\":\n            a = h.y + h.height;\n            g < a && (g = a);\n            break;\n\n          case \"right\":\n            a = h.x + h.width + f + 3;\n            c < a && (c = a);\n            break;\n\n          case \"left\":\n            a = h.x - f, b > a && (b = a);\n        }\n      }\n\n      return {\n        l: b,\n        t: d,\n        r: c,\n        b: g\n      };\n    },\n    drawZoomOutButton: function () {\n      var a = this;\n\n      if (!a.zbSet) {\n        var b = a.container.set();\n        a.zoomButtonSet.push(b);\n        var c = a.color,\n            d = a.fontSize,\n            g = a.zoomOutButtonImageSize,\n            h = a.zoomOutButtonImage.replace(/\\.[a-z]*$/i, \"\"),\n            f = a.langObj.zoomOutText || a.zoomOutText,\n            k = a.zoomOutButtonColor,\n            l = a.zoomOutButtonAlpha,\n            m = a.zoomOutButtonFontSize,\n            p = a.zoomOutButtonPadding;\n        isNaN(m) || (d = m);\n        (m = a.zoomOutButtonFontColor) && (c = m);\n        var m = a.zoomOutButton,\n            n;\n        m && (m.fontSize && (d = m.fontSize), m.color && (c = m.color), m.backgroundColor && (k = m.backgroundColor), isNaN(m.backgroundAlpha) || (a.zoomOutButtonRollOverAlpha = m.backgroundAlpha));\n        var u = m = 0,\n            u = a.pathToImages;\n\n        if (h) {\n          if (e.isAbsolute(h) || void 0 === u) u = \"\";\n          n = a.container.image(u + h + a.extension, 0, 0, g, g);\n          e.setCN(a, n, \"zoom-out-image\");\n          b.push(n);\n          n = n.getBBox();\n          m = n.width + 5;\n        }\n\n        void 0 !== f && (c = e.text(a.container, f, c, a.fontFamily, d, \"start\"), e.setCN(a, c, \"zoom-out-label\"), d = c.getBBox(), u = n ? n.height / 2 - 3 : d.height / 2, c.translate(m, u), b.push(c));\n        n = b.getBBox();\n        c = 1;\n        e.isModern || (c = 0);\n        k = e.rect(a.container, n.width + 2 * p + 5, n.height + 2 * p - 2, k, 1, 1, k, c);\n        k.setAttr(\"opacity\", l);\n        k.translate(-p, -p);\n        e.setCN(a, k, \"zoom-out-bg\");\n        b.push(k);\n        k.toBack();\n        a.zbBG = k;\n        n = k.getBBox();\n        b.translate(a.marginLeftReal + a.plotAreaWidth - n.width + p, a.marginTopReal + p);\n        b.hide();\n        b.mouseover(function () {\n          a.rollOverZB();\n        }).mouseout(function () {\n          a.rollOutZB();\n        }).click(function () {\n          a.clickZB();\n        }).touchstart(function () {\n          a.rollOverZB();\n        }).touchend(function () {\n          a.rollOutZB();\n          a.clickZB();\n        });\n\n        for (l = 0; l < b.length; l++) b[l].attr({\n          cursor: \"pointer\"\n        });\n\n        void 0 !== a.zoomOutButtonTabIndex && (b.setAttr(\"tabindex\", a.zoomOutButtonTabIndex), b.setAttr(\"role\", \"menuitem\"), b.keyup(function (b) {\n          13 == b.keyCode && a.clickZB();\n        }));\n        a.zbSet = b;\n      }\n    },\n    rollOverZB: function () {\n      this.rolledOverZB = !0;\n      this.zbBG.setAttr(\"opacity\", this.zoomOutButtonRollOverAlpha);\n    },\n    rollOutZB: function () {\n      this.rolledOverZB = !1;\n      this.zbBG.setAttr(\"opacity\", this.zoomOutButtonAlpha);\n    },\n    clickZB: function () {\n      this.rolledOverZB = !1;\n      this.zoomOut();\n    },\n    zoomOut: function () {\n      this.zoomOutValueAxes();\n    },\n    drawPlotArea: function () {\n      var a = this.dx,\n          b = this.dy,\n          c = this.marginLeftReal,\n          d = this.marginTopReal,\n          g = this.plotAreaWidth - 1,\n          h = this.plotAreaHeight - 1,\n          f = this.plotAreaFillColors,\n          k = this.plotAreaFillAlphas,\n          l = this.plotAreaBorderColor,\n          m = this.plotAreaBorderAlpha;\n      \"object\" == typeof k && (k = k[0]);\n      f = e.polygon(this.container, [0, g, g, 0, 0], [0, 0, h, h, 0], f, k, 1, l, m, this.plotAreaGradientAngle);\n      e.setCN(this, f, \"plot-area\");\n      f.translate(c + a, d + b);\n      this.set.push(f);\n      0 !== a && 0 !== b && (f = this.plotAreaFillColors, \"object\" == typeof f && (f = f[0]), f = e.adjustLuminosity(f, -.15), g = e.polygon(this.container, [0, a, g + a, g, 0], [0, b, b, 0, 0], f, k, 1, l, m), e.setCN(this, g, \"plot-area-bottom\"), g.translate(c, d + h), this.set.push(g), a = e.polygon(this.container, [0, 0, a, a, 0], [0, h, h + b, b, 0], f, k, 1, l, m), e.setCN(this, a, \"plot-area-left\"), a.translate(c, d), this.set.push(a));\n      (c = this.bbset) && this.scrollbarOnly && c.remove();\n    },\n    updatePlotArea: function () {\n      var a = this.updateWidth(),\n          b = this.updateHeight(),\n          c = this.container;\n      this.realWidth = a;\n      this.realWidth = b;\n      c && this.container.setSize(a, b);\n      var c = this.marginLeftReal,\n          d = this.marginTopReal,\n          a = a - c - this.marginRightReal - this.dx,\n          b = b - d - this.marginBottomReal;\n      1 > a && (a = 1);\n      1 > b && (b = 1);\n      this.plotAreaWidth = Math.round(a);\n      this.plotAreaHeight = Math.round(b);\n      this.plotBalloonsSet.translate(c, d);\n    },\n    updateDxy: function () {\n      this.dx = Math.round(this.depth3D * Math.cos(this.angle * Math.PI / 180));\n      this.dy = Math.round(-this.depth3D * Math.sin(this.angle * Math.PI / 180));\n      this.d3x = Math.round(this.columnSpacing3D * Math.cos(this.angle * Math.PI / 180));\n      this.d3y = Math.round(-this.columnSpacing3D * Math.sin(this.angle * Math.PI / 180));\n    },\n    updateMargins: function () {\n      var a = this.getTitleHeight();\n      this.titleHeight = a;\n      this.marginTopReal = this.marginTop - this.dy;\n      this.fixMargins && !this.fixMargins.top && (this.marginTopReal += a);\n      this.marginBottomReal = this.marginBottom;\n      this.marginLeftReal = this.marginLeft;\n      this.marginRightReal = this.marginRight;\n    },\n    updateValueAxes: function () {\n      var a = this.valueAxes,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b];\n        this.setAxisRenderers(c);\n        this.updateObjectSize(c);\n      }\n    },\n    setAxisRenderers: function (a) {\n      a.axisRenderer = e.RecAxis;\n      a.guideFillRenderer = e.RecFill;\n      a.axisItemRenderer = e.RecItem;\n      a.marginsChanged = !0;\n    },\n    updateGraphs: function () {\n      var a = this.graphs,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b];\n        c.index = b;\n        c.rotate = this.rotate;\n        this.updateObjectSize(c);\n      }\n    },\n    updateObjectSize: function (a) {\n      a.width = this.plotAreaWidth - 1;\n      a.height = this.plotAreaHeight - 1;\n      a.x = this.marginLeftReal;\n      a.y = this.marginTopReal;\n      a.dx = this.dx;\n      a.dy = this.dy;\n    },\n    updateChartCursor: function () {\n      var a = this.chartCursor;\n      a && (a = e.processObject(a, e.ChartCursor, this.theme), this.updateObjectSize(a), this.addChartCursor(a), a.chart = this);\n    },\n    processScrollbars: function () {\n      var a = this.chartScrollbar;\n      a && (a = e.processObject(a, e.ChartScrollbar, this.theme), this.addChartScrollbar(a));\n    },\n    updateScrollbars: function () {},\n    removeChartCursor: function () {\n      e.callMethod(\"destroy\", [this.chartCursor]);\n      this.chartCursor = null;\n    },\n    zoomTrendLines: function () {\n      var a = this.trendLines,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b];\n        c.valueAxis.recalculateToPercents ? c.set && c.set.hide() : (c.x = this.marginLeftReal, c.y = this.marginTopReal, c.draw());\n      }\n    },\n    handleCursorValueZoom: function () {},\n    addTrendLine: function (a) {\n      this.trendLines.push(a);\n    },\n    zoomOutValueAxes: function () {\n      for (var a = this.valueAxes, b = 0; b < a.length; b++) a[b].zoomOut();\n    },\n    removeTrendLine: function (a) {\n      var b = this.trendLines,\n          c;\n\n      for (c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1);\n    },\n    adjustMargins: function (a, b) {\n      var c = a.position,\n          d = a.scrollbarHeight + a.offset;\n      a.enabled && (\"top\" == c ? b ? this.marginLeftReal += d : this.marginTopReal += d : b ? this.marginRightReal += d : this.marginBottomReal += d);\n    },\n    getScrollbarPosition: function (a, b, c) {\n      var d = \"bottom\",\n          g = \"top\";\n      a.oppositeAxis || (g = d, d = \"top\");\n      a.position = b ? \"bottom\" == c || \"left\" == c ? d : g : \"top\" == c || \"right\" == c ? d : g;\n    },\n    updateChartScrollbar: function (a, b) {\n      if (a) {\n        a.rotate = b;\n        var c = this.marginTopReal,\n            d = this.marginLeftReal,\n            g = a.scrollbarHeight,\n            h = this.dx,\n            f = this.dy,\n            e = a.offset;\n        \"top\" == a.position ? b ? (a.y = c, a.x = d - g - e) : (a.y = c - g + f - e, a.x = d + h) : b ? (a.y = c + f, a.x = d + this.plotAreaWidth + h + e) : (a.y = c + this.plotAreaHeight + e, a.x = this.marginLeftReal);\n      }\n    },\n    showZB: function (a) {\n      var b = this.zbSet;\n      a && (b = this.zoomOutText, \"\" !== b && b && this.drawZoomOutButton());\n      if (b = this.zbSet) this.zoomButtonSet.push(b), a ? b.show() : b.hide(), this.rollOutZB();\n    },\n    handleReleaseOutside: function (a) {\n      e.AmRectangularChart.base.handleReleaseOutside.call(this, a);\n      (a = this.chartCursor) && a.handleReleaseOutside && a.handleReleaseOutside();\n    },\n    handleMouseDown: function (a) {\n      e.AmRectangularChart.base.handleMouseDown.call(this, a);\n      var b = this.chartCursor;\n      b && b.handleMouseDown && !this.rolledOverZB && b.handleMouseDown(a);\n    },\n    update: function () {\n      e.AmRectangularChart.base.update.call(this);\n      this.chartCursor && this.chartCursor.update && this.chartCursor.update();\n    },\n    handleScrollbarValueZoom: function (a) {\n      this.relativeZoomValueAxes(a.target.valueAxes, a.relativeStart, a.relativeEnd);\n      this.zoomAxesAndGraphs();\n    },\n    zoomValueScrollbar: function (a) {\n      if (a && a.enabled) {\n        var b = a.valueAxes[0],\n            c = b.relativeStart,\n            d = b.relativeEnd;\n        b.reversed && (d = 1 - c, c = 1 - b.relativeEnd);\n        a.percentZoom(c, d);\n      }\n    },\n    zoomAxesAndGraphs: function () {\n      if (!this.scrollbarOnly) {\n        var a = this.valueAxes,\n            b;\n\n        for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);\n\n        a = this.graphs;\n\n        for (b = 0; b < a.length; b++) a[b].zoom(this.start, this.end);\n\n        (b = this.chartCursor) && b.clearSelection();\n        this.zoomTrendLines();\n      }\n    },\n    handleValueAxisZoomReal: function (a, b) {\n      var c = a.relativeStart,\n          d = a.relativeEnd;\n      if (c > d) var g = c,\n          c = d,\n          d = g;\n      this.relativeZoomValueAxes(b, c, d);\n      this.updateAfterValueZoom();\n    },\n    updateAfterValueZoom: function () {\n      this.zoomAxesAndGraphs();\n      this.zoomScrollbar();\n    },\n    relativeZoomValueAxes: function (a, b, c) {\n      this.hideBalloonReal();\n      b = e.fitToBounds(b, 0, 1);\n      c = e.fitToBounds(c, 0, 1);\n\n      if (b > c) {\n        var d = b;\n        b = c;\n        c = d;\n      }\n\n      var d = 1 / this.maxZoomFactor,\n          g = e.getDecimals(d) + 4;\n      c - b < d && (c = b + (c - b) / 2, b = c - d / 2, c += d / 2, 1 < c && (b -= c - 1, c = 1), 0 > b && (b = 0, c = d));\n      b = e.roundTo(b, g);\n      c = e.roundTo(c, g);\n      d = !1;\n\n      if (a) {\n        for (g = 0; g < a.length; g++) {\n          var h = a[g].zoomToRelativeValues(b, c, !0);\n          h && (d = h);\n        }\n\n        this.showZB();\n      }\n\n      return d;\n    },\n    addChartCursor: function (a) {\n      e.callMethod(\"destroy\", [this.chartCursor]);\n      a && (this.listenTo(a, \"moved\", this.handleCursorMove), this.listenTo(a, \"zoomed\", this.handleCursorZoom), this.listenTo(a, \"zoomStarted\", this.handleCursorZoomStarted), this.listenTo(a, \"panning\", this.handleCursorPanning), this.listenTo(a, \"onHideCursor\", this.handleCursorHide));\n      this.chartCursor = a;\n    },\n    handleCursorChange: function () {},\n    handleCursorMove: function (a) {\n      var b,\n          c = this.valueAxes;\n\n      for (b = 0; b < c.length; b++) if (!a.panning) {\n        var d = c[b];\n        d && d.showBalloon && d.showBalloon(a.x, a.y);\n      }\n    },\n    handleCursorZoom: function (a) {\n      if (this.skipZoomed) this.skipZoomed = !1;else {\n        var b = this.startX0,\n            c = this.endX0,\n            d = this.endY0,\n            g = this.startY0,\n            h = a.startX,\n            f = a.endX,\n            e = a.startY,\n            l = a.endY;\n        this.startX0 = this.endX0 = this.startY0 = this.endY0 = NaN;\n        this.handleCursorZoomReal(b + h * (c - b), b + f * (c - b), g + e * (d - g), g + l * (d - g), a);\n      }\n    },\n    handleCursorHide: function () {\n      var a,\n          b = this.valueAxes;\n\n      for (a = 0; a < b.length; a++) b[a].hideBalloon();\n\n      b = this.graphs;\n\n      for (a = 0; a < b.length; a++) b[a].hideBalloonReal();\n    }\n  });\n})();\n\n(function () {\n  var e = window.AmCharts;\n  e.AmSerialChart = e.Class({\n    inherits: e.AmRectangularChart,\n    construct: function (a) {\n      this.type = \"serial\";\n      e.AmSerialChart.base.construct.call(this, a);\n      this.cname = \"AmSerialChart\";\n      this.theme = a;\n      this.columnSpacing = 5;\n      this.columnSpacing3D = 0;\n      this.columnWidth = .8;\n      var b = new e.CategoryAxis(a);\n      b.chart = this;\n      this.categoryAxis = b;\n      this.zoomOutOnDataUpdate = !0;\n      this.mouseWheelZoomEnabled = this.mouseWheelScrollEnabled = this.rotate = this.skipZoom = !1;\n      this.minSelectedTime = 0;\n      e.applyTheme(this, a, this.cname);\n    },\n    initChart: function () {\n      e.AmSerialChart.base.initChart.call(this);\n      this.updateCategoryAxis(this.categoryAxis, this.rotate, \"categoryAxis\");\n      if (this.dataChanged) this.parseData();else this.onDataUpdated();\n      this.drawGraphs = !0;\n    },\n    onDataUpdated: function () {\n      var a = this.countColumns(),\n          b = this.chartData,\n          c = this.graphs,\n          d;\n\n      for (d = 0; d < c.length; d++) {\n        var g = c[d];\n        g.data = b;\n        g.columnCount = a;\n      }\n\n      0 < b.length && (this.firstTime = this.getStartTime(b[0].time), this.lastTime = this.getEndTime(b[b.length - 1].time));\n      this.drawChart();\n      this.autoMargins && !this.marginsUpdated ? (this.marginsUpdated = !0, this.measureMargins()) : this.dispDUpd();\n    },\n    syncGrid: function () {\n      if (this.synchronizeGrid) {\n        var a = this.valueAxes,\n            b,\n            c;\n\n        if (0 < a.length) {\n          var d = 0;\n\n          for (c = 0; c < a.length; c++) b = a[c], d < b.gridCountReal && (d = b.gridCountReal);\n\n          var g = !1;\n\n          for (c = 0; c < a.length; c++) if (b = a[c], b.gridCountReal < d) {\n            var h = (d - b.gridCountReal) / 2,\n                f = g = h;\n            0 !== h - Math.round(h) && (g -= .5, f += .5);\n            0 <= b.min && 0 > b.min - g * b.step && (f += g, g = 0);\n            0 >= b.max && 0 < b.max + f * b.step && (g += f, f = 0);\n            h = e.getDecimals(b.step);\n            b.minimum = e.roundTo(b.min - g * b.step, h);\n            b.maximum = e.roundTo(b.max + f * b.step, h);\n            b.setStep = b.step;\n            g = b.strictMinMax = !0;\n          }\n\n          g && this.updateAfterValueZoom();\n\n          for (c = 0; c < a.length; c++) b = a[c], b.minimum = NaN, b.maximum = NaN, b.setStep = NaN, b.strictMinMax = !1;\n        }\n      }\n    },\n    handleWheelReal: function (a, b) {\n      if (!this.wheelBusy) {\n        var c = this.categoryAxis,\n            d = c.parseDates,\n            g = c.minDuration(),\n            e = 1,\n            f = 1;\n        this.mouseWheelZoomEnabled ? b || (e = -1) : b && (e = -1);\n        var k = this.chartCursor;\n\n        if (k) {\n          var l = k.mouseX,\n              k = k.mouseY;\n          e != f && (l = this.rotate ? k / this.plotAreaHeight : l / this.plotAreaWidth, e *= l, f *= 1 - l);\n          l = .05 * (this.end - this.start);\n          d && (l = .05 * (this.endTime - this.startTime) / g);\n          1 > l && (l = 1);\n          e *= l;\n          f *= l;\n          if (!d || c.equalSpacing) e = Math.round(e), f = Math.round(f);\n        }\n\n        k = this.chartData.length;\n        c = this.lastTime;\n        l = this.firstTime;\n        0 > a ? d ? (k = this.endTime - this.startTime, d = this.startTime + e * g, g = this.endTime + f * g, 0 < f && 0 < e && g >= c && (g = c, d = c - k), this.zoomToDates(new Date(d), new Date(g))) : (0 < f && 0 < e && this.end >= k - 1 && (e = f = 0), d = this.start + e, g = this.end + f, this.zoomToIndexes(d, g)) : d ? (k = this.endTime - this.startTime, d = this.startTime - e * g, g = this.endTime - f * g, 0 < f && 0 < e && d <= l && (d = l, g = l + k), this.zoomToDates(new Date(d), new Date(g))) : (0 < f && 0 < e && 1 > this.start && (e = f = 0), d = this.start - e, g = this.end - f, this.zoomToIndexes(d, g));\n      }\n    },\n    validateData: function (a) {\n      this.marginsUpdated = !1;\n      this.zoomOutOnDataUpdate && !a && (this.endTime = this.end = this.startTime = this.start = NaN);\n      var b = a = !1,\n          c = !1,\n          d = this.chartScrollbar;\n      d && (d.dragging && (a = !0, d.handleDragStop()), d.resizingRight && (c = !0, d.rightDragStop()), d.resizingLeft && (b = !0, d.leftDragStop()));\n      e.AmSerialChart.base.validateData.call(this);\n      a && d.handleDragStart();\n      c && d.rightDragStart();\n      b && d.leftDragStart();\n    },\n    drawChart: function () {\n      if (0 < this.realWidth && 0 < this.realHeight) {\n        e.AmSerialChart.base.drawChart.call(this);\n        var a = this.chartData;\n\n        if (e.ifArray(a)) {\n          var b = this.chartScrollbar;\n          !b || !this.marginsUpdated && this.autoMargins || b.draw();\n          (b = this.valueScrollbar) && b.draw();\n          var b = a.length - 1,\n              c,\n              d;\n          c = this.categoryAxis;\n\n          if (c.parseDates && !c.equalSpacing) {\n            if (c = this.startTime, d = this.endTime, isNaN(c) || isNaN(d)) c = this.firstTime, d = this.lastTime;\n          } else {\n            c = this.start;\n            d = this.end;\n            if (isNaN(c) || isNaN(d)) d = c = NaN;\n            isNaN(c) && (isNaN(this.startTime) || (c = this.getClosestIndex(a, \"time\", this.startTime, !0, 0, a.length)));\n            isNaN(d) && (isNaN(this.endTime) || (d = this.getClosestIndex(a, \"time\", this.endTime, !1, 0, a.length)));\n            if (isNaN(c) || isNaN(d)) c = 0, d = b;\n          }\n\n          this.endTime = this.startTime = this.end = this.start = void 0;\n          this.zoom(c, d);\n        }\n      } else this.cleanChart();\n    },\n    cleanChart: function () {\n      e.callMethod(\"destroy\", [this.valueAxes, this.graphs, this.categoryAxis, this.chartScrollbar, this.chartCursor, this.valueScrollbar]);\n    },\n    updateCategoryAxis: function (a, b, c) {\n      a.chart = this;\n      a.id = c;\n      a.rotate = b;\n      a.setOrientation(!this.rotate);\n      a.init();\n      this.setAxisRenderers(a);\n      this.updateObjectSize(a);\n    },\n    updateValueAxes: function () {\n      e.AmSerialChart.base.updateValueAxes.call(this);\n      var a = this.valueAxes,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b],\n            d = this.rotate;\n        c.rotate = d;\n        c.setOrientation(d);\n        d = this.categoryAxis;\n        if (!d.startOnAxis || d.parseDates) c.expandMinMax = !0;\n      }\n    },\n    getStartTime: function (a) {\n      var b = this.categoryAxis;\n      return e.resetDateToMin(new Date(a), b.minPeriod, 1, b.firstDayOfWeek).getTime();\n    },\n    getEndTime: function (a) {\n      var b = e.extractPeriod(this.categoryAxis.minPeriod);\n      return e.changeDate(new Date(a), b.period, b.count, !0).getTime() - 1;\n    },\n    updateMargins: function () {\n      e.AmSerialChart.base.updateMargins.call(this);\n      var a = this.chartScrollbar;\n      a && (this.getScrollbarPosition(a, this.rotate, this.categoryAxis.position), this.adjustMargins(a, this.rotate));\n      if (a = this.valueScrollbar) this.getScrollbarPosition(a, !this.rotate, this.valueAxes[0].position), this.adjustMargins(a, !this.rotate);\n    },\n    updateScrollbars: function () {\n      e.AmSerialChart.base.updateScrollbars.call(this);\n      this.updateChartScrollbar(this.chartScrollbar, this.rotate);\n      this.updateChartScrollbar(this.valueScrollbar, !this.rotate);\n    },\n    zoom: function (a, b) {\n      var c = this.categoryAxis;\n      c.parseDates && !c.equalSpacing ? (this.timeZoom(a, b), isNaN(a) && this.zoomOutValueAxes()) : this.indexZoom(a, b);\n      (c = this.chartCursor) && (c.pan || c.hideCursorReal());\n      this.updateLegendValues();\n    },\n    timeZoom: function (a, b) {\n      var c = this.maxSelectedTime;\n      isNaN(c) || (b != this.endTime && b - a > c && (a = b - c), a != this.startTime && b - a > c && (b = a + c));\n      var d = this.minSelectedTime;\n\n      if (0 < d && b - a < d) {\n        var g = Math.round(a + (b - a) / 2),\n            d = Math.round(d / 2);\n        a = g - d;\n        b = g + d;\n      }\n\n      d = this.chartData;\n      g = this.categoryAxis;\n\n      if (e.ifArray(d) && (a != this.startTime || b != this.endTime)) {\n        var h = g.minDuration(),\n            f = this.firstTime,\n            k = this.lastTime;\n        a || (a = f, isNaN(c) || (a = k - c));\n        b || (b = k);\n        a > k && (a = k);\n        b < f && (b = f);\n        a < f && (a = f);\n        b > k && (b = k);\n        b < a && (b = a + h);\n        b - a < h / 5 && (b < k ? b = a + h / 5 : a = b - h / 5);\n        this.startTime = a;\n        this.endTime = b;\n        c = d.length - 1;\n        h = this.getClosestIndex(d, \"time\", a, !0, 0, c);\n        d = this.getClosestIndex(d, \"time\", b, !1, h, c);\n        g.timeZoom(a, b);\n        g.zoom(h, d);\n        this.start = e.fitToBounds(h, 0, c);\n        this.end = e.fitToBounds(d, 0, c);\n        this.zoomAxesAndGraphs();\n        this.zoomScrollbar();\n        this.fixCursor();\n        this.showZB();\n        this.syncGrid();\n        this.updateColumnsDepth();\n        this.dispatchTimeZoomEvent();\n      }\n    },\n    showZB: function () {\n      var a,\n          b = this.categoryAxis;\n      b && b.parseDates && !b.equalSpacing && (this.startTime > this.firstTime && (a = !0), this.endTime < this.lastTime && (a = !0));\n      0 < this.start && (a = !0);\n      this.end < this.chartData.length - 1 && (a = !0);\n      if (b = this.valueAxes) b = b[0], isNaN(b.relativeStart) || (0 !== e.roundTo(b.relativeStart, 3) && (a = !0), 1 != e.roundTo(b.relativeEnd, 3) && (a = !0));\n      e.AmSerialChart.base.showZB.call(this, a);\n    },\n    updateAfterValueZoom: function () {\n      e.AmSerialChart.base.updateAfterValueZoom.call(this);\n      this.updateColumnsDepth();\n    },\n    indexZoom: function (a, b) {\n      var c = this.maxSelectedSeries,\n          d = !1;\n      isNaN(c) || (b != this.end && b - a > c && (a = b - c, d = !0), a != this.start && b - a > c && (b = a + c, d = !0));\n\n      if (d && (d = this.chartScrollbar) && d.dragger) {\n        var g = d.dragger.getBBox();\n        d.maxWidth = g.width;\n        d.maxHeight = g.height;\n      }\n\n      if (a != this.start || b != this.end) d = this.chartData.length - 1, isNaN(a) && (a = 0, isNaN(c) || (a = d - c)), isNaN(b) && (b = d), b < a && (b = a), b > d && (b = d), a > d && (a = d - 1), 0 > a && (a = 0), this.start = a, this.end = b, this.categoryAxis.zoom(a, b), this.zoomAxesAndGraphs(), this.zoomScrollbar(), this.fixCursor(), 0 !== a || b != this.chartData.length - 1 ? this.showZB(!0) : this.showZB(!1), this.syncGrid(), this.updateColumnsDepth(), this.dispatchIndexZoomEvent();\n    },\n    updateGraphs: function () {\n      e.AmSerialChart.base.updateGraphs.call(this);\n      var a = this.graphs,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b];\n        c.columnWidthReal = this.columnWidth;\n        c.categoryAxis = this.categoryAxis;\n        e.isString(c.fillToGraph) && (c.fillToGraph = this.graphsById[c.fillToGraph]);\n      }\n    },\n    zoomAxesAndGraphs: function () {\n      e.AmSerialChart.base.zoomAxesAndGraphs.call(this);\n      this.updateColumnsDepth();\n    },\n    updateColumnsDepth: function () {\n      if (0 !== this.depth3D || 0 !== this.angle) {\n        var a,\n            b = this.graphs,\n            c;\n        this.columnsArray = [];\n\n        for (a = 0; a < b.length; a++) {\n          c = b[a];\n          var d = c.columnsArray;\n\n          if (d) {\n            var g;\n\n            for (g = 0; g < d.length; g++) this.columnsArray.push(d[g]);\n          }\n        }\n\n        this.columnsArray.sort(this.compareDepth);\n        b = this.columnsSet;\n\n        if (0 < this.columnsArray.length) {\n          d = this.container.set();\n          this.columnSet.push(d);\n\n          for (a = 0; a < this.columnsArray.length; a++) d.push(this.columnsArray[a].column.set);\n\n          c && d.translate(c.x, c.y);\n          this.columnsSet = d;\n        }\n\n        e.remove(b);\n      }\n    },\n    compareDepth: function (a, b) {\n      return a.depth > b.depth ? 1 : -1;\n    },\n    zoomScrollbar: function () {\n      var a = this.chartScrollbar,\n          b = this.categoryAxis;\n\n      if (a) {\n        if (!this.zoomedByScrollbar) {\n          var c = a.dragger;\n          c && c.stop();\n        }\n\n        this.zoomedByScrollbar = !1;\n        b.parseDates && !b.equalSpacing ? a.timeZoom(this.startTime, this.endTime) : a.zoom(this.start, this.end);\n      }\n\n      this.zoomValueScrollbar(this.valueScrollbar);\n    },\n    updateTrendLines: function () {\n      var a = this.trendLines,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b],\n            c = e.processObject(c, e.TrendLine, this.theme);\n        a[b] = c;\n        c.chart = this;\n        c.id || (c.id = \"trendLineAuto\" + b + \"_\" + new Date().getTime());\n        e.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));\n        c.valueAxis || (c.valueAxis = this.valueAxes[0]);\n        c.categoryAxis = this.categoryAxis;\n      }\n    },\n    countColumns: function () {\n      var a = 0,\n          b = this.valueAxes.length,\n          c = this.graphs.length,\n          d,\n          g,\n          e = !1,\n          f,\n          k;\n\n      for (k = 0; k < b; k++) {\n        g = this.valueAxes[k];\n        var l = g.stackType,\n            m = 0;\n        if (\"100%\" == l || \"regular\" == l) for (e = !1, f = 0; f < c; f++) d = this.graphs[f], d.tcc = 1, d.valueAxis == g && \"column\" == d.type && (!e && d.stackable && (a++, e = !0), (!d.stackable && d.clustered || d.newStack && 0 !== m) && a++, d.columnIndex = a - 1, d.clustered || (d.columnIndex = 0), m++);\n\n        if (\"none\" == l || \"3d\" == l) {\n          m = !1;\n\n          for (f = 0; f < c; f++) d = this.graphs[f], d.valueAxis == g && \"column\" == d.type && (d.clustered ? (d.tcc = 1, d.newStack && (a = 0), d.hidden || (d.columnIndex = a, a++)) : d.hidden || (m = !0, d.tcc = 1, d.columnIndex = 0));\n\n          m && 0 === a && (a = 1);\n        }\n\n        if (\"3d\" == l) {\n          g = 1;\n\n          for (m = 0; m < c; m++) d = this.graphs[m], d.newStack && g++, d.depthCount = g, d.tcc = a;\n\n          a = g;\n        }\n      }\n\n      return a;\n    },\n    parseData: function () {\n      e.AmSerialChart.base.parseData.call(this);\n      this.parseSerialData(this.dataProvider);\n    },\n    getCategoryIndexByValue: function (a) {\n      var b = this.chartData,\n          c;\n\n      for (c = 0; c < b.length; c++) if (b[c].category == a) return c;\n    },\n    handleScrollbarZoom: function (a) {\n      this.zoomedByScrollbar = !0;\n      this.zoom(a.start, a.end);\n    },\n    dispatchTimeZoomEvent: function () {\n      if (this.drawGraphs && (this.prevStartTime != this.startTime || this.prevEndTime != this.endTime)) {\n        var a = {\n          type: \"zoomed\"\n        };\n        a.startDate = new Date(this.startTime);\n        a.endDate = new Date(this.endTime);\n        a.startIndex = this.start;\n        a.endIndex = this.end;\n        this.startIndex = this.start;\n        this.endIndex = this.end;\n        this.startDate = a.startDate;\n        this.endDate = a.endDate;\n        this.prevStartTime = this.startTime;\n        this.prevEndTime = this.endTime;\n        var b = this.categoryAxis,\n            c = e.extractPeriod(b.minPeriod).period,\n            b = b.dateFormatsObject[c];\n        a.startValue = e.formatDate(a.startDate, b, this);\n        a.endValue = e.formatDate(a.endDate, b, this);\n        a.chart = this;\n        a.target = this;\n        this.fire(a);\n      }\n    },\n    dispatchIndexZoomEvent: function () {\n      if (this.drawGraphs && (this.prevStartIndex != this.start || this.prevEndIndex != this.end)) {\n        this.startIndex = this.start;\n        this.endIndex = this.end;\n        var a = this.chartData;\n\n        if (e.ifArray(a) && !isNaN(this.start) && !isNaN(this.end)) {\n          var b = {\n            chart: this,\n            target: this,\n            type: \"zoomed\"\n          };\n          b.startIndex = this.start;\n          b.endIndex = this.end;\n          b.startValue = a[this.start].category;\n          b.endValue = a[this.end].category;\n          this.categoryAxis.parseDates && (this.startTime = a[this.start].time, this.endTime = a[this.end].time, b.startDate = new Date(this.startTime), b.endDate = new Date(this.endTime));\n          this.prevStartIndex = this.start;\n          this.prevEndIndex = this.end;\n          this.fire(b);\n        }\n      }\n    },\n    updateLegendValues: function () {\n      this.legend && this.legend.updateValues();\n    },\n    getClosestIndex: function (a, b, c, d, g, e) {\n      0 > g && (g = 0);\n      e > a.length - 1 && (e = a.length - 1);\n      var f = g + Math.round((e - g) / 2),\n          k = a[f][b];\n      return c == k ? f : 1 >= e - g ? d ? g : Math.abs(a[g][b] - c) < Math.abs(a[e][b] - c) ? g : e : c == k ? f : c < k ? this.getClosestIndex(a, b, c, d, g, f) : this.getClosestIndex(a, b, c, d, f, e);\n    },\n    zoomToIndexes: function (a, b) {\n      var c = this.chartData;\n\n      if (c) {\n        var d = c.length;\n        0 < d && (0 > a && (a = 0), b > d - 1 && (b = d - 1), d = this.categoryAxis, d.parseDates && !d.equalSpacing ? this.zoom(c[a].time, this.getEndTime(c[b].time)) : this.zoom(a, b));\n      }\n    },\n    zoomToDates: function (a, b) {\n      var c = this.chartData;\n      if (c) if (this.categoryAxis.equalSpacing) {\n        var d = this.getClosestIndex(c, \"time\", a.getTime(), !0, 0, c.length);\n        b = e.resetDateToMin(b, this.categoryAxis.minPeriod, 1);\n        c = this.getClosestIndex(c, \"time\", b.getTime(), !1, 0, c.length);\n        this.zoom(d, c);\n      } else this.zoom(a.getTime(), b.getTime());\n    },\n    zoomToCategoryValues: function (a, b) {\n      this.chartData && this.zoom(this.getCategoryIndexByValue(a), this.getCategoryIndexByValue(b));\n    },\n    formatPeriodString: function (a, b) {\n      if (b) {\n        b.periodDataItem = {};\n        b.periodPercentDataItem = {};\n        var c = [\"value\", \"open\", \"low\", \"high\", \"close\"],\n            d = \"value open low high close average sum count\".split(\" \"),\n            g = b.valueAxis,\n            h = this.chartData,\n            f = b.numberFormatter;\n        f || (f = this.nf);\n\n        for (var k = 0; k < c.length; k++) {\n          for (var l = c[k], m = 0, p = 0, n = 0, u = 0, v, x, E, t, r, B, q, w, y, C, F = this.start; F <= this.end; F++) {\n            var D = h[F];\n\n            if (D) {\n              var A = D.axes[g.id].graphs[b.id];\n\n              if (A) {\n                if (A.values) {\n                  var z = A.values[l],\n                      D = D.x.categoryAxis;\n\n                  if (this.rotate) {\n                    if (0 > D || D > A.graph.height) z = NaN;\n                  } else if (0 > D || D > A.graph.width) z = NaN;\n\n                  if (!isNaN(z)) {\n                    isNaN(v) && (v = z);\n                    x = z;\n                    if (isNaN(E) || E > z) E = z;\n                    if (isNaN(t) || t < z) t = z;\n                    r = e.getDecimals(m);\n                    D = e.getDecimals(z);\n                    m += z;\n                    m = e.roundTo(m, Math.max(r, D));\n                    p++;\n                    r = m / p;\n                  }\n                }\n\n                if (A.percents && (A = A.percents[l], !isNaN(A))) {\n                  isNaN(B) && (B = A);\n                  q = A;\n                  if (isNaN(w) || w > A) w = A;\n                  if (isNaN(y) || y < A) y = A;\n                  C = e.getDecimals(n);\n                  z = e.getDecimals(A);\n                  n += A;\n                  n = e.roundTo(n, Math.max(C, z));\n                  u++;\n                  C = n / u;\n                }\n              }\n            }\n          }\n\n          m = {\n            open: v,\n            close: x,\n            high: t,\n            low: E,\n            average: r,\n            sum: m,\n            count: p\n          };\n          n = {\n            open: B,\n            close: q,\n            high: y,\n            low: w,\n            average: C,\n            sum: n,\n            count: u\n          };\n          a = e.formatValue(a, m, d, f, l + \"\\\\.\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\n          a = e.formatValue(a, n, d, this.pf, \"percents\\\\.\" + l + \"\\\\.\");\n          b.periodDataItem[l] = m;\n          b.periodPercentDataItem[l] = n;\n        }\n      }\n\n      return a = e.cleanFromEmpty(a);\n    },\n    formatString: function (a, b, c) {\n      if (b) {\n        var d = b.graph;\n\n        if (void 0 !== a) {\n          if (-1 != a.indexOf(\"[[category]]\")) {\n            var g = b.serialDataItem.category;\n\n            if (this.categoryAxis.parseDates) {\n              var h = this.balloonDateFormat,\n                  f = this.chartCursor;\n              f && f.categoryBalloonDateFormat && (h = f.categoryBalloonDateFormat);\n              h = e.formatDate(g, h, this);\n              -1 != h.indexOf(\"fff\") && (h = e.formatMilliseconds(h, g));\n              g = h;\n            }\n\n            a = a.replace(/\\[\\[category\\]\\]/g, String(g.replace(\"$\", \"$$$\")));\n          }\n\n          g = d.numberFormatter;\n          g || (g = this.nf);\n          h = b.graph.valueAxis;\n          (f = h.duration) && !isNaN(b.values.value) && (f = e.formatDuration(b.values.value, f, \"\", h.durationUnits, h.maxInterval, g), a = a.replace(RegExp(\"\\\\[\\\\[value\\\\]\\\\]\", \"g\"), f));\n          \"date\" == h.type && (h = e.formatDate(new Date(b.values.value), d.dateFormat, this), f = RegExp(\"\\\\[\\\\[value\\\\]\\\\]\", \"g\"), a = a.replace(f, h), h = e.formatDate(new Date(b.values.open), d.dateFormat, this), f = RegExp(\"\\\\[\\\\[open\\\\]\\\\]\", \"g\"), a = a.replace(f, h));\n          d = \"value open low high close total\".split(\" \");\n          h = this.pf;\n          a = e.formatValue(a, b.percents, d, h, \"percents\\\\.\");\n          a = e.formatValue(a, b.values, d, g, \"\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\n          a = e.formatValue(a, b.values, [\"percents\"], h);\n          -1 != a.indexOf(\"[[\") && (a = e.formatDataContextValue(a, b.dataContext));\n          -1 != a.indexOf(\"[[\") && b.graph.customData && (a = e.formatDataContextValue(a, b.graph.customData));\n          a = e.AmSerialChart.base.formatString.call(this, a, b, c);\n        }\n\n        return a;\n      }\n    },\n    updateChartCursor: function () {\n      e.AmSerialChart.base.updateChartCursor.call(this);\n      var a = this.chartCursor,\n          b = this.categoryAxis;\n\n      if (a) {\n        var c = a.categoryBalloonAlpha,\n            d = a.categoryBalloonColor,\n            g = a.color;\n        void 0 === d && (d = a.cursorColor);\n        var h = a.valueZoomable,\n            f = a.zoomable,\n            k = a.valueLineEnabled;\n        this.rotate ? (a.vLineEnabled = k, a.hZoomEnabled = h, a.vZoomEnabled = f) : (a.hLineEnabled = k, a.vZoomEnabled = h, a.hZoomEnabled = f);\n        if (a.valueLineBalloonEnabled) for (k = 0; k < this.valueAxes.length; k++) h = this.valueAxes[k], (f = h.balloon) || (f = {}), f = e.extend(f, this.balloon, !0), f.fillColor = d, f.balloonColor = d, f.fillAlpha = c, f.borderColor = d, f.color = g, h.balloon = f;else for (f = 0; f < this.valueAxes.length; f++) h = this.valueAxes[f], h.balloon && (h.balloon = null);\n        b && (b.balloonTextFunction = a.categoryBalloonFunction, a.categoryLineAxis = b, b.balloonText = a.categoryBalloonText, a.categoryBalloonEnabled && ((f = b.balloon) || (f = {}), f = e.extend(f, this.balloon, !0), f.fillColor = d, f.balloonColor = d, f.fillAlpha = c, f.borderColor = d, f.color = g, b.balloon = f), b.balloon && (b.balloon.enabled = a.categoryBalloonEnabled));\n      }\n    },\n    addChartScrollbar: function (a) {\n      e.callMethod(\"destroy\", [this.chartScrollbar]);\n      a && (a.chart = this, this.listenTo(a, \"zoomed\", this.handleScrollbarZoom));\n      this.rotate ? void 0 === a.width && (a.width = a.scrollbarHeight) : void 0 === a.height && (a.height = a.scrollbarHeight);\n      a.gridAxis = this.categoryAxis;\n      this.chartScrollbar = a;\n    },\n    addValueScrollbar: function (a) {\n      e.callMethod(\"destroy\", [this.valueScrollbar]);\n      a && (a.chart = this, this.listenTo(a, \"zoomed\", this.handleScrollbarValueZoom), this.listenTo(a, \"zoomStarted\", this.handleCursorZoomStarted));\n      var b = a.scrollbarHeight;\n      this.rotate ? void 0 === a.height && (a.height = b) : void 0 === a.width && (a.width = b);\n      a.gridAxis || (a.gridAxis = this.valueAxes[0]);\n      a.valueAxes = this.valueAxes;\n      this.valueScrollbar = a;\n    },\n    removeChartScrollbar: function () {\n      e.callMethod(\"destroy\", [this.chartScrollbar]);\n      this.chartScrollbar = null;\n    },\n    removeValueScrollbar: function () {\n      e.callMethod(\"destroy\", [this.valueScrollbar]);\n      this.valueScrollbar = null;\n    },\n    handleReleaseOutside: function (a) {\n      e.AmSerialChart.base.handleReleaseOutside.call(this, a);\n      e.callMethod(\"handleReleaseOutside\", [this.chartScrollbar, this.valueScrollbar]);\n    },\n    update: function () {\n      e.AmSerialChart.base.update.call(this);\n      this.chartScrollbar && this.chartScrollbar.update && this.chartScrollbar.update();\n      this.valueScrollbar && this.valueScrollbar.update && this.valueScrollbar.update();\n    },\n    processScrollbars: function () {\n      e.AmSerialChart.base.processScrollbars.call(this);\n      var a = this.valueScrollbar;\n      a && (a = e.processObject(a, e.ChartScrollbar, this.theme), a.id = \"valueScrollbar\", this.addValueScrollbar(a));\n    },\n    handleValueAxisZoom: function (a) {\n      this.handleValueAxisZoomReal(a, this.valueAxes);\n    },\n    zoomOut: function () {\n      e.AmSerialChart.base.zoomOut.call(this);\n      this.zoom();\n      this.syncGrid();\n    },\n    getNextItem: function (a) {\n      var b = a.index,\n          c = this.chartData,\n          d = a.graph;\n      if (b + 1 < c.length) for (b += 1; b < c.length; b++) if (a = c[b]) if (a = a.axes[d.valueAxis.id].graphs[d.id], !isNaN(a.y)) return a;\n    },\n    handleCursorZoomReal: function (a, b, c, d, e) {\n      var h = e.target,\n          f,\n          k;\n      this.rotate ? (isNaN(a) || isNaN(b) || this.relativeZoomValueAxes(this.valueAxes, a, b) && this.updateAfterValueZoom(), h.vZoomEnabled && (f = e.start, k = e.end)) : (isNaN(c) || isNaN(d) || this.relativeZoomValueAxes(this.valueAxes, c, d) && this.updateAfterValueZoom(), h.hZoomEnabled && (f = e.start, k = e.end));\n      isNaN(f) || isNaN(k) || (a = this.categoryAxis, a.parseDates && !a.equalSpacing ? this.zoomToDates(new Date(f), new Date(k)) : this.zoomToIndexes(f, k));\n    },\n    handleCursorZoomStarted: function () {\n      var a = this.valueAxes;\n\n      if (a) {\n        var a = a[0],\n            b = a.relativeStart,\n            c = a.relativeEnd;\n        a.reversed && (b = 1 - a.relativeEnd, c = 1 - a.relativeStart);\n        this.rotate ? (this.startX0 = b, this.endX0 = c) : (this.startY0 = b, this.endY0 = c);\n      }\n\n      this.categoryAxis && (this.start0 = this.start, this.end0 = this.end, this.startTime0 = this.startTime, this.endTime0 = this.endTime);\n    },\n    fixCursor: function () {\n      this.chartCursor && this.chartCursor.fixPosition();\n      this.prevCursorItem = null;\n    },\n    handleCursorMove: function (a) {\n      e.AmSerialChart.base.handleCursorMove.call(this, a);\n      var b = a.target,\n          c = this.categoryAxis;\n      if (a.panning) this.handleCursorHide(a);else if (this.chartData && !b.isHidden) {\n        var d = this.graphs;\n\n        if (d) {\n          var g;\n          g = c.xToIndex(this.rotate ? a.y : a.x);\n\n          if (g = this.chartData[g]) {\n            var h, f, k, l;\n\n            if (b.oneBalloonOnly && b.valueBalloonsEnabled) {\n              var m = Infinity;\n\n              for (h = d.length - 1; 0 <= h; h--) if (f = d[h], f.balloon.enabled && f.showBalloon && !f.hidden) {\n                k = f.valueAxis.id;\n                k = g.axes[k].graphs[f.id];\n                if (b.showNextAvailable && isNaN(k.y) && (k = this.getNextItem(k), !k)) continue;\n                k = k.y;\n                \"top\" == f.showBalloonAt && (k = 0);\n                \"bottom\" == f.showBalloonAt && (k = this.height);\n                var p = b.mouseX,\n                    n = b.mouseY;\n                k = this.rotate ? Math.abs(p - k) : Math.abs(n - k);\n                k < m && (m = k, l = f);\n              }\n\n              b.mostCloseGraph = l;\n            }\n\n            if (this.prevCursorItem != g || l != this.prevMostCloseGraph) {\n              m = [];\n\n              for (h = 0; h < d.length; h++) {\n                f = d[h];\n                k = f.valueAxis.id;\n                k = g.axes[k].graphs[f.id];\n\n                if (b.showNextAvailable && isNaN(k.y) && (k = this.getNextItem(k), !k && f.balloon)) {\n                  f.balloon.hide();\n                  continue;\n                }\n\n                l && f != l ? (f.showGraphBalloon(k, b.pointer, !1, b.graphBulletSize, b.graphBulletAlpha), f.balloon.hide(0)) : b.valueBalloonsEnabled ? (f.balloon.showBullet = b.bulletsEnabled, f.balloon.bulletSize = b.bulletSize / 2, a.hideBalloons || (f.showGraphBalloon(k, b.pointer, !1, b.graphBulletSize, b.graphBulletAlpha), f.balloon.set && m.push({\n                  balloon: f.balloon,\n                  y: f.balloon.pointToY\n                }))) : (f.currentDataItem = k, f.resizeBullet(k, b.graphBulletSize, b.graphBulletAlpha));\n              }\n\n              b.avoidBalloonOverlapping && this.arrangeBalloons(m);\n              this.prevCursorItem = g;\n            }\n\n            this.prevMostCloseGraph = l;\n          }\n        }\n\n        c.showBalloon(a.x, a.y, b.categoryBalloonDateFormat, a.skip);\n        this.updateLegendValues();\n      }\n    },\n    handleCursorHide: function (a) {\n      e.AmSerialChart.base.handleCursorHide.call(this, a);\n      a = this.categoryAxis;\n      this.prevCursorItem = null;\n      this.updateLegendValues();\n      a && a.hideBalloon();\n      a = this.graphs;\n      var b;\n\n      for (b = 0; b < a.length; b++) a[b].currentDataItem = null;\n    },\n    handleCursorPanning: function (a) {\n      var b = a.target,\n          c,\n          d = a.deltaX,\n          g = a.deltaY,\n          h = a.delta2X,\n          f = a.delta2Y;\n      a = !1;\n\n      if (this.rotate) {\n        isNaN(h) && (h = d, a = !0);\n        var k = this.endX0;\n        c = this.startX0;\n        var l = k - c,\n            k = k - l * h,\n            m = l;\n        a || (m = 0);\n        a = e.fitToBounds(c - l * d, 0, 1 - m);\n      } else isNaN(f) && (f = g, a = !0), k = this.endY0, c = this.startY0, l = k - c, k += l * g, m = l, a || (m = 0), a = e.fitToBounds(c + l * f, 0, 1 - m);\n\n      c = e.fitToBounds(k, m, 1);\n      var p;\n      b.valueZoomable && (p = this.relativeZoomValueAxes(this.valueAxes, a, c));\n      var n;\n      c = this.categoryAxis;\n      this.rotate && (d = g, h = f);\n      a = !1;\n      isNaN(h) && (h = d, a = !0);\n      if (b.zoomable && (0 < Math.abs(d) || 0 < Math.abs(h))) if (c.parseDates && !c.equalSpacing) {\n        if (f = this.startTime0, g = this.endTime0, c = g - f, h *= c, l = this.firstTime, k = this.lastTime, m = c, a || (m = 0), a = Math.round(e.fitToBounds(f - c * d, l, k - m)), h = Math.round(e.fitToBounds(g - h, l + m, k)), this.startTime != a || this.endTime != h) n = {\n          chart: this,\n          target: b,\n          type: \"zoomed\",\n          start: a,\n          end: h\n        }, this.skipZoomed = !0, b.fire(n), this.zoom(a, h), n = !0;\n      } else if (f = this.start0, g = this.end0, c = g - f, d = Math.round(c * d), h = Math.round(c * h), l = this.chartData.length - 1, a || (c = 0), a = e.fitToBounds(f - d, 0, l - c), c = e.fitToBounds(g - h, c, l), this.start != a || this.end != c) this.skipZoomed = !0, b.fire({\n        chart: this,\n        target: b,\n        type: \"zoomed\",\n        start: a,\n        end: c\n      }), this.zoom(a, c), n = !0;\n      !n && p && this.updateAfterValueZoom();\n    },\n    arrangeBalloons: function (a) {\n      var b = this.plotAreaHeight;\n      a.sort(this.compareY);\n      var c,\n          d,\n          e,\n          h = this.plotAreaWidth,\n          f = a.length;\n\n      for (c = 0; c < f; c++) d = a[c].balloon, d.setBounds(0, 0, h, b), d.restorePrevious(), d.draw(), b = d.yPos - 3;\n\n      a.reverse();\n\n      for (c = 0; c < f; c++) {\n        d = a[c].balloon;\n        var b = d.bottom,\n            k = d.bottom - d.yPos;\n        0 < c && b - k < e + 3 && d.setBounds && (d.setBounds(0, e + 3, h, e + k + 3), d.restorePrevious(), d.draw());\n        d.set && d.set.show();\n        e = d.bottom;\n      }\n    },\n    compareY: function (a, b) {\n      return a.y < b.y ? 1 : -1;\n    }\n  });\n})();\n\n(function () {\n  var e = window.AmCharts;\n  e.Cuboid = e.Class({\n    construct: function (a, b, c, d, e, h, f, k, l, m, p, n, u, v, x, E, t) {\n      this.set = a.set();\n      this.container = a;\n      this.h = Math.round(c);\n      this.w = Math.round(b);\n      this.dx = d;\n      this.dy = e;\n      this.colors = h;\n      this.alpha = f;\n      this.bwidth = k;\n      this.bcolor = l;\n      this.balpha = m;\n      this.dashLength = v;\n      this.topRadius = E;\n      this.pattern = x;\n      this.rotate = u;\n      this.bcn = t;\n      u ? 0 > b && 0 === p && (p = 180) : 0 > c && 270 == p && (p = 90);\n      this.gradientRotation = p;\n      0 === d && 0 === e && (this.cornerRadius = n);\n      this.draw();\n    },\n    draw: function () {\n      var a = this.set;\n      a.clear();\n      var b = this.container,\n          c = b.chart,\n          d = this.w,\n          g = this.h,\n          h = this.dx,\n          f = this.dy,\n          k = this.colors,\n          l = this.alpha,\n          m = this.bwidth,\n          p = this.bcolor,\n          n = this.balpha,\n          u = this.gradientRotation,\n          v = this.cornerRadius,\n          x = this.dashLength,\n          E = this.pattern,\n          t = this.topRadius,\n          r = this.bcn,\n          B = k,\n          q = k;\n      \"object\" == typeof k && (B = k[0], q = k[k.length - 1]);\n      var w,\n          y,\n          C,\n          F,\n          D,\n          A,\n          z,\n          L,\n          M,\n          Q = l;\n      E && (l = 0);\n      var G,\n          H,\n          I,\n          J,\n          K = this.rotate;\n      if (0 < Math.abs(h) || 0 < Math.abs(f)) if (isNaN(t)) z = q, q = e.adjustLuminosity(B, -.2), q = e.adjustLuminosity(B, -.2), w = e.polygon(b, [0, h, d + h, d, 0], [0, f, f, 0, 0], q, l, 1, p, 0, u), 0 < n && (M = e.line(b, [0, h, d + h], [0, f, f], p, n, m, x)), y = e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], q, l, 1, p, 0, u), y.translate(h, f), 0 < n && (C = e.line(b, [h, h], [f, f + g], p, n, m, x)), F = e.polygon(b, [0, 0, h, h, 0], [0, g, g + f, f, 0], q, l, 1, p, 0, u), D = e.polygon(b, [d, d, d + h, d + h, d], [0, g, g + f, f, 0], q, l, 1, p, 0, u), 0 < n && (A = e.line(b, [d, d + h, d + h, d], [0, f, g + f, g], p, n, m, x)), q = e.adjustLuminosity(z, .2), z = e.polygon(b, [0, h, d + h, d, 0], [g, g + f, g + f, g, g], q, l, 1, p, 0, u), 0 < n && (L = e.line(b, [0, h, d + h], [g, g + f, g + f], p, n, m, x));else {\n        var N, O, P;\n        K ? (N = g / 2, q = h / 2, P = g / 2, O = d + h / 2, H = Math.abs(g / 2), G = Math.abs(h / 2)) : (q = d / 2, N = f / 2, O = d / 2, P = g + f / 2 + 1, G = Math.abs(d / 2), H = Math.abs(f / 2));\n        I = G * t;\n        J = H * t;\n        .1 < G && .1 < G && (w = e.circle(b, G, B, l, m, p, n, !1, H), w.translate(q, N));\n        .1 < I && .1 < I && (z = e.circle(b, I, e.adjustLuminosity(B, .5), l, m, p, n, !1, J), z.translate(O, P));\n      }\n      l = Q;\n      1 > Math.abs(g) && (g = 0);\n      1 > Math.abs(d) && (d = 0);\n      !isNaN(t) && (0 < Math.abs(h) || 0 < Math.abs(f)) ? (k = [B], k = {\n        fill: k,\n        stroke: p,\n        \"stroke-width\": m,\n        \"stroke-opacity\": n,\n        \"fill-opacity\": l\n      }, K ? (l = \"M0,0 L\" + d + \",\" + (g / 2 - g / 2 * t), m = \" B\", 0 < d && (m = \" A\"), e.VML ? (l += m + Math.round(d - I) + \",\" + Math.round(g / 2 - J) + \",\" + Math.round(d + I) + \",\" + Math.round(g / 2 + J) + \",\" + d + \",0,\" + d + \",\" + g, l = l + (\" L0,\" + g) + (m + Math.round(-G) + \",\" + Math.round(g / 2 - H) + \",\" + Math.round(G) + \",\" + Math.round(g / 2 + H) + \",0,\" + g + \",0,0\")) : (l += \"A\" + I + \",\" + J + \",0,0,0,\" + d + \",\" + (g - g / 2 * (1 - t)) + \"L0,\" + g, l += \"A\" + G + \",\" + H + \",0,0,1,0,0\"), G = 90) : (m = d / 2 - d / 2 * t, l = \"M0,0 L\" + m + \",\" + g, e.VML ? (l = \"M0,0 L\" + m + \",\" + g, m = \" B\", 0 > g && (m = \" A\"), l += m + Math.round(d / 2 - I) + \",\" + Math.round(g - J) + \",\" + Math.round(d / 2 + I) + \",\" + Math.round(g + J) + \",0,\" + g + \",\" + d + \",\" + g, l += \" L\" + d + \",0\", l += m + Math.round(d / 2 + G) + \",\" + Math.round(H) + \",\" + Math.round(d / 2 - G) + \",\" + Math.round(-H) + \",\" + d + \",0,0,0\") : (l += \"A\" + I + \",\" + J + \",0,0,0,\" + (d - d / 2 * (1 - t)) + \",\" + g + \"L\" + d + \",0\", l += \"A\" + G + \",\" + H + \",0,0,1,0,0\"), G = 180), b = b.path(l).attr(k), b.gradient(\"linearGradient\", [B, e.adjustLuminosity(B, -.3), e.adjustLuminosity(B, -.3), B], G), K ? b.translate(h / 2, 0) : b.translate(0, f / 2)) : b = 0 === g ? e.line(b, [0, d], [0, 0], p, n, m, x) : 0 === d ? e.line(b, [0, 0], [0, g], p, n, m, x) : 0 < v ? e.rect(b, d, g, k, l, m, p, n, v, u, x) : e.polygon(b, [0, 0, d, d, 0], [0, g, g, 0, 0], k, l, m, p, n, u, !1, x);\n      d = isNaN(t) ? 0 > g ? [w, M, y, C, F, D, A, z, L, b] : [z, L, y, C, F, D, w, M, A, b] : K ? 0 < d ? [w, b, z] : [z, b, w] : 0 > g ? [w, b, z] : [z, b, w];\n      e.setCN(c, b, r + \"front\");\n      e.setCN(c, y, r + \"back\");\n      e.setCN(c, z, r + \"top\");\n      e.setCN(c, w, r + \"bottom\");\n      e.setCN(c, F, r + \"left\");\n      e.setCN(c, D, r + \"right\");\n\n      for (w = 0; w < d.length; w++) if (y = d[w]) a.push(y), e.setCN(c, y, r + \"element\");\n\n      E && b.pattern(E, NaN, c.path);\n    },\n    width: function (a) {\n      isNaN(a) && (a = 0);\n      this.w = Math.round(a);\n      this.draw();\n    },\n    height: function (a) {\n      isNaN(a) && (a = 0);\n      this.h = Math.round(a);\n      this.draw();\n    },\n    animateHeight: function (a, b) {\n      var c = this;\n      c.animationFinished = !1;\n      c.easing = b;\n      c.totalFrames = a * e.updateRate;\n      c.rh = c.h;\n      c.frame = 0;\n      c.height(1);\n      setTimeout(function () {\n        c.updateHeight.call(c);\n      }, 1E3 / e.updateRate);\n    },\n    updateHeight: function () {\n      var a = this;\n      a.frame++;\n      var b = a.totalFrames;\n      a.frame <= b ? (b = a.easing(0, a.frame, 1, a.rh - 1, b), a.height(b), window.requestAnimationFrame ? window.requestAnimationFrame(function () {\n        a.updateHeight.call(a);\n      }) : setTimeout(function () {\n        a.updateHeight.call(a);\n      }, 1E3 / e.updateRate)) : (a.height(a.rh), a.animationFinished = !0);\n    },\n    animateWidth: function (a, b) {\n      var c = this;\n      c.animationFinished = !1;\n      c.easing = b;\n      c.totalFrames = a * e.updateRate;\n      c.rw = c.w;\n      c.frame = 0;\n      c.width(1);\n      setTimeout(function () {\n        c.updateWidth.call(c);\n      }, 1E3 / e.updateRate);\n    },\n    updateWidth: function () {\n      var a = this;\n      a.frame++;\n      var b = a.totalFrames;\n      a.frame <= b ? (b = a.easing(0, a.frame, 1, a.rw - 1, b), a.width(b), window.requestAnimationFrame ? window.requestAnimationFrame(function () {\n        a.updateWidth.call(a);\n      }) : setTimeout(function () {\n        a.updateWidth.call(a);\n      }, 1E3 / e.updateRate)) : (a.width(a.rw), a.animationFinished = !0);\n    }\n  });\n})();\n\n(function () {\n  var e = window.AmCharts;\n  e.CategoryAxis = e.Class({\n    inherits: e.AxisBase,\n    construct: function (a) {\n      this.cname = \"CategoryAxis\";\n      e.CategoryAxis.base.construct.call(this, a);\n      this.minPeriod = \"DD\";\n      this.equalSpacing = this.parseDates = !1;\n      this.position = \"bottom\";\n      this.startOnAxis = !1;\n      this.gridPosition = \"middle\";\n      this.safeDistance = 30;\n      this.stickBalloonToCategory = !1;\n      e.applyTheme(this, a, this.cname);\n    },\n    draw: function () {\n      e.CategoryAxis.base.draw.call(this);\n      this.generateDFObject();\n      var a = this.chart.chartData;\n      this.data = a;\n      this.labelRotationR = this.labelRotation;\n      this.type = null;\n\n      if (e.ifArray(a)) {\n        var b,\n            c = this.chart;\n        \"scrollbar\" != this.id ? (e.setCN(c, this.set, \"category-axis\"), e.setCN(c, this.labelsSet, \"category-axis\"), e.setCN(c, this.axisLine.axisSet, \"category-axis\")) : this.bcn = this.id + \"-\";\n        var d = this.start,\n            g = this.labelFrequency,\n            h = 0,\n            f = this.end - d + 1,\n            k = this.gridCountR,\n            l = this.showFirstLabel,\n            m = this.showLastLabel,\n            p,\n            n = \"\",\n            n = e.extractPeriod(this.minPeriod),\n            u = e.getPeriodDuration(n.period, n.count),\n            v,\n            x,\n            E,\n            t,\n            r,\n            B = this.rotate,\n            q = this.firstDayOfWeek,\n            w = this.boldPeriodBeginning;\n        b = e.resetDateToMin(new Date(a[a.length - 1].time + 1.05 * u), this.minPeriod, 1, q).getTime();\n        this.firstTime = c.firstTime;\n        this.endTime > b && (this.endTime = b);\n        r = this.minorGridEnabled;\n        x = this.gridAlpha;\n        var y = 0,\n            C = 0;\n        if (this.widthField) for (b = this.start; b <= this.end; b++) if (t = this.data[b]) {\n          var F = Number(this.data[b].dataContext[this.widthField]);\n          isNaN(F) || (y += F, t.widthValue = F);\n        }\n        if (this.parseDates && !this.equalSpacing) this.lastTime = a[a.length - 1].time, this.maxTime = e.resetDateToMin(new Date(this.lastTime + 1.05 * u), this.minPeriod, 1, q).getTime(), this.timeDifference = this.endTime - this.startTime, this.parseDatesDraw();else if (!this.parseDates) {\n          if (this.cellWidth = this.getStepWidth(f), f < k && (k = f), h += this.start, this.stepWidth = this.getStepWidth(f), 0 < k) for (q = Math.floor(f / k), t = this.chooseMinorFrequency(q), f = h, f / 2 == Math.round(f / 2) && f--, 0 > f && (f = 0), w = 0, this.widthField && (f = this.start, q = 1), this.end - f + 1 >= this.autoRotateCount && (this.labelRotationR = this.autoRotateAngle), b = f; b <= this.end + 2; b++) {\n            k = !1;\n            0 <= b && b < this.data.length ? (v = this.data[b], n = v.category, k = v.forceShow) : n = \"\";\n            if (r && !isNaN(t)) {\n              if (b / t == Math.round(b / t) || k) b / q == Math.round(b / q) || k || (this.gridAlpha = this.minorGridAlpha, n = void 0);else continue;\n            } else if (b / q != Math.round(b / q) && !k) continue;\n            f = this.getCoordinate(b - h);\n            k = 0;\n            \"start\" == this.gridPosition && (f -= this.cellWidth / 2, k = this.cellWidth / 2);\n            p = !0;\n            E = k;\n            \"start\" == this.tickPosition && (E = 0, p = !1, k = 0);\n            if (b == d && !l || b == this.end && !m) n = void 0;\n            Math.round(w / g) != w / g && (n = void 0);\n            w++;\n            a = this.cellWidth;\n            B && (a = NaN, this.ignoreAxisWidth || !c.autoMargins) && (a = \"right\" == this.position ? c.marginRight - this.titleWidth : c.marginLeft - this.titleWidth, a -= this.tickLength + 10);\n            this.labelFunction && v && (n = this.labelFunction(n, v, this));\n            n = e.fixBrakes(n);\n            u = !1;\n            this.boldLabels && (u = !0);\n            b > this.end && \"start\" == this.tickPosition && (n = \" \");\n            this.rotate && this.inside && (k -= 2);\n            isNaN(v.widthValue) || (v.percentWidthValue = v.widthValue / y * 100, a = this.rotate ? this.height * v.widthValue / y : this.width * v.widthValue / y, f = C, C += a, E = k = a / 2);\n            p = new this.axisItemRenderer(this, f, n, p, a, k, void 0, u, E, !1, v.labelColor, v.className);\n            p.serialDataItem = v;\n            this.pushAxisItem(p);\n            this.gridAlpha = x;\n          }\n        } else if (this.parseDates && this.equalSpacing) {\n          h = this.start;\n          this.startTime = this.data[this.start].time;\n          this.endTime = this.data[this.end].time;\n          this.timeDifference = this.endTime - this.startTime;\n          b = this.choosePeriod(0);\n          g = b.period;\n          v = b.count;\n          b = e.getPeriodDuration(g, v);\n          b < u && (g = n.period, v = n.count, b = u);\n          x = g;\n          \"WW\" == x && (x = \"DD\");\n          this.currentDateFormat = this.dateFormatsObject[x];\n          this.stepWidth = this.getStepWidth(f);\n          k = Math.ceil(this.timeDifference / b) + 1;\n          n = e.resetDateToMin(new Date(this.startTime - b), g, v, q).getTime();\n          this.cellWidth = this.getStepWidth(f);\n          f = Math.round(n / b);\n          d = -1;\n          f / 2 == Math.round(f / 2) && (d = -2, n -= b);\n          f = this.start;\n          f / 2 == Math.round(f / 2) && f--;\n          0 > f && (f = 0);\n          C = this.end + 2;\n          C >= this.data.length && (C = this.data.length);\n          a = !1;\n          a = !l;\n          this.previousPos = -1E3;\n          20 < this.labelRotationR && (this.safeDistance = 5);\n          F = f;\n\n          if (this.data[f].time != e.resetDateToMin(new Date(this.data[f].time), g, v, q).getTime()) {\n            var u = 0,\n                D = n;\n\n            for (b = f; b < C; b++) t = this.data[b].time, this.checkPeriodChange(g, v, t, D) && (u++, 2 <= u && (F = b, b = C), D = t);\n          }\n\n          r && 1 < v && (t = this.chooseMinorFrequency(v), e.getPeriodDuration(g, t));\n          if (0 < this.gridCountR) for (b = f; b < C; b++) if (t = this.data[b].time, this.checkPeriodChange(g, v, t, n) && b >= F) {\n            f = this.getCoordinate(b - this.start);\n            r = !1;\n            this.nextPeriod[x] && (r = this.checkPeriodChange(this.nextPeriod[x], 1, t, n, x)) && e.resetDateToMin(new Date(t), this.nextPeriod[x], 1, q).getTime() != t && (r = !1);\n            u = !1;\n            r && this.markPeriodChange ? (r = this.dateFormatsObject[this.nextPeriod[x]], u = !0) : r = this.dateFormatsObject[x];\n            n = e.formatDate(new Date(t), r, c);\n            if (b == d && !l || b == k && !m) n = \" \";\n            a ? a = !1 : (w || (u = !1), f - this.previousPos > this.safeDistance * Math.cos(this.labelRotationR * Math.PI / 180) && (this.labelFunction && (n = this.labelFunction(n, new Date(t), this, g, v, E)), this.boldLabels && (u = !0), p = new this.axisItemRenderer(this, f, n, void 0, void 0, void 0, void 0, u), r = p.graphics(), this.pushAxisItem(p), r = r.getBBox().width, e.isModern || (r -= f), this.previousPos = f + r));\n            E = n = t;\n          }\n        }\n\n        for (b = l = 0; b < this.data.length; b++) if (t = this.data[b]) this.parseDates && !this.equalSpacing ? (m = t.time, d = this.cellWidth, \"MM\" == this.minPeriod && (d = 864E5 * e.daysInMonth(new Date(m)) * this.stepWidth, t.cellWidth = d), m = Math.round((m - this.startTime) * this.stepWidth + d / 2)) : m = this.getCoordinate(b - h), t.x[this.id] = m;\n\n        if (this.widthField) for (b = this.start; b <= this.end; b++) t = this.data[b], d = t.widthValue, t.percentWidthValue = d / y * 100, this.rotate ? (m = this.height * d / y / 2 + l, l = this.height * d / y + l) : (m = this.width * d / y / 2 + l, l = this.width * d / y + l), t.x[this.id] = m;\n        y = this.guides.length;\n\n        for (b = 0; b < y; b++) if (l = this.guides[b], q = q = q = r = d = NaN, m = l.above, l.toCategory && (q = c.getCategoryIndexByValue(l.toCategory), isNaN(q) || (d = this.getCoordinate(q - h), l.expand && (d += this.cellWidth / 2), p = new this.axisItemRenderer(this, d, \"\", !0, NaN, NaN, l), this.pushAxisItem(p, m))), l.category && (q = c.getCategoryIndexByValue(l.category), isNaN(q) || (r = this.getCoordinate(q - h), l.expand && (r -= this.cellWidth / 2), q = (d - r) / 2, p = new this.axisItemRenderer(this, r, l.label, !0, NaN, q, l), this.pushAxisItem(p, m))), w = c.dataDateFormat, l.toDate && (!w || l.toDate instanceof Date || (l.toDate = l.toDate.toString() + \" |\"), l.toDate = e.getDate(l.toDate, w), this.equalSpacing ? (q = c.getClosestIndex(this.data, \"time\", l.toDate.getTime(), !1, 0, this.data.length - 1), isNaN(q) || (d = this.getCoordinate(q - h))) : d = (l.toDate.getTime() - this.startTime) * this.stepWidth, p = new this.axisItemRenderer(this, d, \"\", !0, NaN, NaN, l), this.pushAxisItem(p, m)), l.date && (!w || l.date instanceof Date || (l.date = l.date.toString() + \" |\"), l.date = e.getDate(l.date, w), this.equalSpacing ? (q = c.getClosestIndex(this.data, \"time\", l.date.getTime(), !1, 0, this.data.length - 1), isNaN(q) || (r = this.getCoordinate(q - h))) : r = (l.date.getTime() - this.startTime) * this.stepWidth, q = (d - r) / 2, p = !0, l.toDate && (p = !1), p = \"H\" == this.orientation ? new this.axisItemRenderer(this, r, l.label, p, 2 * q, NaN, l) : new this.axisItemRenderer(this, r, l.label, !1, NaN, q, l), this.pushAxisItem(p, m)), p && (q = p.label) && this.addEventListeners(q, l), 0 < d || 0 < r) {\n          q = !1;\n\n          if (this.rotate) {\n            if (d < this.height || r < this.height) q = !0;\n          } else if (d < this.width || r < this.width) q = !0;\n\n          q && (d = new this.guideFillRenderer(this, r, d, l), r = d.graphics(), this.pushAxisItem(d, m), l.graphics = r, r.index = b, this.addEventListeners(r, l));\n        }\n\n        if (c = c.chartCursor) B ? c.fixHeight(this.cellWidth) : (c.fixWidth(this.cellWidth), c.fullWidth && this.balloon && (this.balloon.minWidth = this.cellWidth));\n        this.previousHeight = A;\n      }\n\n      this.axisCreated = !0;\n      this.set.translate(this.x, this.y);\n      this.labelsSet.translate(this.x, this.y);\n      this.labelsSet.show();\n      this.positionTitle();\n      (B = this.axisLine.set) && B.toFront();\n      var A = this.getBBox().height;\n      2 < A - this.previousHeight && this.autoWrap && !this.parseDates && (this.axisCreated = this.chart.marginsUpdated = !1);\n    },\n    xToIndex: function (a) {\n      var b = this.data,\n          c = this.chart,\n          d = c.rotate,\n          g = this.stepWidth,\n          h;\n      if (this.parseDates && !this.equalSpacing) a = this.startTime + Math.round(a / g) - this.minDuration() / 2, h = c.getClosestIndex(b, \"time\", a, !1, this.start, this.end + 1);else if (this.widthField) for (c = Infinity, g = this.start; g <= this.end; g++) {\n        var f = this.data[g];\n        f && (f = Math.abs(f.x[this.id] - a), f < c && (c = f, h = g));\n      } else this.startOnAxis || (a -= g / 2), h = this.start + Math.round(a / g);\n      h = e.fitToBounds(h, 0, b.length - 1);\n      var k;\n      b[h] && (k = b[h].x[this.id]);\n      d ? k > this.height + 1 && h-- : k > this.width + 1 && h--;\n      0 > k && h++;\n      return h = e.fitToBounds(h, 0, b.length - 1);\n    },\n    dateToCoordinate: function (a) {\n      return this.parseDates && !this.equalSpacing ? (a.getTime() - this.startTime) * this.stepWidth : this.parseDates && this.equalSpacing ? (a = this.chart.getClosestIndex(this.data, \"time\", a.getTime(), !1, 0, this.data.length - 1), this.getCoordinate(a - this.start)) : NaN;\n    },\n    categoryToCoordinate: function (a) {\n      if (this.chart) {\n        if (this.parseDates) return this.dateToCoordinate(new Date(a));\n        a = this.chart.getCategoryIndexByValue(a);\n        if (!isNaN(a)) return this.getCoordinate(a - this.start);\n      } else return NaN;\n    },\n    coordinateToDate: function (a) {\n      return this.equalSpacing ? (a = this.xToIndex(a), new Date(this.data[a].time)) : new Date(this.startTime + a / this.stepWidth);\n    },\n    coordinateToValue: function (a) {\n      a = this.xToIndex(a);\n      if (a = this.data[a]) return this.parseDates ? a.time : a.category;\n    },\n    getCoordinate: function (a) {\n      a *= this.stepWidth;\n      this.startOnAxis || (a += this.stepWidth / 2);\n      return Math.round(a);\n    },\n    formatValue: function (a, b) {\n      b || (b = this.currentDateFormat);\n      this.parseDates && (a = e.formatDate(new Date(a), b, this.chart));\n      return a;\n    },\n    showBalloonAt: function (a, b) {\n      void 0 === b && (b = this.parseDates ? this.dateToCoordinate(new Date(a)) : this.categoryToCoordinate(a));\n      return this.adjustBalloonCoordinate(b);\n    },\n    formatBalloonText: function (a, b, c) {\n      var d = \"\",\n          g = \"\",\n          h = this.chart,\n          f = this.data[b];\n      if (f) if (this.parseDates) d = e.formatDate(f.category, c, h), b = e.changeDate(new Date(f.category), this.minPeriod, 1), g = e.formatDate(b, c, h), -1 != d.indexOf(\"fff\") && (d = e.formatMilliseconds(d, f.category), g = e.formatMilliseconds(g, b));else {\n        var k;\n        this.data[b + 1] && (k = this.data[b + 1]);\n        d = e.fixNewLines(f.category);\n        k && (g = e.fixNewLines(k.category));\n      }\n      a = a.replace(/\\[\\[category\\]\\]/g, String(d));\n      return a = a.replace(/\\[\\[toCategory\\]\\]/g, String(g));\n    },\n    adjustBalloonCoordinate: function (a, b) {\n      var c = this.xToIndex(a),\n          d = this.chart.chartCursor;\n\n      if (this.stickBalloonToCategory) {\n        var e = this.data[c];\n        e && (a = e.x[this.id]);\n        this.stickBalloonToStart && (a -= this.cellWidth / 2);\n        var h = 0;\n\n        if (d) {\n          var f = d.limitToGraph;\n\n          if (f) {\n            var k = f.valueAxis.id;\n            f.hidden || (h = e.axes[k].graphs[f.id].y);\n          }\n\n          this.rotate ? (\"left\" == this.position ? (f && (h -= d.width), 0 < h && (h = 0)) : 0 > h && (h = 0), d.fixHLine(a, h)) : (\"top\" == this.position ? (f && (h -= d.height), 0 < h && (h = 0)) : 0 > h && (h = 0), d.fullWidth && (a += 1), d.fixVLine(a, h));\n        }\n      }\n\n      d && !b && (d.setIndex(c), this.parseDates && d.setTimestamp(this.coordinateToDate(a).getTime()));\n      return a;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}