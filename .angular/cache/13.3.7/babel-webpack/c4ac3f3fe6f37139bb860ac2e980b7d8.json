{"ast":null,"code":"(function () {\n  var k = window.AmCharts;\n  k.AmSlicedChart = k.Class({\n    inherits: k.AmChart,\n    construct: function (a) {\n      this.createEvents(\"rollOverSlice\", \"rollOutSlice\", \"clickSlice\", \"pullOutSlice\", \"pullInSlice\", \"rightClickSlice\");\n      k.AmSlicedChart.base.construct.call(this, a);\n      this.colors = \"#FF0F00 #FF6600 #FF9E01 #FCD202 #F8FF01 #B0DE09 #04D215 #0D8ECF #0D52D1 #2A0CD0 #8A0CCF #CD0D74 #754DEB #DDDDDD #999999 #333333 #000000 #57032A #CA9726 #990000 #4B0C25\".split(\" \");\n      this.alpha = 1;\n      this.groupPercent = 0;\n      this.groupedTitle = \"Other\";\n      this.groupedPulled = !1;\n      this.groupedAlpha = 1;\n      this.marginLeft = 0;\n      this.marginBottom = this.marginTop = 10;\n      this.marginRight = 0;\n      this.hoverAlpha = 1;\n      this.outlineColor = \"#FFFFFF\";\n      this.outlineAlpha = 0;\n      this.outlineThickness = 1;\n      this.startAlpha = 0;\n      this.startDuration = 1;\n      this.startEffect = \"bounce\";\n      this.sequencedAnimation = !0;\n      this.pullOutDuration = 1;\n      this.pullOutEffect = \"bounce\";\n      this.pullOnHover = this.pullOutOnlyOne = !1;\n      this.labelsEnabled = !0;\n      this.labelTickColor = \"#000000\";\n      this.labelTickAlpha = .2;\n      this.hideLabelsPercent = 0;\n      this.urlTarget = \"_self\";\n      this.autoMarginOffset = 10;\n      this.gradientRatio = [];\n      this.maxLabelWidth = 200;\n      this.accessibleLabel = \"[[title]]: [[percents]]% [[value]] [[description]]\";\n      k.applyTheme(this, a, \"AmSlicedChart\");\n    },\n    initChart: function () {\n      k.AmSlicedChart.base.initChart.call(this);\n      this.dataChanged && (this.parseData(), this.dispatchDataUpdated = !0, this.dataChanged = !1, this.setLegendData(this.chartData));\n      this.drawChart();\n    },\n    handleLegendEvent: function (a) {\n      var b = a.type,\n          c = a.dataItem,\n          d = this.legend;\n\n      if (c.wedge && c) {\n        var g = c.hidden;\n        a = a.event;\n\n        switch (b) {\n          case \"clickMarker\":\n            g || d.switchable || this.clickSlice(c, a);\n            break;\n\n          case \"clickLabel\":\n            g || this.clickSlice(c, a, !1);\n            break;\n\n          case \"rollOverItem\":\n            g || this.rollOverSlice(c, !1, a);\n            break;\n\n          case \"rollOutItem\":\n            g || this.rollOutSlice(c, a);\n            break;\n\n          case \"hideItem\":\n            this.hideSlice(c, a);\n            break;\n\n          case \"showItem\":\n            this.showSlice(c, a);\n        }\n      }\n    },\n    invalidateVisibility: function () {\n      this.recalculatePercents();\n      this.initChart();\n      var a = this.legend;\n      a && a.invalidateSize();\n    },\n    addEventListeners: function (a, b) {\n      var c = this;\n      a.mouseover(function (a) {\n        c.rollOverSlice(b, !0, a);\n      }).mouseout(function (a) {\n        c.rollOutSlice(b, a);\n      }).touchend(function (a) {\n        c.rollOverSlice(b, a);\n      }).mouseup(function (a) {\n        c.clickSlice(b, a);\n      }).contextmenu(function (a) {\n        c.handleRightClick(b, a);\n      });\n    },\n    formatString: function (a, b, c) {\n      a = k.formatValue(a, b, [\"value\"], this.nf, \"\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\n      var d = this.pf.precision;\n      isNaN(this.tempPrec) || (this.pf.precision = this.tempPrec);\n      a = k.formatValue(a, b, [\"percents\"], this.pf);\n      a = k.massReplace(a, {\n        \"[[title]]\": b.title,\n        \"[[description]]\": b.description\n      });\n      this.pf.precision = d;\n      -1 != a.indexOf(\"[[\") && (a = k.formatDataContextValue(a, b.dataContext));\n      a = c ? k.fixNewLines(a) : k.fixBrakes(a);\n      return a = k.cleanFromEmpty(a);\n    },\n    startSlices: function () {\n      var a;\n\n      for (a = 0; a < this.chartData.length; a++) 0 < this.startDuration && this.sequencedAnimation ? this.setStartTO(a) : this.startSlice(this.chartData[a]);\n    },\n    setStartTO: function (a) {\n      var b = this;\n      a = setTimeout(function () {\n        b.startSequenced.call(b);\n      }, b.startDuration / b.chartData.length * 500 * a);\n      b.timeOuts.push(a);\n    },\n    pullSlices: function (a) {\n      var b = this.chartData,\n          c;\n\n      for (c = 0; c < b.length; c++) {\n        var d = b[c];\n        d.pulled && this.pullSlice(d, 1, a);\n      }\n    },\n    startSequenced: function () {\n      var a = this.chartData,\n          b;\n\n      for (b = 0; b < a.length; b++) if (!a[b].started) {\n        this.startSlice(this.chartData[b]);\n        break;\n      }\n    },\n    startSlice: function (a) {\n      a.started = !0;\n      var b = a.wedge,\n          c = this.startDuration,\n          d = a.labelSet;\n      b && 0 < c && (0 < a.alpha && b.show(), b.translate(a.startX, a.startY), this.animatable.push(b), b.animate({\n        opacity: 1,\n        translate: \"0,0\"\n      }, c, this.startEffect));\n      d && 0 < c && (0 < a.alpha && d.show(), d.translate(a.startX, a.startY), d.animate({\n        opacity: 1,\n        translate: \"0,0\"\n      }, c, this.startEffect));\n    },\n    showLabels: function () {\n      var a = this.chartData,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b];\n\n        if (0 < c.alpha) {\n          var d = c.label;\n          d && d.show();\n          (c = c.tick) && c.show();\n        }\n      }\n    },\n    showSlice: function (a) {\n      isNaN(a) ? a.hidden = !1 : this.chartData[a].hidden = !1;\n      this.invalidateVisibility();\n    },\n    hideSlice: function (a) {\n      isNaN(a) ? a.hidden = !0 : this.chartData[a].hidden = !0;\n      this.hideBalloon();\n      this.invalidateVisibility();\n    },\n    rollOverSlice: function (a, b, c) {\n      isNaN(a) || (a = this.chartData[a]);\n      clearTimeout(this.hoverInt);\n\n      if (!a.hidden) {\n        this.pullOnHover && this.pullSlice(a, 1);\n        1 > this.hoverAlpha && a.wedge && a.wedge.attr({\n          opacity: this.hoverAlpha\n        });\n        var d = a.balloonX,\n            g = a.balloonY;\n        a.pulled && (d += a.pullX, g += a.pullY);\n        var f = this.formatString(this.balloonText, a, !0),\n            h = this.balloonFunction;\n        h && (f = h(a, f));\n        h = k.adjustLuminosity(a.color, -.15);\n        f ? this.showBalloon(f, h, b, d, g) : this.hideBalloon();\n        0 === a.value && this.hideBalloon();\n        this.fire({\n          type: \"rollOverSlice\",\n          dataItem: a,\n          chart: this,\n          event: c\n        });\n      }\n    },\n    rollOutSlice: function (a, b) {\n      isNaN(a) || (a = this.chartData[a]);\n      a.wedge && a.wedge.attr({\n        opacity: 1\n      });\n      this.hideBalloon();\n      this.fire({\n        type: \"rollOutSlice\",\n        dataItem: a,\n        chart: this,\n        event: b\n      });\n    },\n    clickSlice: function (a, b, c) {\n      this.checkTouchDuration(b) && (isNaN(a) || (a = this.chartData[a]), a.pulled ? this.pullSlice(a, 0) : this.pullSlice(a, 1), k.getURL(a.url, this.urlTarget), c || this.fire({\n        type: \"clickSlice\",\n        dataItem: a,\n        chart: this,\n        event: b\n      }));\n    },\n    handleRightClick: function (a, b) {\n      isNaN(a) || (a = this.chartData[a]);\n      this.fire({\n        type: \"rightClickSlice\",\n        dataItem: a,\n        chart: this,\n        event: b\n      });\n    },\n    drawTicks: function () {\n      var a = this.chartData,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b];\n\n        if (c.label && !c.skipTick) {\n          var d = c.ty,\n              d = k.line(this.container, [c.tx0, c.tx, c.tx2], [c.ty0, d, d], this.labelTickColor, this.labelTickAlpha);\n          k.setCN(this, d, this.type + \"-tick\");\n          k.setCN(this, d, c.className, !0);\n          c.tick = d;\n          c.wedge.push(d);\n          \"AmFunnelChart\" == this.cname && d.toBack();\n        }\n      }\n    },\n    initialStart: function () {\n      var a = this,\n          b = a.startDuration,\n          c = setTimeout(function () {\n        a.showLabels.call(a);\n      }, 1E3 * b);\n      a.timeOuts.push(c);\n      a.chartCreated ? a.pullSlices(!0) : (a.startSlices(), 0 < b ? (b = setTimeout(function () {\n        a.pullSlices.call(a);\n      }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices(!0));\n    },\n    pullSlice: function (a, b, c) {\n      var d = this.pullOutDuration;\n      !0 === c && (d = 0);\n      if (c = a.wedge) 0 < d ? (c.animate({\n        translate: b * a.pullX + \",\" + b * a.pullY\n      }, d, this.pullOutEffect), a.labelSet && a.labelSet.animate({\n        translate: b * a.pullX + \",\" + b * a.pullY\n      }, d, this.pullOutEffect)) : (a.labelSet && a.labelSet.translate(b * a.pullX, b * a.pullY), c.translate(b * a.pullX, b * a.pullY));\n      1 == b ? (a.pulled = !0, this.pullOutOnlyOne && this.pullInAll(a.index), a = {\n        type: \"pullOutSlice\",\n        dataItem: a,\n        chart: this\n      }) : (a.pulled = !1, a = {\n        type: \"pullInSlice\",\n        dataItem: a,\n        chart: this\n      });\n      this.fire(a);\n    },\n    pullInAll: function (a) {\n      var b = this.chartData,\n          c;\n\n      for (c = 0; c < this.chartData.length; c++) c != a && b[c].pulled && this.pullSlice(b[c], 0);\n    },\n    pullOutAll: function () {\n      var a = this.chartData,\n          b;\n\n      for (b = 0; b < a.length; b++) a[b].pulled || this.pullSlice(a[b], 1);\n    },\n    parseData: function () {\n      var a = [];\n      this.chartData = a;\n      var b = this.dataProvider;\n      isNaN(this.pieAlpha) || (this.alpha = this.pieAlpha);\n\n      if (void 0 !== b) {\n        var c = b.length,\n            d = 0,\n            g,\n            f,\n            h;\n\n        for (g = 0; g < c; g++) {\n          f = {};\n          var e = b[g];\n          f.dataContext = e;\n          null !== e[this.valueField] && (f.value = Number(e[this.valueField]));\n          (h = e[this.titleField]) || (h = \"\");\n          f.title = h;\n          f.pulled = k.toBoolean(e[this.pulledField], !1);\n          (h = e[this.descriptionField]) || (h = \"\");\n          f.description = h;\n          f.labelRadius = Number(e[this.labelRadiusField]);\n          f.switchable = !0;\n          f.className = e[this.classNameField];\n          f.url = e[this.urlField];\n          h = e[this.patternField];\n          !h && this.patterns && (h = this.patterns[g]);\n          f.pattern = h;\n          f.visibleInLegend = k.toBoolean(e[this.visibleInLegendField], !0);\n          h = e[this.alphaField];\n          f.alpha = void 0 !== h ? Number(h) : this.alpha;\n          h = e[this.colorField];\n          void 0 !== h && (f.color = h);\n          f.labelColor = k.toColor(e[this.labelColorField]);\n          d += f.value;\n          f.hidden = !1;\n          a[g] = f;\n        }\n\n        for (g = b = 0; g < c; g++) f = a[g], f.percents = f.value / d * 100, f.percents < this.groupPercent && b++;\n\n        1 < b && (this.groupValue = 0, this.removeSmallSlices(), a.push({\n          title: this.groupedTitle,\n          value: this.groupValue,\n          percents: this.groupValue / d * 100,\n          pulled: this.groupedPulled,\n          color: this.groupedColor,\n          url: this.groupedUrl,\n          description: this.groupedDescription,\n          alpha: this.groupedAlpha,\n          pattern: this.groupedPattern,\n          className: this.groupedClassName,\n          dataContext: {}\n        }));\n        c = this.baseColor;\n        c || (c = this.pieBaseColor);\n        d = this.brightnessStep;\n        d || (d = this.pieBrightnessStep);\n\n        for (g = 0; g < a.length; g++) c ? h = k.adjustLuminosity(c, g * d / 100) : (h = this.colors[g], void 0 === h && (h = k.randomColor())), void 0 === a[g].color && (a[g].color = h);\n\n        this.recalculatePercents();\n      }\n    },\n    recalculatePercents: function () {\n      var a = this.chartData,\n          b = 0,\n          c,\n          d;\n\n      for (c = 0; c < a.length; c++) d = a[c], !d.hidden && 0 < d.value && (b += d.value);\n\n      for (c = 0; c < a.length; c++) d = this.chartData[c], d.percents = !d.hidden && 0 < d.value ? 100 * d.value / b : 0;\n    },\n    removeSmallSlices: function () {\n      var a = this.chartData,\n          b;\n\n      for (b = a.length - 1; 0 <= b; b--) a[b].percents < this.groupPercent && (this.groupValue += a[b].value, a.splice(b, 1));\n    },\n    animateAgain: function () {\n      var a = this;\n      a.startSlices();\n\n      for (var b = 0; b < a.chartData.length; b++) {\n        var c = a.chartData[b];\n        c.started = !1;\n        var d = c.wedge;\n        d && (d.setAttr(\"opacity\", a.startAlpha), d.translate(c.startX, c.startY));\n        if (d = c.labelSet) d.setAttr(\"opacity\", a.startAlpha), d.translate(c.startX, c.startY);\n      }\n\n      b = a.startDuration;\n      0 < b ? (b = setTimeout(function () {\n        a.pullSlices.call(a);\n      }, 1200 * b), a.timeOuts.push(b)) : a.pullSlices();\n    },\n    measureMaxLabel: function () {\n      var a = this.chartData,\n          b = 0,\n          c;\n\n      for (c = 0; c < a.length; c++) {\n        var d = a[c],\n            g = this.formatString(this.labelText, d),\n            f = this.labelFunction;\n        f && (g = f(d, g));\n        d = k.text(this.container, g, this.color, this.fontFamily, this.fontSize);\n        g = d.getBBox().width;\n        g > b && (b = g);\n        d.remove();\n      }\n\n      return b;\n    }\n  });\n})();\n\n(function () {\n  var k = window.AmCharts;\n  k.AmPieChart = k.Class({\n    inherits: k.AmSlicedChart,\n    construct: function (a) {\n      this.type = \"pie\";\n      k.AmPieChart.base.construct.call(this, a);\n      this.cname = \"AmPieChart\";\n      this.pieBrightnessStep = 30;\n      this.minRadius = 10;\n      this.depth3D = 0;\n      this.startAngle = 90;\n      this.angle = this.innerRadius = 0;\n      this.startRadius = \"500%\";\n      this.pullOutRadius = \"20%\";\n      this.labelRadius = 20;\n      this.labelText = \"[[title]]: [[percents]]%\";\n      this.balloonText = \"[[title]]: [[percents]]% ([[value]])\\n[[description]]\";\n      this.previousScale = 1;\n      this.adjustPrecision = !1;\n      this.gradientType = \"radial\";\n      k.applyTheme(this, a, this.cname);\n    },\n    drawChart: function () {\n      k.AmPieChart.base.drawChart.call(this);\n      var a = this.chartData;\n\n      if (k.ifArray(a)) {\n        if (0 < this.realWidth && 0 < this.realHeight) {\n          k.VML && (this.startAlpha = 1);\n          var b = this.startDuration,\n              c = this.container,\n              d = this.updateWidth();\n          this.realWidth = d;\n          var g = this.updateHeight();\n          this.realHeight = g;\n          var f = k.toCoordinate,\n              h = f(this.marginLeft, d),\n              e = f(this.marginRight, d),\n              z = f(this.marginTop, g) + this.getTitleHeight(),\n              n = f(this.marginBottom, g) + this.depth3D,\n              A,\n              B,\n              m,\n              w = k.toNumber(this.labelRadius),\n              q = this.measureMaxLabel();\n          q > this.maxLabelWidth && (q = this.maxLabelWidth);\n          this.labelText && this.labelsEnabled || (w = q = 0);\n          A = void 0 === this.pieX ? (d - h - e) / 2 + h : f(this.pieX, this.realWidth);\n          B = void 0 === this.pieY ? (g - z - n) / 2 + z : f(this.pieY, g);\n          m = f(this.radius, d, g);\n          m || (d = 0 <= w ? d - h - e - 2 * q : d - h - e, g = g - z - n, m = Math.min(d, g), g < d && (m /= 1 - this.angle / 90, m > d && (m = d)), g = k.toCoordinate(this.pullOutRadius, m), m = (0 <= w ? m - 1.8 * (w + g) : m - 1.8 * g) / 2);\n          m < this.minRadius && (m = this.minRadius);\n          g = f(this.pullOutRadius, m);\n          z = k.toCoordinate(this.startRadius, m);\n          f = f(this.innerRadius, m);\n          f >= m && (f = m - 1);\n          n = k.fitToBounds(this.startAngle, 0, 360);\n          0 < this.depth3D && (n = 270 <= n ? 270 : 90);\n          n -= 90;\n          360 < n && (n -= 360);\n          d = m - m * this.angle / 90;\n\n          for (h = q = 0; h < a.length; h++) e = a[h], !0 !== e.hidden && (q += k.roundTo(e.percents, this.pf.precision));\n\n          q = k.roundTo(q, this.pf.precision);\n          this.tempPrec = NaN;\n          this.adjustPrecision && 100 != q && (this.tempPrec = this.pf.precision + 1);\n\n          for (var E, h = 0; h < a.length; h++) if (e = a[h], !0 !== e.hidden && (this.showZeroSlices || 0 !== e.percents)) {\n            var r = 360 * e.percents / 100,\n                q = Math.sin((n + r / 2) / 180 * Math.PI),\n                C = d / m * -Math.cos((n + r / 2) / 180 * Math.PI),\n                p = this.outlineColor;\n            p || (p = e.color);\n            var u = this.alpha;\n            isNaN(e.alpha) || (u = e.alpha);\n            p = {\n              fill: e.color,\n              stroke: p,\n              \"stroke-width\": this.outlineThickness,\n              \"stroke-opacity\": this.outlineAlpha,\n              \"fill-opacity\": u\n            };\n            e.url && (p.cursor = \"pointer\");\n            p = k.wedge(c, A, B, n, r, m, d, f, this.depth3D, p, this.gradientRatio, e.pattern, this.path, this.gradientType);\n            k.setCN(this, p, \"pie-item\");\n            k.setCN(this, p.wedge, \"pie-slice\");\n            k.setCN(this, p, e.className, !0);\n            this.addEventListeners(p, e);\n            e.startAngle = n;\n            a[h].wedge = p;\n            0 < b && (this.chartCreated || p.setAttr(\"opacity\", this.startAlpha));\n            e.ix = q;\n            e.iy = C;\n            e.wedge = p;\n            e.index = h;\n            e.label = null;\n            u = c.set();\n\n            if (this.labelsEnabled && this.labelText && e.percents >= this.hideLabelsPercent) {\n              var l = n + r / 2;\n              0 > l && (l += 360);\n              360 < l && (l -= 360);\n              var t = w;\n              isNaN(e.labelRadius) || (t = e.labelRadius, 0 > t && (e.skipTick = !0));\n              var r = A + q * (m + t),\n                  D = B + C * (m + t),\n                  x,\n                  v = 0;\n              isNaN(E) && 350 < l && 1 < a.length - h && (E = h - 1 + Math.floor((a.length - h) / 2));\n\n              if (0 <= t) {\n                var y;\n                90 >= l && 0 <= l ? (y = 0, x = \"start\", v = 8) : 90 <= l && 180 > l ? (y = 1, x = \"start\", v = 8) : 180 <= l && 270 > l ? (y = 2, x = \"end\", v = -8) : 270 <= l && 354 >= l ? (y = 3, x = \"end\", v = -8) : 354 <= l && (h > E ? (y = 0, x = \"start\", v = 8) : (y = 3, x = \"end\", v = -8));\n                e.labelQuarter = y;\n              } else x = \"middle\";\n\n              l = this.formatString(this.labelText, e);\n              (t = this.labelFunction) && (l = t(e, l));\n              t = e.labelColor;\n              t || (t = this.color);\n              \"\" !== l && (l = k.wrappedText(c, l, t, this.fontFamily, this.fontSize, x, !1, this.maxLabelWidth), k.setCN(this, l, \"pie-label\"), k.setCN(this, l, e.className, !0), l.translate(r + 1.5 * v, D), 0 > w && (l.node.style.pointerEvents = \"none\"), l.node.style.cursor = \"default\", e.ty = D, e.textX = r + 1.5 * v, u.push(l), this.axesSet.push(u), e.labelSet = u, e.label = l, this.addEventListeners(u, e));\n              e.tx = r;\n              e.tx2 = r + v;\n              e.tx0 = A + q * m;\n              e.ty0 = B + C * m;\n            }\n\n            r = f + (m - f) / 2;\n            e.pulled && (r += g);\n            this.accessible && this.accessibleLabel && (D = this.formatString(this.accessibleLabel, e), this.makeAccessible(p, D));\n            void 0 !== this.tabIndex && p.setAttr(\"tabindex\", this.tabIndex);\n            e.balloonX = q * r + A;\n            e.balloonY = C * r + B;\n            e.startX = Math.round(q * z);\n            e.startY = Math.round(C * z);\n            e.pullX = Math.round(q * g);\n            e.pullY = Math.round(C * g);\n            this.graphsSet.push(p);\n            if (0 === e.alpha || 0 < b && !this.chartCreated) p.hide(), u && u.hide();\n            n += 360 * e.percents / 100;\n            360 < n && (n -= 360);\n          }\n\n          0 < w && this.arrangeLabels();\n          this.pieXReal = A;\n          this.pieYReal = B;\n          this.radiusReal = m;\n          this.innerRadiusReal = f;\n          0 < w && this.drawTicks();\n          this.initialStart();\n          this.setDepths();\n        }\n\n        (a = this.legend) && a.invalidateSize();\n      } else this.cleanChart();\n\n      this.dispDUpd();\n    },\n    setDepths: function () {\n      var a = this.chartData,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b],\n            d = c.wedge,\n            c = c.startAngle;\n        0 <= c && 180 > c ? d.toFront() : 180 <= c && d.toBack();\n      }\n    },\n    arrangeLabels: function () {\n      var a = this.chartData,\n          b = a.length,\n          c,\n          d;\n\n      for (d = b - 1; 0 <= d; d--) c = a[d], 0 !== c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 0, !0, 0);\n\n      for (d = 0; d < b; d++) c = a[d], 1 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 1, !1, 0);\n\n      for (d = b - 1; 0 <= d; d--) c = a[d], 2 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 2, !0, 0);\n\n      for (d = 0; d < b; d++) c = a[d], 3 != c.labelQuarter || c.hidden || this.checkOverlapping(d, c, 3, !1, 0);\n    },\n    checkOverlapping: function (a, b, c, d, g) {\n      var f,\n          h,\n          e = this.chartData,\n          k = e.length,\n          n = b.label;\n\n      if (n) {\n        if (!0 === d) for (h = a + 1; h < k; h++) e[h].labelQuarter == c && (f = this.checkOverlappingReal(b, e[h], c)) && (h = k);else for (h = a - 1; 0 <= h; h--) e[h].labelQuarter == c && (f = this.checkOverlappingReal(b, e[h], c)) && (h = 0);\n        !0 === f && 200 > g && isNaN(b.labelRadius) && (f = b.ty + 3 * b.iy, b.ty = f, n.translate(b.textX, f), this.checkOverlapping(a, b, c, d, g + 1));\n      }\n    },\n    checkOverlappingReal: function (a, b, c) {\n      var d = !1,\n          g = a.label,\n          f = b.label;\n      a.labelQuarter != c || a.hidden || b.hidden || !f || (g = g.getBBox(), c = {}, c.width = g.width, c.height = g.height, c.y = a.ty, c.x = a.tx, a = f.getBBox(), f = {}, f.width = a.width, f.height = a.height, f.y = b.ty, f.x = b.tx, k.hitTest(c, f) && (d = !0));\n      return d;\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}