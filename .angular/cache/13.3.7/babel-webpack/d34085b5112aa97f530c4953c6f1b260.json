{"ast":null,"code":"(function () {\n  var d = window.AmCharts;\n  d.GaugeAxis = d.Class({\n    construct: function (a) {\n      this.cname = \"GaugeAxis\";\n      this.radius = \"95%\";\n      this.createEvents(\"rollOverBand\", \"rollOutBand\", \"clickBand\");\n      this.labelsEnabled = !0;\n      this.startAngle = -120;\n      this.endAngle = 120;\n      this.startValue = 0;\n      this.endValue = 200;\n      this.gridCount = 5;\n      this.tickLength = 10;\n      this.minorTickLength = 5;\n      this.tickColor = \"#555555\";\n      this.labelFrequency = this.tickThickness = this.tickAlpha = 1;\n      this.inside = !0;\n      this.labelOffset = 10;\n      this.showLastLabel = this.showFirstLabel = !0;\n      this.axisThickness = 1;\n      this.axisColor = \"#000000\";\n      this.axisAlpha = 1;\n      this.gridInside = !0;\n      this.topTextYOffset = 0;\n      this.topTextBold = !0;\n      this.bottomTextYOffset = 0;\n      this.bottomTextBold = !0;\n      this.centerY = this.centerX = \"0%\";\n      this.bandOutlineAlpha = this.bandOutlineThickness = 0;\n      this.bandOutlineColor = \"#000000\";\n      this.bandAlpha = 1;\n      this.bcn = \"gauge-axis\";\n      d.applyTheme(this, a, \"GaugeAxis\");\n    },\n    value2angle: function (a) {\n      return (a - this.startValue) / (this.endValue - this.startValue) * (this.endAngle - this.startAngle) + this.startAngle;\n    },\n    setTopText: function (a) {\n      if (void 0 !== a) {\n        this.topText = a;\n        var b = this.chart;\n\n        if (this.axisCreated) {\n          this.topTF && this.topTF.remove();\n          var c = this.topTextFontSize;\n          c || (c = b.fontSize);\n          var e = this.topTextColor;\n          e || (e = b.color);\n          a = d.text(b.container, a, e, b.fontFamily, c, void 0, this.topTextBold);\n          d.setCN(b, a, \"axis-top-label\");\n          a.translate(this.centerXReal, this.centerYReal - this.radiusReal / 2 + this.topTextYOffset);\n          this.set.push(a);\n          this.topTF = a;\n        }\n      }\n    },\n    setBottomText: function (a) {\n      if (void 0 !== a) {\n        this.bottomText = a;\n        var b = this.chart;\n\n        if (this.axisCreated) {\n          this.bottomTF && this.bottomTF.remove();\n          var c = this.bottomTextFontSize;\n          c || (c = b.fontSize);\n          var e = this.bottomTextColor;\n          e || (e = b.color);\n          a = d.text(b.container, a, e, b.fontFamily, c, void 0, this.bottomTextBold);\n          d.setCN(b, a, \"axis-bottom-label\");\n          a.translate(this.centerXReal, this.centerYReal + this.radiusReal / 2 + this.bottomTextYOffset);\n          this.bottomTF = a;\n          this.set.push(a);\n        }\n      }\n    },\n    draw: function () {\n      var a = this.chart,\n          b = a.container.set();\n      this.set = b;\n      d.setCN(a, b, this.bcn);\n      d.setCN(a, b, this.bcn + \"-\" + this.id);\n      a.graphsSet.push(b);\n      this.bandSet = a.container.set();\n      this.set.push(this.bandSet);\n      var c = this.startValue,\n          e = this.endValue,\n          g = this.valueInterval;\n      isNaN(g) && (g = (e - c) / this.gridCount);\n      var l = this.minorTickInterval;\n      isNaN(l) && (l = g / 5);\n      var n = this.startAngle,\n          h = this.endAngle,\n          k = this.tickLength,\n          p = (e - c) / g + 1,\n          f = (h - n) / (p - 1);\n      this.singleValueAngle = f / g;\n      var m = a.container,\n          w = this.tickColor,\n          z = this.tickAlpha,\n          J = this.tickThickness,\n          l = g / l,\n          K = f / l,\n          H = this.minorTickLength,\n          I = this.labelFrequency,\n          v = this.radiusReal;\n      this.inside || (v -= 15);\n      this.radiusRealReal = v;\n      var A = a.centerX + d.toCoordinate(this.centerX, a.realWidth),\n          B = a.centerY + d.toCoordinate(this.centerY, a.realHeight);\n      this.centerXReal = A;\n      this.centerYReal = B;\n      var t = {\n        fill: this.axisColor,\n        \"fill-opacity\": this.axisAlpha,\n        \"stroke-width\": 0,\n        \"stroke-opacity\": 0\n      },\n          r,\n          C;\n      this.gridInside ? C = r = v : (r = v - k, C = r + H);\n      this.minorTickRadius = C;\n      this.drawBands();\n      var q = this.axisThickness / 2,\n          h = d.wedge(m, A, B, n, h - n, r + q, r + q, r - q, 0, t);\n      d.setCN(a, h.wedge, \"axis-line\");\n      b.push(h);\n      h = d.doNothing;\n      d.isModern || (h = Math.round);\n      t = d.getDecimals(c);\n      r = d.getDecimals(e);\n      e = d.getDecimals(g);\n      e = Math.max(e, t, r);\n      g = d.roundTo(g, e + 1);\n\n      for (t = 0; t < p; t++) {\n        q = d.roundTo(c + t * g, e);\n        r = n + t * f;\n        var u = h(A + v * Math.sin(r / 180 * Math.PI)),\n            F = h(B - v * Math.cos(r / 180 * Math.PI)),\n            x = h(A + (v - k) * Math.sin(r / 180 * Math.PI)),\n            y = h(B - (v - k) * Math.cos(r / 180 * Math.PI)),\n            u = d.line(m, [u, x], [F, y], w, z, J, 0, !1, !1, !0);\n        d.setCN(a, u, \"axis-tick\");\n        b.push(u);\n        u = -1;\n        x = this.labelOffset;\n        this.inside || (x = -x - k, u = 1);\n        var F = A + (v - k - x) * Math.sin(r / 180 * Math.PI),\n            x = B - (v - k - x) * Math.cos(r / 180 * Math.PI),\n            D = this.fontSize;\n        isNaN(D) && (D = a.fontSize);\n        var y = Math.sin((r - 90) / 180 * Math.PI),\n            L = Math.cos((r - 90) / 180 * Math.PI);\n\n        if (0 < I && this.labelsEnabled && t / I == Math.round(t / I) && (this.showLastLabel || t != p - 1) && (this.showFirstLabel || 0 !== t)) {\n          var E;\n          E = this.usePrefixes ? d.addPrefix(q, a.prefixesOfBigNumbers, a.prefixesOfSmallNumbers, a.nf, !0) : d.formatNumber(q, a.nf, e);\n          var G = this.unit;\n          G && (E = \"left\" == this.unitPosition ? G + E : E + G);\n          (G = this.labelFunction) && (E = G(q));\n          q = this.color;\n          void 0 === q && (q = a.color);\n          q = d.text(m, E, q, a.fontFamily, D);\n          d.setCN(a, q, \"axis-label\");\n          D = q.getBBox();\n          q.translate(F + u * D.width / 2 * L, x + u * D.height / 2 * y);\n          b.push(q);\n        }\n\n        if (t < p - 1) for (q = 1; q < l; q++) y = r + K * q, u = h(A + C * Math.sin(y / 180 * Math.PI)), F = h(B - C * Math.cos(y / 180 * Math.PI)), x = h(A + (C - H) * Math.sin(y / 180 * Math.PI)), y = h(B - (C - H) * Math.cos(y / 180 * Math.PI)), u = d.line(m, [u, x], [F, y], w, z, J, 0, !1, !1, !0), d.setCN(a, u, \"axis-tick-minor\"), b.push(u);\n      }\n\n      this.axisCreated = !0;\n      this.setTopText(this.topText);\n      this.setBottomText(this.bottomText);\n      a = a.graphsSet.getBBox();\n      this.width = a.width;\n      this.height = a.height;\n    },\n    drawBands: function () {\n      var a = this.bands;\n      if (a) for (var b = 0; b < a.length; b++) {\n        var c = a[b];\n        c && (c.axis = this, d.processObject(c, d.GaugeBand, this.theme), c.draw(c.startValue, c.endValue));\n      }\n    },\n    fireEvent: function (a, b, c) {\n      this.fire({\n        type: a,\n        dataItem: b,\n        chart: this,\n        event: c\n      });\n    },\n    addEventListeners: function (a, b) {\n      var c = this,\n          e = c.chart;\n      a.mouseover(function (a) {\n        e.showBalloon(b.balloonText, b.color, !0);\n        c.fireEvent(\"rollOverBand\", b, a);\n      }).mouseout(function (a) {\n        e.hideBalloon();\n        c.fireEvent(\"rollOutBand\", b, a);\n      }).click(function (a) {\n        c.fireEvent(\"clickBand\", b, a);\n        d.getURL(b.url, e.urlTarget);\n      }).touchend(function (a) {\n        c.fireEvent(\"clickBand\", b, a);\n        d.getURL(b.url, e.urlTarget);\n      });\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.GaugeArrow = d.Class({\n    construct: function (a) {\n      this.cname = \"GaugeArrow\";\n      this.color = \"#000000\";\n      this.nailAlpha = this.alpha = 1;\n      this.startWidth = this.nailRadius = 8;\n      this.endWidth = 0;\n      this.borderAlpha = 1;\n      this.radius = \"90%\";\n      this.nailBorderAlpha = this.innerRadius = 0;\n      this.nailBorderThickness = 1;\n      this.frame = 0;\n      d.applyTheme(this, a, \"GaugeArrow\");\n    },\n    setValue: function (a) {\n      var b = this.chart;\n      b ? b.setValue ? b.setValue(this, a) : this.previousValue = this.value = a : this.previousValue = this.value = a;\n    }\n  });\n  d.GaugeBand = d.Class({\n    construct: function () {\n      this.cname = \"GaugeBand\";\n      this.frame = 0;\n    },\n    draw: function (a, b) {\n      var c = this.axis;\n      this.bandGraphics && this.bandGraphics.remove();\n      var e = c.chart,\n          g = c.startAngle,\n          l = c.radiusRealReal,\n          n = c.singleValueAngle,\n          h = e.container,\n          k = c.minorTickLength,\n          p = d.toCoordinate(this.radius, l);\n      isNaN(p) && (p = c.minorTickRadius);\n      l = d.toCoordinate(this.innerRadius, l);\n      isNaN(l) && (l = p - k);\n      var g = g + n * (a - c.startValue),\n          k = n * (b - a),\n          f = this.outlineColor;\n      void 0 === f && (f = c.bandOutlineColor);\n      var m = this.outlineThickness;\n      isNaN(m) && (m = c.bandOutlineThickness);\n      var w = this.outlineAlpha;\n      isNaN(w) && (w = c.bandOutlineAlpha);\n      n = this.alpha;\n      isNaN(n) && (n = c.bandAlpha);\n      f = {\n        fill: this.color,\n        stroke: f,\n        \"stroke-width\": m,\n        \"stroke-opacity\": w\n      };\n      this.url && (f.cursor = \"pointer\");\n      m = this.gradientRatio;\n      m || (m = c.bandGradientRatio);\n      h = d.wedge(h, c.centerXReal, c.centerYReal, g, k, p, p, l, 0, f, m, void 0, void 0, \"radial\");\n      d.setCN(e, h.wedge, \"axis-band\");\n      void 0 !== this.id && d.setCN(e, h.wedge, \"axis-band-\" + this.id);\n      h.setAttr(\"opacity\", n);\n      c.bandSet.push(h);\n      this.bandGraphics = h;\n      this.currentStartValue = a;\n      this.currentEndValue = b;\n      c.addEventListeners(h, this);\n    },\n    update: function () {\n      var a = this.axis,\n          b = a.chart;\n\n      if (a && a.value2angle) {\n        if (this.frame >= b.totalFrames) b = this.endValue, a = this.startValue;else {\n          this.frame++;\n          var c = d.getEffect(b.startEffect),\n              a = d[c](0, this.frame, this.previousStartValue, this.startValue - this.previousStartValue, b.totalFrames),\n              b = d[c](0, this.frame, this.previousEndValue, this.endValue - this.previousEndValue, b.totalFrames);\n          isNaN(a) && (a = this.startValue);\n          isNaN(b) && (b = this.endValue);\n        }\n        a == this.currentStartValue && b == this.currentEndValue || this.draw(a, b);\n      }\n    },\n    setStartValue: function (a) {\n      this.previousStartValue = this.startValue;\n      this.startValue = a;\n      this.frame = 0;\n    },\n    setEndValue: function (a) {\n      this.previousEndValue = this.endValue;\n      this.endValue = a;\n      this.frame = 0;\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmAngularGauge = d.Class({\n    inherits: d.AmChart,\n    construct: function (a) {\n      this.cname = \"AmAngularGauge\";\n      d.AmAngularGauge.base.construct.call(this, a);\n      this.theme = a;\n      this.type = \"gauge\";\n      this.minRadius = this.marginRight = this.marginBottom = this.marginTop = this.marginLeft = 10;\n      this.faceColor = \"#FAFAFA\";\n      this.faceAlpha = 0;\n      this.faceBorderWidth = 1;\n      this.faceBorderColor = \"#555555\";\n      this.faceBorderAlpha = 0;\n      this.arrows = [];\n      this.axes = [];\n      this.startDuration = 1;\n      this.startEffect = \"easeOutSine\";\n      this.adjustSize = !0;\n      this.extraHeight = this.extraWidth = 0;\n      d.applyTheme(this, a, this.cname);\n    },\n    addAxis: function (a) {\n      a.chart = this;\n      this.axes.push(a);\n    },\n    formatString: function (a, b) {\n      return a = d.formatValue(a, b, [\"value\"], this.nf, \"\", this.usePrefixes, this.prefixesOfSmallNumbers, this.prefixesOfBigNumbers);\n    },\n    initChart: function () {\n      d.AmAngularGauge.base.initChart.call(this);\n      var a;\n      0 === this.axes.length && (a = new d.GaugeAxis(this.theme), this.addAxis(a));\n      var b;\n\n      for (b = 0; b < this.axes.length; b++) a = this.axes[b], a = d.processObject(a, d.GaugeAxis, this.theme), a.id || (a.id = \"axisAuto\" + b + \"_\" + new Date().getTime()), a.chart = this, this.axes[b] = a;\n\n      var c = this.arrows;\n\n      for (b = 0; b < c.length; b++) {\n        a = c[b];\n        a = d.processObject(a, d.GaugeArrow, this.theme);\n        a.id || (a.id = \"arrowAuto\" + b + \"_\" + new Date().getTime());\n        a.chart = this;\n        c[b] = a;\n        var e = a.axis;\n        d.isString(e) && (a.axis = d.getObjById(this.axes, e));\n        a.axis || (a.axis = this.axes[0]);\n        isNaN(a.value) && a.setValue(a.axis.startValue);\n        isNaN(a.previousValue) && (a.previousValue = a.axis.startValue);\n      }\n\n      this.setLegendData(c);\n      this.drawChart();\n      this.totalFrames = this.startDuration * d.updateRate;\n    },\n    drawChart: function () {\n      d.AmAngularGauge.base.drawChart.call(this);\n      var a = this.container,\n          b = this.updateWidth();\n      this.realWidth = b;\n      var c = this.updateHeight();\n      this.realHeight = c;\n      var e = d.toCoordinate,\n          g = e(this.marginLeft, b),\n          l = e(this.marginRight, b),\n          n = e(this.marginTop, c) + this.getTitleHeight(),\n          h = e(this.marginBottom, c),\n          k = e(this.radius, b, c),\n          e = b - g - l,\n          p = c - n - h + this.extraHeight;\n      k || (k = Math.min(e, p) / 2);\n      k < this.minRadius && (k = this.minRadius);\n      this.radiusReal = k;\n      this.centerX = (b - g - l) / 2 + g;\n      this.centerY = (c - n - h) / 2 + n + this.extraHeight / 2;\n      isNaN(this.gaugeX) || (this.centerX = this.gaugeX);\n      isNaN(this.gaugeY) || (this.centerY = this.gaugeY);\n      var b = this.faceAlpha,\n          c = this.faceBorderAlpha,\n          f;\n      if (0 < b || 0 < c) f = d.circle(a, k, this.faceColor, b, this.faceBorderWidth, this.faceBorderColor, c, !1), f.translate(this.centerX, this.centerY), f.toBack(), (a = this.facePattern) && f.pattern(a, NaN, this.path);\n\n      for (b = k = a = 0; b < this.axes.length; b++) c = this.axes[b], g = c.radius, c.radiusReal = d.toCoordinate(g, this.radiusReal), c.draw(), l = 1, -1 !== String(g).indexOf(\"%\") && (l = 1 + (100 - Number(g.substr(0, g.length - 1))) / 100), c.width * l > a && (a = c.width * l), c.height * l > k && (k = c.height * l);\n\n      (b = this.legend) && b.invalidateSize();\n\n      if (this.adjustSize && !this.sizeAdjusted) {\n        f && (f = f.getBBox(), f.width > a && (a = f.width), f.height > k && (k = f.height));\n        f = 0;\n        if (p > k || e > a) f = Math.min(p - k, e - a);\n        5 < f && (this.extraHeight = f, this.sizeAdjusted = !0, this.validateNow());\n      }\n\n      e = this.arrows.length;\n\n      for (b = 0; b < e; b++) p = this.arrows[b], p.drawnAngle = NaN;\n\n      this.dispDUpd();\n    },\n    validateSize: function () {\n      this.extraHeight = this.extraWidth = 0;\n      this.chartCreated = this.sizeAdjusted = !1;\n      d.AmAngularGauge.base.validateSize.call(this);\n    },\n    addArrow: function (a) {\n      this.arrows.push(a);\n    },\n    removeArrow: function (a) {\n      d.removeFromArray(this.arrows, a);\n      this.validateNow();\n    },\n    removeAxis: function (a) {\n      d.removeFromArray(this.axes, a);\n      this.validateNow();\n    },\n    drawArrow: function (a, b) {\n      a.set && a.set.remove();\n      var c = this.container;\n      a.set = c.set();\n      d.setCN(this, a.set, \"gauge-arrow\");\n      d.setCN(this, a.set, \"gauge-arrow-\" + a.id);\n      var e = a.axis,\n          g = e.radiusReal,\n          l = e.centerXReal,\n          n = e.centerYReal,\n          h = a.startWidth,\n          k = a.endWidth,\n          p = d.toCoordinate(a.innerRadius, e.radiusReal),\n          f = d.toCoordinate(a.radius, e.radiusReal);\n      e.inside || (f -= 15);\n      var m = a.nailColor;\n      m || (m = a.color);\n      var w = a.nailColor;\n      w || (w = a.color);\n      0 < a.nailRadius && (m = d.circle(c, a.nailRadius, m, a.nailAlpha, a.nailBorderThickness, m, a.nailBorderAlpha), d.setCN(this, m, \"gauge-arrow-nail\"), a.set.push(m), m.translate(l, n));\n      isNaN(f) && (f = g - e.tickLength);\n      var e = Math.sin(b / 180 * Math.PI),\n          g = Math.cos(b / 180 * Math.PI),\n          m = Math.sin((b + 90) / 180 * Math.PI),\n          z = Math.cos((b + 90) / 180 * Math.PI),\n          c = d.polygon(c, [l - h / 2 * m + p * e, l + f * e - k / 2 * m, l + f * e + k / 2 * m, l + h / 2 * m + p * e], [n + h / 2 * z - p * g, n - f * g + k / 2 * z, n - f * g - k / 2 * z, n - h / 2 * z - p * g], a.color, a.alpha, 1, w, a.borderAlpha, void 0, !0);\n      d.setCN(this, c, \"gauge-arrow\");\n      a.set.push(c);\n      this.graphsSet.push(a.set);\n      a.hidden && this.hideArrow(a);\n    },\n    setValue: function (a, b) {\n      a.axis && a.axis.value2angle && (a.frame = 0, a.previousValue = a.value);\n      a.value = b;\n      var c = this.legend;\n      c && c.updateValues();\n      this.accessible && this.background && this.makeAccessible(this.background, b);\n    },\n    handleLegendEvent: function (a) {\n      var b = a.type;\n      a = a.dataItem;\n      if (!this.legend.data && a) switch (b) {\n        case \"hideItem\":\n          this.hideArrow(a);\n          break;\n\n        case \"showItem\":\n          this.showArrow(a);\n      }\n    },\n    hideArrow: function (a) {\n      a.set.hide();\n      a.hidden = !0;\n      this.legend && this.legend.invalidateSize();\n    },\n    showArrow: function (a) {\n      a.set.show();\n      a.hidden = !1;\n      this.legend && this.legend.invalidateSize();\n    },\n    updateAnimations: function () {\n      d.AmAngularGauge.base.updateAnimations.call(this);\n\n      for (var a = this.arrows.length, b, c, e = 0; e < a; e++) b = this.arrows[e], b.axis && b.axis.value2angle && (b.frame >= this.totalFrames ? c = b.value : (b.frame++, b.clockWiseOnly && b.value < b.previousValue && (c = b.axis, b.previousValue -= c.endValue - c.startValue), c = d.getEffect(this.startEffect), c = d[c](0, b.frame, b.previousValue, b.value - b.previousValue, this.totalFrames), isNaN(c) && (c = b.value)), c = b.axis.value2angle(c), b.drawnAngle != c && (this.drawArrow(b, c), b.drawnAngle = c));\n\n      a = this.axes;\n\n      for (b = a.length - 1; 0 <= b; b--) if (c = a[b], c.bands) for (e = c.bands.length - 1; 0 <= e; e--) {\n        var g = c.bands[e];\n        g.update && g.update();\n      }\n    }\n  });\n})();","map":null,"metadata":{},"sourceType":"script"}