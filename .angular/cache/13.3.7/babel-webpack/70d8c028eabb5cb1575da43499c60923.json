{"ast":null,"code":"(function () {\n  var d;\n  window.AmCharts ? d = window.AmCharts : (d = {}, window.AmCharts = d, d.themes = {}, d.maps = {}, d.inheriting = {}, d.charts = [], d.onReadyArray = [], d.useUTC = !1, d.updateRate = 60, d.uid = 0, d.lang = {}, d.translations = {}, d.mapTranslations = {}, d.windows = {}, d.initHandlers = [], d.amString = \"am\", d.pmString = \"pm\");\n\n  d.Class = function (a) {\n    var b = function () {\n      arguments[0] !== d.inheriting && (this.events = {}, this.construct.apply(this, arguments));\n    };\n\n    a.inherits ? (b.prototype = new a.inherits(d.inheriting), b.base = a.inherits.prototype, delete a.inherits) : (b.prototype.createEvents = function () {\n      for (var a = 0; a < arguments.length; a++) this.events[arguments[a]] = [];\n    }, b.prototype.listenTo = function (a, b, c) {\n      this.removeListener(a, b, c);\n      a.events[b].push({\n        handler: c,\n        scope: this\n      });\n    }, b.prototype.addListener = function (a, b, c) {\n      this.removeListener(this, a, b);\n      a && this.events[a] && this.events[a].push({\n        handler: b,\n        scope: c\n      });\n    }, b.prototype.removeListener = function (a, b, c) {\n      if (a && a.events && (a = a.events[b])) for (b = a.length - 1; 0 <= b; b--) a[b].handler === c && a.splice(b, 1);\n    }, b.prototype.fire = function (a) {\n      for (var b = this.events[a.type], c = 0; c < b.length; c++) {\n        var d = b[c];\n        d.handler.call(d.scope, a);\n      }\n    });\n\n    for (var c in a) b.prototype[c] = a[c];\n\n    return b;\n  };\n\n  d.addChart = function (a) {\n    window.requestAnimationFrame ? d.animationRequested || (d.animationRequested = !0, window.requestAnimationFrame(d.update)) : d.updateInt || (d.updateInt = setInterval(function () {\n      d.update();\n    }, Math.round(1E3 / d.updateRate)));\n    d.charts.push(a);\n  };\n\n  d.removeChart = function (a) {\n    for (var b = d.charts, c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1);\n\n    0 === b.length && (d.requestAnimation && (window.cancelAnimationFrame(d.requestAnimation), d.animationRequested = !1), d.updateInt && (clearInterval(d.updateInt), d.updateInt = NaN));\n  };\n\n  d.isModern = !0;\n\n  d.getIEVersion = function () {\n    var a = 0,\n        b,\n        c;\n    \"Microsoft Internet Explorer\" == navigator.appName && (b = navigator.userAgent, c = /MSIE ([0-9]{1,}[.0-9]{0,})/, null !== c.exec(b) && (a = parseFloat(RegExp.$1)));\n    return a;\n  };\n\n  d.applyLang = function (a, b) {\n    var c = d.translations;\n    b.dayNames = d.extend({}, d.dayNames);\n    b.shortDayNames = d.extend({}, d.shortDayNames);\n    b.monthNames = d.extend({}, d.monthNames);\n    b.shortMonthNames = d.extend({}, d.shortMonthNames);\n    b.amString = \"am\";\n    b.pmString = \"pm\";\n    c && (c = c[a]) && (d.lang = c, b.langObj = c, c.monthNames && (b.dayNames = d.extend({}, c.dayNames), b.shortDayNames = d.extend({}, c.shortDayNames), b.monthNames = d.extend({}, c.monthNames), b.shortMonthNames = d.extend({}, c.shortMonthNames)), c.am && (b.amString = c.am), c.pm && (b.pmString = c.pm));\n    d.amString = b.amString;\n    d.pmString = b.pmString;\n  };\n\n  d.IEversion = d.getIEVersion();\n  9 > d.IEversion && 0 < d.IEversion && (d.isModern = !1, d.isIE = !0);\n  d.dx = 0;\n  d.dy = 0;\n  if (document.addEventListener || window.opera) d.isNN = !0, d.isIE = !1, d.dx = .5, d.dy = .5;\n  document.attachEvent && (d.isNN = !1, d.isIE = !0, d.isModern || (d.dx = 0, d.dy = 0));\n  window.chrome && (d.chrome = !0);\n\n  d.handleMouseUp = function (a) {\n    for (var b = d.charts, c = 0; c < b.length; c++) {\n      var e = b[c];\n      e && e.handleReleaseOutside && e.handleReleaseOutside(a);\n    }\n  };\n\n  d.handleMouseMove = function (a) {\n    for (var b = d.charts, c = 0; c < b.length; c++) {\n      var e = b[c];\n      e && e.handleMouseMove && e.handleMouseMove(a);\n    }\n  };\n\n  d.handleWheel = function (a) {\n    for (var b = d.charts, c = 0; c < b.length; c++) {\n      var e = b[c];\n\n      if (e && e.mouseIsOver) {\n        (e.mouseWheelScrollEnabled || e.mouseWheelZoomEnabled) && e.handleWheel && e.handleWheel(a);\n        break;\n      }\n    }\n  };\n\n  d.resetMouseOver = function () {\n    for (var a = d.charts, b = 0; b < a.length; b++) {\n      var c = a[b];\n      c && (c.mouseIsOver = !1);\n    }\n  };\n\n  d.ready = function (a) {\n    d.onReadyArray.push(a);\n  };\n\n  d.handleLoad = function () {\n    d.isReady = !0;\n\n    for (var a = d.onReadyArray, b = 0; b < a.length; b++) {\n      var c = a[b];\n      isNaN(d.processDelay) ? c() : setTimeout(c, d.processDelay * b);\n    }\n\n    d.onReadyArray = [];\n  };\n\n  d.addInitHandler = function (a, b) {\n    d.initHandlers.push({\n      method: a,\n      types: b\n    });\n  };\n\n  d.callInitHandler = function (a) {\n    var b = d.initHandlers;\n    if (d.initHandlers) for (var c = 0; c < b.length; c++) {\n      var e = b[c];\n      e.types ? d.isInArray(e.types, a.type) && e.method(a) : e.method(a);\n    }\n  };\n\n  d.getUniqueId = function () {\n    d.uid++;\n    return \"AmChartsEl-\" + d.uid;\n  };\n\n  d.isNN && (document.addEventListener(\"mousemove\", d.handleMouseMove), document.addEventListener(\"mouseup\", d.handleMouseUp, !0), window.addEventListener(\"load\", d.handleLoad, !0));\n  d.isIE && (document.attachEvent(\"onmousemove\", d.handleMouseMove), document.attachEvent(\"onmouseup\", d.handleMouseUp), window.attachEvent(\"onload\", d.handleLoad));\n\n  d.addWheelListeners = function () {\n    d.wheelIsListened || (d.isNN && (window.addEventListener(\"DOMMouseScroll\", d.handleWheel, !0), document.addEventListener(\"mousewheel\", d.handleWheel, !0)), d.isIE && document.attachEvent(\"onmousewheel\", d.handleWheel));\n    d.wheelIsListened = !0;\n  };\n\n  d.clear = function () {\n    var a = d.charts;\n    if (a) for (var b = a.length - 1; 0 <= b; b--) a[b].clear();\n    d.updateInt && clearInterval(d.updateInt);\n    d.requestAnimation && window.cancelAnimationFrame(d.requestAnimation);\n    d.charts = [];\n    d.isNN && (document.removeEventListener(\"mousemove\", d.handleMouseMove, !0), document.removeEventListener(\"mouseup\", d.handleMouseUp, !0), window.removeEventListener(\"load\", d.handleLoad, !0), window.removeEventListener(\"DOMMouseScroll\", d.handleWheel, !0), document.removeEventListener(\"mousewheel\", d.handleWheel, !0));\n    d.isIE && (document.detachEvent(\"onmousemove\", d.handleMouseMove), document.detachEvent(\"onmouseup\", d.handleMouseUp), window.detachEvent(\"onload\", d.handleLoad));\n  };\n\n  d.makeChart = function (a, b, c) {\n    var e = b.type,\n        h = b.theme;\n    d.isString(h) && (h = d.themes[h], b.theme = h);\n    var f;\n\n    switch (e) {\n      case \"serial\":\n        f = new d.AmSerialChart(h);\n        break;\n\n      case \"xy\":\n        f = new d.AmXYChart(h);\n        break;\n\n      case \"pie\":\n        f = new d.AmPieChart(h);\n        break;\n\n      case \"radar\":\n        f = new d.AmRadarChart(h);\n        break;\n\n      case \"gauge\":\n        f = new d.AmAngularGauge(h);\n        break;\n\n      case \"funnel\":\n        f = new d.AmFunnelChart(h);\n        break;\n\n      case \"map\":\n        f = new d.AmMap(h);\n        break;\n\n      case \"stock\":\n        f = new d.AmStockChart(h);\n        break;\n\n      case \"gantt\":\n        f = new d.AmGanttChart(h);\n    }\n\n    d.extend(f, b);\n    d.isReady ? isNaN(c) ? f.write(a) : setTimeout(function () {\n      d.realWrite(f, a);\n    }, c) : d.ready(function () {\n      isNaN(c) ? f.write(a) : setTimeout(function () {\n        d.realWrite(f, a);\n      }, c);\n    });\n    return f;\n  };\n\n  d.realWrite = function (a, b) {\n    a.write(b);\n  };\n\n  d.updateCount = 0;\n  d.validateAt = Math.round(d.updateRate / 10);\n\n  d.update = function () {\n    var a = d.charts;\n    d.updateCount++;\n    var b = !1;\n    d.updateCount == d.validateAt && (b = !0, d.updateCount = 0);\n    if (a) for (var c = a.length - 1; 0 <= c; c--) a[c].update && a[c].update(), b && (a[c].autoResize ? a[c].validateSize && a[c].validateSize() : a[c].premeasure && a[c].premeasure());\n    window.requestAnimationFrame && (d.requestAnimation = window.requestAnimationFrame(d.update));\n  };\n\n  \"complete\" == document.readyState && d.handleLoad();\n})();\n\n(function () {\n  var d = window.AmCharts;\n\n  d.toBoolean = function (a, b) {\n    if (void 0 === a) return b;\n\n    switch (String(a).toLowerCase()) {\n      case \"true\":\n      case \"yes\":\n      case \"1\":\n        return !0;\n\n      case \"false\":\n      case \"no\":\n      case \"0\":\n      case null:\n        return !1;\n\n      default:\n        return !!a;\n    }\n  };\n\n  d.removeFromArray = function (a, b) {\n    var c;\n    if (void 0 !== b && void 0 !== a) for (c = a.length - 1; 0 <= c; c--) a[c] == b && a.splice(c, 1);\n  };\n\n  d.getPath = function () {\n    var a = document.getElementsByTagName(\"script\");\n    if (a) for (var b = 0; b < a.length; b++) {\n      var c = a[b].src;\n      if (-1 !== c.search(/\\/(amcharts|ammap)\\.js/)) return c.replace(/\\/(amcharts|ammap)\\.js.*/, \"/\");\n    }\n  };\n\n  d.normalizeUrl = function (a) {\n    return \"\" !== a && -1 === a.search(/\\/$/) ? a + \"/\" : a;\n  };\n\n  d.isAbsolute = function (a) {\n    return 0 === a.search(/^http[s]?:|^\\//);\n  };\n\n  d.isInArray = function (a, b) {\n    for (var c = 0; c < a.length; c++) if (a[c] == b) return !0;\n\n    return !1;\n  };\n\n  d.getDecimals = function (a) {\n    var b = 0;\n    isNaN(a) || (a = String(a), -1 != a.indexOf(\"e-\") ? b = Number(a.split(\"-\")[1]) : -1 != a.indexOf(\".\") && (b = a.split(\".\")[1].length));\n    return b;\n  };\n\n  d.wordwrap = function (a, b, c, e) {\n    var h, f, g, k;\n    a += \"\";\n    if (1 > b) return a;\n    h = -1;\n\n    for (a = (k = a.split(/\\r\\n|\\n|\\r/)).length; ++h < a; k[h] += g) {\n      g = k[h];\n\n      for (k[h] = \"\"; g.length > b; k[h] += d.trim(g.slice(0, f)) + ((g = g.slice(f)).length ? c : \"\")) f = 2 == e || (f = g.slice(0, b + 1).match(/\\S*(\\s)?$/))[1] ? b : f.input.length - f[0].length || 1 == e && b || f.input.length + (f = g.slice(b).match(/^\\S*/))[0].length;\n\n      g = d.trim(g);\n    }\n\n    return k.join(c);\n  };\n\n  d.trim = function (a) {\n    return a.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\n  };\n\n  d.wrappedText = function (a, b, c, e, h, f, g, k) {\n    var l = d.text(a, b, c, e, h, f, g);\n\n    if (l) {\n      var m = l.getBBox();\n\n      if (m.width > k) {\n        var p = \"\\n\";\n        d.isModern || (p = \"<br>\");\n        k = Math.floor(k / (m.width / b.length));\n        2 < k && (k -= 2);\n        b = d.wordwrap(b, k, p, !0);\n        l.remove();\n        l = d.text(a, b, c, e, h, f, g);\n      }\n    }\n\n    return l;\n  };\n\n  d.getStyle = function (a, b) {\n    var c = \"\";\n    if (document.defaultView && document.defaultView.getComputedStyle) try {\n      c = document.defaultView.getComputedStyle(a, \"\").getPropertyValue(b);\n    } catch (e) {} else a.currentStyle && (b = b.replace(/\\-(\\w)/g, function (a, b) {\n      return b.toUpperCase();\n    }), c = a.currentStyle[b]);\n    return c;\n  };\n\n  d.removePx = function (a) {\n    if (void 0 !== a) return Number(a.substring(0, a.length - 2));\n  };\n\n  d.getURL = function (a, b) {\n    if (a) if (\"_self\" != b && b) {\n      if (\"_top\" == b && window.top) window.top.location.href = a;else if (\"_parent\" == b && window.parent) window.parent.location.href = a;else if (\"_blank\" == b) window.open(a);else {\n        var c = document.getElementsByName(b)[0];\n        c ? c.src = a : (c = d.windows[b]) ? c.opener && !c.opener.closed ? c.location.href = a : d.windows[b] = window.open(a) : d.windows[b] = window.open(a);\n      }\n    } else window.location.href = a;\n  };\n\n  d.ifArray = function (a) {\n    return a && \"object\" == typeof a && 0 < a.length ? !0 : !1;\n  };\n\n  d.callMethod = function (a, b) {\n    var c;\n\n    for (c = 0; c < b.length; c++) {\n      var e = b[c];\n\n      if (e) {\n        if (e[a]) e[a]();\n        var d = e.length;\n\n        if (0 < d) {\n          var f;\n\n          for (f = 0; f < d; f++) {\n            var g = e[f];\n            if (g && g[a]) g[a]();\n          }\n        }\n      }\n    }\n  };\n\n  d.toNumber = function (a) {\n    return \"number\" == typeof a ? a : Number(String(a).replace(/[^0-9\\-.]+/g, \"\"));\n  };\n\n  d.toColor = function (a) {\n    if (\"\" !== a && void 0 !== a) if (-1 != a.indexOf(\",\")) {\n      a = a.split(\",\");\n      var b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b].substring(a[b].length - 6, a[b].length);\n        a[b] = \"#\" + c;\n      }\n    } else a = a.substring(a.length - 6, a.length), a = \"#\" + a;\n    return a;\n  };\n\n  d.toCoordinate = function (a, b, c) {\n    var e;\n    void 0 !== a && (a = String(a), c && c < b && (b = c), e = Number(a), -1 != a.indexOf(\"!\") && (e = b - Number(a.substr(1))), -1 != a.indexOf(\"%\") && (e = b * Number(a.substr(0, a.length - 1)) / 100));\n    return e;\n  };\n\n  d.fitToBounds = function (a, b, c) {\n    a < b && (a = b);\n    a > c && (a = c);\n    return a;\n  };\n\n  d.isDefined = function (a) {\n    return void 0 === a ? !1 : !0;\n  };\n\n  d.stripNumbers = function (a) {\n    return a.replace(/[0-9]+/g, \"\");\n  };\n\n  d.roundTo = function (a, b) {\n    if (0 > b) return a;\n    var c = Math.pow(10, b);\n    return Math.round(a * c) / c;\n  };\n\n  d.toFixed = function (a, b) {\n    var c = !1;\n    0 > a && (c = !0, a = Math.abs(a));\n    var e = String(Math.round(a * Math.pow(10, b)));\n\n    if (0 < b) {\n      var d = e.length;\n\n      if (d < b) {\n        var f;\n\n        for (f = 0; f < b - d; f++) e = \"0\" + e;\n      }\n\n      d = e.substring(0, e.length - b);\n      \"\" === d && (d = 0);\n      e = d + \".\" + e.substring(e.length - b, e.length);\n      return c ? \"-\" + e : e;\n    }\n\n    return String(e);\n  };\n\n  d.formatDuration = function (a, b, c, e, h, f) {\n    var g = d.intervals,\n        k = f.decimalSeparator;\n\n    if (a >= g[b].contains) {\n      var l = a - Math.floor(a / g[b].contains) * g[b].contains;\n      \"ss\" == b ? (l = d.formatNumber(l, f), 1 == l.split(k)[0].length && (l = \"0\" + l)) : l = d.roundTo(l, f.precision);\n      (\"mm\" == b || \"hh\" == b) && 10 > l && (l = \"0\" + l);\n      c = l + \"\" + e[b] + \"\" + c;\n      a = Math.floor(a / g[b].contains);\n      b = g[b].nextInterval;\n      return d.formatDuration(a, b, c, e, h, f);\n    }\n\n    \"ss\" == b && (a = d.formatNumber(a, f), 1 == a.split(k)[0].length && (a = \"0\" + a));\n    (\"mm\" == b || \"hh\" == b) && 10 > a && (a = \"0\" + a);\n    c = a + \"\" + e[b] + \"\" + c;\n    if (g[h].count > g[b].count) for (a = g[b].count; a < g[h].count; a++) b = g[b].nextInterval, \"ss\" == b || \"mm\" == b || \"hh\" == b ? c = \"00\" + e[b] + \"\" + c : \"DD\" == b && (c = \"0\" + e[b] + \"\" + c);\n    \":\" == c.charAt(c.length - 1) && (c = c.substring(0, c.length - 1));\n    return c;\n  };\n\n  d.formatNumber = function (a, b, c, e, h) {\n    a = d.roundTo(a, b.precision);\n    isNaN(c) && (c = b.precision);\n    var f = b.decimalSeparator;\n    b = b.thousandsSeparator;\n    var g;\n    g = 0 > a ? \"-\" : \"\";\n    a = Math.abs(a);\n    var k = String(a),\n        l = !1;\n    -1 != k.indexOf(\"e\") && (l = !0);\n    0 <= c && !l && (k = d.toFixed(a, c));\n    var m = \"\";\n    if (l) m = k;else {\n      var k = k.split(\".\"),\n          l = String(k[0]),\n          p;\n\n      for (p = l.length; 0 <= p; p -= 3) m = p != l.length ? 0 !== p ? l.substring(p - 3, p) + b + m : l.substring(p - 3, p) + m : l.substring(p - 3, p);\n\n      void 0 !== k[1] && (m = m + f + k[1]);\n      void 0 !== c && 0 < c && \"0\" != m && (m = d.addZeroes(m, f, c));\n    }\n    m = g + m;\n    \"\" === g && !0 === e && 0 !== a && (m = \"+\" + m);\n    !0 === h && (m += \"%\");\n    return m;\n  };\n\n  d.addZeroes = function (a, b, c) {\n    a = a.split(b);\n    void 0 === a[1] && 0 < c && (a[1] = \"0\");\n    return a[1].length < c ? (a[1] += \"0\", d.addZeroes(a[0] + b + a[1], b, c)) : void 0 !== a[1] ? a[0] + b + a[1] : a[0];\n  };\n\n  d.scientificToNormal = function (a) {\n    var b;\n    a = String(a).split(\"e\");\n    var c;\n\n    if (\"-\" == a[1].substr(0, 1)) {\n      b = \"0.\";\n\n      for (c = 0; c < Math.abs(Number(a[1])) - 1; c++) b += \"0\";\n\n      b += a[0].split(\".\").join(\"\");\n    } else {\n      var e = 0;\n      b = a[0].split(\".\");\n      b[1] && (e = b[1].length);\n      b = a[0].split(\".\").join(\"\");\n\n      for (c = 0; c < Math.abs(Number(a[1])) - e; c++) b += \"0\";\n    }\n\n    return b;\n  };\n\n  d.toScientific = function (a, b) {\n    if (0 === a) return \"0\";\n    var c = Math.floor(Math.log(Math.abs(a)) * Math.LOG10E),\n        e = String(e).split(\".\").join(b);\n    return String(e) + \"e\" + c;\n  };\n\n  d.randomColor = function () {\n    return \"#\" + (\"00000\" + (16777216 * Math.random() << 0).toString(16)).substr(-6);\n  };\n\n  d.hitTest = function (a, b, c) {\n    var e = !1,\n        h = a.x,\n        f = a.x + a.width,\n        g = a.y,\n        k = a.y + a.height,\n        l = d.isInRectangle;\n    e || (e = l(h, g, b));\n    e || (e = l(h, k, b));\n    e || (e = l(f, g, b));\n    e || (e = l(f, k, b));\n    e || !0 === c || (e = d.hitTest(b, a, !0));\n    return e;\n  };\n\n  d.isInRectangle = function (a, b, c) {\n    return a >= c.x - 5 && a <= c.x + c.width + 5 && b >= c.y - 5 && b <= c.y + c.height + 5 ? !0 : !1;\n  };\n\n  d.isPercents = function (a) {\n    if (-1 != String(a).indexOf(\"%\")) return !0;\n  };\n\n  d.formatValue = function (a, b, c, e, h, f, g, k) {\n    if (b) {\n      void 0 === h && (h = \"\");\n      var l;\n\n      for (l = 0; l < c.length; l++) {\n        var m = c[l],\n            p = b[m];\n        void 0 !== p && (p = f ? d.addPrefix(p, k, g, e) : d.formatNumber(p, e), a = a.replace(new RegExp(\"\\\\[\\\\[\" + h + \"\" + m + \"\\\\]\\\\]\", \"g\"), p));\n      }\n    }\n\n    return a;\n  };\n\n  d.formatDataContextValue = function (a, b) {\n    if (a) {\n      var c = a.match(/\\[\\[.*?\\]\\]/g),\n          e;\n\n      for (e = 0; e < c.length; e++) {\n        var d = c[e],\n            d = d.substr(2, d.length - 4);\n        void 0 !== b[d] && (a = a.replace(new RegExp(\"\\\\[\\\\[\" + d + \"\\\\]\\\\]\", \"g\"), b[d]));\n      }\n    }\n\n    return a;\n  };\n\n  d.massReplace = function (a, b) {\n    for (var c in b) if (b.hasOwnProperty(c)) {\n      var e = b[c];\n      void 0 === e && (e = \"\");\n      a = a.replace(c, e);\n    }\n\n    return a;\n  };\n\n  d.cleanFromEmpty = function (a) {\n    return a.replace(/\\[\\[[^\\]]*\\]\\]/g, \"\");\n  };\n\n  d.addPrefix = function (a, b, c, e, h) {\n    var f = d.formatNumber(a, e),\n        g = \"\",\n        k,\n        l,\n        m;\n    if (0 === a) return \"0\";\n    0 > a && (g = \"-\");\n    a = Math.abs(a);\n    if (1 < a) for (k = b.length - 1; -1 < k; k--) {\n      if (a >= b[k].number && (l = a / b[k].number, m = Number(e.precision), 1 > m && (m = 1), c = d.roundTo(l, m), m = d.formatNumber(c, {\n        precision: -1,\n        decimalSeparator: e.decimalSeparator,\n        thousandsSeparator: e.thousandsSeparator\n      }), !h || l == c)) {\n        f = g + \"\" + m + \"\" + b[k].prefix;\n        break;\n      }\n    } else for (k = 0; k < c.length; k++) if (a <= c[k].number) {\n      l = a / c[k].number;\n      m = Math.abs(Math.floor(Math.log(l) * Math.LOG10E));\n      l = d.roundTo(l, m);\n      f = g + \"\" + l + \"\" + c[k].prefix;\n      break;\n    }\n    return f;\n  };\n\n  d.remove = function (a) {\n    a && a.remove();\n  };\n\n  d.getEffect = function (a) {\n    \">\" == a && (a = \"easeOutSine\");\n    \"<\" == a && (a = \"easeInSine\");\n    \"elastic\" == a && (a = \"easeOutElastic\");\n    return a;\n  };\n\n  d.getObjById = function (a, b) {\n    var c, e;\n\n    for (e = 0; e < a.length; e++) {\n      var d = a[e];\n\n      if (d.id == b) {\n        c = d;\n        break;\n      }\n    }\n\n    return c;\n  };\n\n  d.applyTheme = function (a, b, c) {\n    b || (b = d.theme);\n\n    try {\n      b = JSON.parse(JSON.stringify(b));\n    } catch (e) {}\n\n    b && b[c] && d.extend(a, b[c]);\n  };\n\n  d.isString = function (a) {\n    return \"string\" == typeof a ? !0 : !1;\n  };\n\n  d.extend = function (a, b, c) {\n    var e;\n    a || (a = {});\n\n    for (e in b) c ? a.hasOwnProperty(e) || (a[e] = b[e]) : a[e] = b[e];\n\n    return a;\n  };\n\n  d.copyProperties = function (a, b) {\n    for (var c in a) a.hasOwnProperty(c) && \"events\" != c && void 0 !== a[c] && \"function\" != typeof a[c] && \"cname\" != c && (b[c] = a[c]);\n  };\n\n  d.processObject = function (a, b, c, e) {\n    if (!1 === a instanceof b && (a = e ? d.extend(new b(c), a) : d.extend(a, new b(c), !0), a.listeners)) for (var h in a.listeners) b = a.listeners[h], a.addListener(b.event, b.method);\n    return a;\n  };\n\n  d.fixNewLines = function (a) {\n    var b = RegExp(\"\\\\n\", \"g\");\n    a && (a = a.replace(b, \"<br />\"));\n    return a;\n  };\n\n  d.fixBrakes = function (a) {\n    if (d.isModern) {\n      var b = RegExp(\"<br>\", \"g\");\n      a && (a = a.replace(b, \"\\n\"));\n    } else a = d.fixNewLines(a);\n\n    return a;\n  };\n\n  d.deleteObject = function (a, b) {\n    if (a) {\n      if (void 0 === b || null === b) b = 20;\n      if (0 !== b) if (\"[object Array]\" === Object.prototype.toString.call(a)) for (var c = 0; c < a.length; c++) d.deleteObject(a[c], b - 1), a[c] = null;else if (a && !a.tagName) try {\n        for (c in a.theme = null, a) a[c] && (\"object\" == typeof a[c] && d.deleteObject(a[c], b - 1), \"function\" != typeof a[c] && (a[c] = null));\n      } catch (e) {}\n    }\n  };\n\n  d.bounce = function (a, b, c, e, d) {\n    return (b /= d) < 1 / 2.75 ? 7.5625 * e * b * b + c : b < 2 / 2.75 ? e * (7.5625 * (b -= 1.5 / 2.75) * b + .75) + c : b < 2.5 / 2.75 ? e * (7.5625 * (b -= 2.25 / 2.75) * b + .9375) + c : e * (7.5625 * (b -= 2.625 / 2.75) * b + .984375) + c;\n  };\n\n  d.easeInOutQuad = function (a, b, c, e, d) {\n    b /= d / 2;\n    if (1 > b) return e / 2 * b * b + c;\n    b--;\n    return -e / 2 * (b * (b - 2) - 1) + c;\n  };\n\n  d.easeInSine = function (a, b, c, e, d) {\n    return -e * Math.cos(b / d * (Math.PI / 2)) + e + c;\n  };\n\n  d.easeOutSine = function (a, b, c, e, d) {\n    return e * Math.sin(b / d * (Math.PI / 2)) + c;\n  };\n\n  d.easeOutElastic = function (a, b, c, e, d) {\n    a = 1.70158;\n    var f = 0,\n        g = e;\n    if (0 === b) return c;\n    if (1 == (b /= d)) return c + e;\n    f || (f = .3 * d);\n    g < Math.abs(e) ? (g = e, a = f / 4) : a = f / (2 * Math.PI) * Math.asin(e / g);\n    return g * Math.pow(2, -10 * b) * Math.sin(2 * (b * d - a) * Math.PI / f) + e + c;\n  };\n\n  d.fixStepE = function (a) {\n    a = a.toExponential(0).split(\"e\");\n    var b = Number(a[1]);\n    9 == Number(a[0]) && b++;\n    return d.generateNumber(1, b);\n  };\n\n  d.generateNumber = function (a, b) {\n    var c = \"\",\n        e;\n    e = 0 > b ? Math.abs(b) - 1 : Math.abs(b);\n    var d;\n\n    for (d = 0; d < e; d++) c += \"0\";\n\n    return 0 > b ? Number(\"0.\" + c + String(a)) : Number(String(a) + c);\n  };\n\n  d.setCN = function (a, b, c, e) {\n    if (a.addClassNames && b && (b = b.node) && c) {\n      var d = b.getAttribute(\"class\");\n      a = a.classNamePrefix + \"-\";\n      e && (a = \"\");\n      d ? b.setAttribute(\"class\", d + \" \" + a + c) : b.setAttribute(\"class\", a + c);\n    }\n  };\n\n  d.removeCN = function (a, b, c) {\n    b && (b = b.node) && c && (b = b.classList) && b.remove(a.classNamePrefix + \"-\" + c);\n  };\n\n  d.parseDefs = function (a, b) {\n    for (var c in a) {\n      var e = typeof a[c];\n      if (0 < a[c].length && \"object\" == e) for (var h = 0; h < a[c].length; h++) e = document.createElementNS(d.SVG_NS, c), b.appendChild(e), d.parseDefs(a[c][h], e);else \"object\" == e ? (e = document.createElementNS(d.SVG_NS, c), b.appendChild(e), d.parseDefs(a[c], e)) : b.setAttribute(c, a[c]);\n    }\n  };\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AxisBase = d.Class({\n    construct: function (a) {\n      this.createEvents(\"clickItem\", \"rollOverItem\", \"rollOutItem\", \"rollOverGuide\", \"rollOutGuide\", \"clickGuide\");\n      this.titleDY = this.y = this.x = this.dy = this.dx = 0;\n      this.axisThickness = 1;\n      this.axisColor = \"#000000\";\n      this.axisAlpha = 1;\n      this.gridCount = this.tickLength = 5;\n      this.gridAlpha = .15;\n      this.gridThickness = 1;\n      this.gridColor = \"#000000\";\n      this.dashLength = 0;\n      this.labelFrequency = 1;\n      this.showLastLabel = this.showFirstLabel = !0;\n      this.fillColor = \"#FFFFFF\";\n      this.fillAlpha = 0;\n      this.labelsEnabled = !0;\n      this.labelRotation = 0;\n      this.autoGridCount = !0;\n      this.offset = 0;\n      this.guides = [];\n      this.visible = !0;\n      this.counter = 0;\n      this.guides = [];\n      this.ignoreAxisWidth = this.inside = !1;\n      this.minHorizontalGap = 75;\n      this.minVerticalGap = 35;\n      this.titleBold = !0;\n      this.minorGridEnabled = !1;\n      this.minorGridAlpha = .07;\n      this.autoWrap = !1;\n      this.titleAlign = \"middle\";\n      this.labelOffset = 0;\n      this.bcn = \"axis-\";\n      this.centerLabels = !1;\n      this.firstDayOfWeek = 1;\n      this.centerLabelOnFullPeriod = this.markPeriodChange = this.boldPeriodBeginning = !0;\n      this.titleWidth = 0;\n      this.periods = [{\n        period: \"fff\",\n        count: 1\n      }, {\n        period: \"fff\",\n        count: 5\n      }, {\n        period: \"fff\",\n        count: 10\n      }, {\n        period: \"fff\",\n        count: 50\n      }, {\n        period: \"fff\",\n        count: 100\n      }, {\n        period: \"fff\",\n        count: 500\n      }, {\n        period: \"ss\",\n        count: 1\n      }, {\n        period: \"ss\",\n        count: 5\n      }, {\n        period: \"ss\",\n        count: 10\n      }, {\n        period: \"ss\",\n        count: 30\n      }, {\n        period: \"mm\",\n        count: 1\n      }, {\n        period: \"mm\",\n        count: 5\n      }, {\n        period: \"mm\",\n        count: 10\n      }, {\n        period: \"mm\",\n        count: 30\n      }, {\n        period: \"hh\",\n        count: 1\n      }, {\n        period: \"hh\",\n        count: 3\n      }, {\n        period: \"hh\",\n        count: 6\n      }, {\n        period: \"hh\",\n        count: 12\n      }, {\n        period: \"DD\",\n        count: 1\n      }, {\n        period: \"DD\",\n        count: 2\n      }, {\n        period: \"DD\",\n        count: 3\n      }, {\n        period: \"DD\",\n        count: 4\n      }, {\n        period: \"DD\",\n        count: 5\n      }, {\n        period: \"WW\",\n        count: 1\n      }, {\n        period: \"MM\",\n        count: 1\n      }, {\n        period: \"MM\",\n        count: 2\n      }, {\n        period: \"MM\",\n        count: 3\n      }, {\n        period: \"MM\",\n        count: 6\n      }, {\n        period: \"YYYY\",\n        count: 1\n      }, {\n        period: \"YYYY\",\n        count: 2\n      }, {\n        period: \"YYYY\",\n        count: 5\n      }, {\n        period: \"YYYY\",\n        count: 10\n      }, {\n        period: \"YYYY\",\n        count: 50\n      }, {\n        period: \"YYYY\",\n        count: 100\n      }];\n      this.dateFormats = [{\n        period: \"fff\",\n        format: \"NN:SS.QQQ\"\n      }, {\n        period: \"ss\",\n        format: \"JJ:NN:SS\"\n      }, {\n        period: \"mm\",\n        format: \"JJ:NN\"\n      }, {\n        period: \"hh\",\n        format: \"JJ:NN\"\n      }, {\n        period: \"DD\",\n        format: \"MMM DD\"\n      }, {\n        period: \"WW\",\n        format: \"MMM DD\"\n      }, {\n        period: \"MM\",\n        format: \"MMM\"\n      }, {\n        period: \"YYYY\",\n        format: \"YYYY\"\n      }];\n      this.nextPeriod = {\n        fff: \"ss\",\n        ss: \"mm\",\n        mm: \"hh\",\n        hh: \"DD\",\n        DD: \"MM\",\n        MM: \"YYYY\"\n      };\n      d.applyTheme(this, a, \"AxisBase\");\n    },\n    zoom: function (a, b) {\n      this.start = a;\n      this.end = b;\n      this.dataChanged = !0;\n      this.draw();\n    },\n    fixAxisPosition: function () {\n      var a = this.position;\n      \"H\" == this.orientation ? (\"left\" == a && (a = \"bottom\"), \"right\" == a && (a = \"top\")) : (\"bottom\" == a && (a = \"left\"), \"top\" == a && (a = \"right\"));\n      this.position = a;\n    },\n    init: function () {\n      this.createBalloon();\n    },\n    draw: function () {\n      var a = this.chart;\n      this.prevBY = this.prevBX = NaN;\n      this.allLabels = [];\n      this.counter = 0;\n      this.destroy();\n      this.fixAxisPosition();\n      this.setBalloonBounds();\n      this.labels = [];\n      var b = a.container,\n          c = b.set();\n      a.gridSet.push(c);\n      this.set = c;\n      b = b.set();\n      a.axesLabelsSet.push(b);\n      this.labelsSet = b;\n      this.axisLine = new this.axisRenderer(this);\n      this.autoGridCount ? (\"V\" == this.orientation ? (a = this.height / this.minVerticalGap, 3 > a && (a = 3)) : a = this.width / this.minHorizontalGap, this.gridCountR = Math.max(a, 1)) : this.gridCountR = this.gridCount;\n      this.axisWidth = this.axisLine.axisWidth;\n      this.addTitle();\n    },\n    setOrientation: function (a) {\n      this.orientation = a ? \"H\" : \"V\";\n    },\n    addTitle: function () {\n      var a = this.title;\n      this.titleLabel = null;\n\n      if (a) {\n        var b = this.chart,\n            c = this.titleColor;\n        void 0 === c && (c = b.color);\n        var e = this.titleFontSize;\n        isNaN(e) && (e = b.fontSize + 1);\n        a = d.text(b.container, a, c, b.fontFamily, e, this.titleAlign, this.titleBold);\n        d.setCN(b, a, this.bcn + \"title\");\n        this.titleLabel = a;\n      }\n    },\n    positionTitle: function () {\n      var a = this.titleLabel;\n\n      if (a) {\n        var b,\n            c,\n            e = this.labelsSet,\n            h = {};\n        0 < e.length() ? h = e.getBBox() : (h.x = 0, h.y = 0, h.width = this.width, h.height = this.height, d.VML && (h.y += this.y, h.x += this.x));\n        e.push(a);\n        var e = h.x,\n            f = h.y;\n        d.VML && (f -= this.y, e -= this.x);\n        var g = h.width,\n            h = h.height,\n            k = this.width,\n            l = this.height,\n            m = 0,\n            p = a.getBBox().height / 2,\n            q = this.inside,\n            n = this.titleAlign;\n\n        switch (this.position) {\n          case \"top\":\n            b = \"left\" == n ? -1 : \"right\" == n ? k : k / 2;\n            c = f - 10 - p;\n            break;\n\n          case \"bottom\":\n            b = \"left\" == n ? -1 : \"right\" == n ? k : k / 2;\n            c = f + h + 10 + p;\n            break;\n\n          case \"left\":\n            b = e - 10 - p;\n            q && (b -= 5);\n            m = -90;\n            c = (\"left\" == n ? l + 1 : \"right\" == n ? -1 : l / 2) + this.titleDY;\n            this.titleWidth = p + 10;\n            break;\n\n          case \"right\":\n            b = e + g + 10 + p, q && (b += 7), c = (\"left\" == n ? l + 2 : \"right\" == n ? -2 : l / 2) + this.titleDY, this.titleWidth = p + 10, m = -90;\n        }\n\n        this.marginsChanged ? (a.translate(b, c), this.tx = b, this.ty = c) : a.translate(this.tx, this.ty);\n        this.marginsChanged = !1;\n        isNaN(this.titleRotation) || (m = this.titleRotation);\n        0 !== m && a.rotate(m);\n      }\n    },\n    pushAxisItem: function (a, b) {\n      var c = this,\n          e = a.graphics();\n      0 < e.length() && (b ? c.labelsSet.push(e) : c.set.push(e));\n      if (e = a.getLabel()) c.labelsSet.push(e), e.click(function (b) {\n        c.handleMouse(b, a, \"clickItem\");\n      }).touchend(function (b) {\n        c.handleMouse(b, a, \"clickItem\");\n      }).mouseover(function (b) {\n        c.handleMouse(b, a, \"rollOverItem\");\n      }).mouseout(function (b) {\n        c.handleMouse(b, a, \"rollOutItem\");\n      });\n    },\n    handleMouse: function (a, b, c) {\n      this.fire({\n        type: c,\n        value: b.value,\n        serialDataItem: b.serialDataItem,\n        axis: this,\n        target: b.label,\n        chart: this.chart,\n        event: a\n      });\n    },\n    addGuide: function (a) {\n      for (var b = this.guides, c = !1, e = b.length, h = 0; h < b.length; h++) b[h] == a && (c = !0, e = h);\n\n      a = d.processObject(a, d.Guide, this.theme);\n      a.id || (a.id = \"guideAuto\" + e + \"_\" + new Date().getTime());\n      c || b.push(a);\n    },\n    removeGuide: function (a) {\n      var b = this.guides,\n          c;\n\n      for (c = 0; c < b.length; c++) b[c] == a && b.splice(c, 1);\n    },\n    handleGuideOver: function (a) {\n      clearTimeout(this.chart.hoverInt);\n      var b = a.graphics.getBBox(),\n          c = this.x + b.x + b.width / 2,\n          b = this.y + b.y + b.height / 2,\n          e = a.fillColor;\n      void 0 === e && (e = a.lineColor);\n      this.chart.showBalloon(a.balloonText, e, !0, c, b);\n      this.fire({\n        type: \"rollOverGuide\",\n        guide: a,\n        chart: this.chart\n      });\n    },\n    handleGuideOut: function (a) {\n      this.chart.hideBalloon();\n      this.fire({\n        type: \"rollOutGuide\",\n        guide: a,\n        chart: this.chart\n      });\n    },\n    handleGuideClick: function (a) {\n      this.chart.hideBalloon();\n      this.fire({\n        type: \"clickGuide\",\n        guide: a,\n        chart: this.chart\n      });\n    },\n    addEventListeners: function (a, b) {\n      var c = this;\n      a.mouseover(function () {\n        c.handleGuideOver(b);\n      });\n      a.mouseup(function () {\n        c.handleGuideClick(b);\n      });\n      a.touchstart(function () {\n        c.handleGuideOver(b);\n      });\n      a.mouseout(function () {\n        c.handleGuideOut(b);\n      });\n    },\n    getBBox: function () {\n      var a;\n      this.labelsSet && (a = this.labelsSet.getBBox());\n      a ? d.VML || (a = {\n        x: a.x + this.x,\n        y: a.y + this.y,\n        width: a.width,\n        height: a.height\n      }) : a = {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      };\n      return a;\n    },\n    destroy: function () {\n      d.remove(this.set);\n      d.remove(this.labelsSet);\n      var a = this.axisLine;\n      a && d.remove(a.axisSet);\n      d.remove(this.grid0);\n    },\n    chooseMinorFrequency: function (a) {\n      for (var b = 10; 0 < b; b--) if (a / b == Math.round(a / b)) return a / b;\n    },\n    parseDatesDraw: function () {\n      var a,\n          b = this.chart,\n          c = this.showFirstLabel,\n          e = this.showLastLabel,\n          h,\n          f = \"\",\n          g = d.extractPeriod(this.minPeriod),\n          k = d.getPeriodDuration(g.period, g.count),\n          l,\n          m,\n          p,\n          q,\n          n,\n          t = this.firstDayOfWeek,\n          r = this.boldPeriodBeginning;\n      a = this.minorGridEnabled;\n      var w,\n          z = this.gridAlpha,\n          x,\n          u = this.choosePeriod(0),\n          A = u.period,\n          u = u.count,\n          y = d.getPeriodDuration(A, u);\n      y < k && (A = g.period, u = g.count, y = k);\n      g = A;\n      \"WW\" == g && (g = \"DD\");\n      this.stepWidth = this.getStepWidth(this.timeDifference);\n      var B = Math.ceil(this.timeDifference / y) + 5,\n          D = l = d.resetDateToMin(new Date(this.startTime - y), A, u, t).getTime();\n      if (g == A && 1 == u && this.centerLabelOnFullPeriod || this.autoWrap || this.centerLabels) p = y * this.stepWidth, this.autoWrap && !this.centerLabels && (p = -p);\n      this.cellWidth = k * this.stepWidth;\n      q = Math.round(l / y);\n      k = -1;\n      q / 2 == Math.round(q / 2) && (k = -2, l -= y);\n      q = this.firstTime;\n      var C = 0,\n          I = 0;\n      a && 1 < u && (w = this.chooseMinorFrequency(u), x = d.getPeriodDuration(A, w), \"DD\" == A && (x += d.getPeriodDuration(\"hh\")), \"fff\" == A && (x = 1));\n      if (0 < this.gridCountR) for (B - 5 - k > this.autoRotateCount && !isNaN(this.autoRotateAngle) && (this.labelRotationR = this.autoRotateAngle), a = k; a <= B; a++) {\n        n = q + y * (a + Math.floor((D - q) / y)) - C;\n        \"DD\" == A && (n += 36E5);\n        n = d.resetDateToMin(new Date(n), A, u, t).getTime();\n        \"MM\" == A && (h = (n - l) / y, 1.5 <= (n - l) / y && (n = n - (h - 1) * y + d.getPeriodDuration(\"DD\", 3), n = d.resetDateToMin(new Date(n), A, 1).getTime(), C += y));\n        h = (n - this.startTime) * this.stepWidth;\n\n        if (\"radar\" == b.type) {\n          if (h = this.axisWidth - h, 0 > h || h > this.axisWidth) continue;\n        } else this.rotate ? \"date\" == this.type && \"middle\" == this.gridPosition && (I = -y * this.stepWidth / 2) : \"date\" == this.type && (h = this.axisWidth - h);\n\n        f = !1;\n        this.nextPeriod[g] && (f = this.checkPeriodChange(this.nextPeriod[g], 1, n, l, g));\n        l = !1;\n        f && this.markPeriodChange ? (f = this.dateFormatsObject[this.nextPeriod[g]], this.twoLineMode && (f = this.dateFormatsObject[g] + \"\\n\" + f, f = d.fixBrakes(f)), l = !0) : f = this.dateFormatsObject[g];\n        r || (l = !1);\n        this.currentDateFormat = f;\n        f = d.formatDate(new Date(n), f, b);\n        if (a == k && !c || a == B && !e) f = \" \";\n        this.labelFunction && (f = this.labelFunction(f, new Date(n), this, A, u, m).toString());\n        this.boldLabels && (l = !0);\n        m = new this.axisItemRenderer(this, h, f, !1, p, I, !1, l);\n        this.pushAxisItem(m);\n        m = l = n;\n        if (!isNaN(w)) for (h = 1; h < u; h += w) this.gridAlpha = this.minorGridAlpha, f = n + x * h, f = d.resetDateToMin(new Date(f), A, w, t).getTime(), f = new this.axisItemRenderer(this, (f - this.startTime) * this.stepWidth, void 0, void 0, void 0, void 0, void 0, void 0, void 0, !0), this.pushAxisItem(f);\n        this.gridAlpha = z;\n      }\n    },\n    choosePeriod: function (a) {\n      var b = d.getPeriodDuration(this.periods[a].period, this.periods[a].count),\n          c = this.periods;\n      return this.timeDifference < b && 0 < a ? c[a - 1] : Math.ceil(this.timeDifference / b) <= this.gridCountR ? c[a] : a + 1 < c.length ? this.choosePeriod(a + 1) : c[a];\n    },\n    getStepWidth: function (a) {\n      var b;\n      this.startOnAxis ? (b = this.axisWidth / (a - 1), 1 == a && (b = this.axisWidth)) : b = this.axisWidth / a;\n      return b;\n    },\n    timeZoom: function (a, b) {\n      this.startTime = a;\n      this.endTime = b;\n    },\n    minDuration: function () {\n      var a = d.extractPeriod(this.minPeriod);\n      return d.getPeriodDuration(a.period, a.count);\n    },\n    checkPeriodChange: function (a, b, c, e, h) {\n      c = new Date(c);\n      var f = new Date(e),\n          g = this.firstDayOfWeek;\n      e = b;\n      \"DD\" == a && (b = 1);\n      c = d.resetDateToMin(c, a, b, g).getTime();\n      b = d.resetDateToMin(f, a, b, g).getTime();\n      return \"DD\" == a && \"hh\" != h && c - b < d.getPeriodDuration(a, e) - d.getPeriodDuration(\"hh\", 1) ? !1 : c != b ? !0 : !1;\n    },\n    generateDFObject: function () {\n      this.dateFormatsObject = {};\n      var a;\n\n      for (a = 0; a < this.dateFormats.length; a++) {\n        var b = this.dateFormats[a];\n        this.dateFormatsObject[b.period] = b.format;\n      }\n    },\n    hideBalloon: function () {\n      this.balloon && this.balloon.hide && this.balloon.hide();\n      this.prevBY = this.prevBX = NaN;\n    },\n    formatBalloonText: function (a) {\n      return a;\n    },\n    showBalloon: function (a, b, c, e) {\n      var d = this.offset;\n\n      switch (this.position) {\n        case \"bottom\":\n          b = this.height + d;\n          break;\n\n        case \"top\":\n          b = -d;\n          break;\n\n        case \"left\":\n          a = -d;\n          break;\n\n        case \"right\":\n          a = this.width + d;\n      }\n\n      c || (c = this.currentDateFormat);\n\n      if (\"V\" == this.orientation) {\n        if (0 > b || b > this.height) return;\n\n        if (isNaN(b)) {\n          this.hideBalloon();\n          return;\n        }\n\n        b = this.adjustBalloonCoordinate(b, e);\n        e = this.coordinateToValue(b);\n      } else {\n        if (0 > a || a > this.width) return;\n\n        if (isNaN(a)) {\n          this.hideBalloon();\n          return;\n        }\n\n        a = this.adjustBalloonCoordinate(a, e);\n        e = this.coordinateToValue(a);\n      }\n\n      var f;\n      if (d = this.chart.chartCursor) f = d.index;\n\n      if (this.balloon && void 0 !== e && this.balloon.enabled) {\n        if (this.balloonTextFunction) {\n          if (\"date\" == this.type || !0 === this.parseDates) e = new Date(e);\n          e = this.balloonTextFunction(e);\n        } else this.balloonText ? e = this.formatBalloonText(this.balloonText, f, c) : isNaN(e) || (e = this.formatValue(e, c));\n\n        if (a != this.prevBX || b != this.prevBY) this.balloon.setPosition(a, b), this.prevBX = a, this.prevBY = b, e && this.balloon.showBalloon(e);\n      }\n    },\n    adjustBalloonCoordinate: function (a) {\n      return a;\n    },\n    createBalloon: function () {\n      var a = this.chart,\n          b = a.chartCursor;\n      b && (b = b.cursorPosition, \"mouse\" != b && (this.stickBalloonToCategory = !0), \"start\" == b && (this.stickBalloonToStart = !0), \"ValueAxis\" == this.cname && (this.stickBalloonToCategory = !1));\n      this.balloon && (this.balloon.destroy && this.balloon.destroy(), d.extend(this.balloon, a.balloon, !0));\n    },\n    setBalloonBounds: function () {\n      var a = this.balloon;\n\n      if (a) {\n        var b = this.chart;\n        a.cornerRadius = 0;\n        a.shadowAlpha = 0;\n        a.borderThickness = 1;\n        a.borderAlpha = 1;\n        a.adjustBorderColor = !1;\n        a.showBullet = !1;\n        this.balloon = a;\n        a.chart = b;\n        a.mainSet = b.plotBalloonsSet;\n        a.pointerWidth = this.tickLength;\n        if (this.parseDates || \"date\" == this.type) a.pointerWidth = 0;\n        a.className = this.id;\n        b = \"V\";\n        \"V\" == this.orientation && (b = \"H\");\n        this.stickBalloonToCategory || (a.animationDuration = 0);\n        var c,\n            e,\n            d,\n            f,\n            g = this.inside,\n            k = this.width,\n            l = this.height;\n\n        switch (this.position) {\n          case \"bottom\":\n            c = 0;\n            e = k;\n            g ? (d = 0, f = l) : (d = l, f = l + 1E3);\n            break;\n\n          case \"top\":\n            c = 0;\n            e = k;\n            g ? (d = 0, f = l) : (d = -1E3, f = 0);\n            break;\n\n          case \"left\":\n            d = 0;\n            f = l;\n            g ? (c = 0, e = k) : (c = -1E3, e = 0);\n            break;\n\n          case \"right\":\n            d = 0, f = l, g ? (c = 0, e = k) : (c = k, e = k + 1E3);\n        }\n\n        a.drop || (a.pointerOrientation = b);\n        a.setBounds(c, d, e, f);\n      }\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.ValueAxis = d.Class({\n    inherits: d.AxisBase,\n    construct: function (a) {\n      this.cname = \"ValueAxis\";\n      this.createEvents(\"axisChanged\", \"logarithmicAxisFailed\", \"axisZoomed\", \"axisIntZoomed\");\n      d.ValueAxis.base.construct.call(this, a);\n      this.dataChanged = !0;\n      this.stackType = \"none\";\n      this.position = \"left\";\n      this.unitPosition = \"right\";\n      this.includeAllValues = this.recalculateToPercents = this.includeHidden = this.includeGuidesInMinMax = this.integersOnly = !1;\n      this.durationUnits = {\n        DD: \"d. \",\n        hh: \":\",\n        mm: \":\",\n        ss: \"\"\n      };\n      this.scrollbar = !1;\n      this.baseValue = 0;\n      this.radarCategoriesEnabled = !0;\n      this.axisFrequency = 1;\n      this.gridType = \"polygons\";\n      this.useScientificNotation = !1;\n      this.axisTitleOffset = 10;\n      this.pointPosition = \"axis\";\n      this.minMaxMultiplier = 1;\n      this.logGridLimit = 2;\n      this.totalTextOffset = this.treatZeroAs = 0;\n      this.minPeriod = \"ss\";\n      this.relativeStart = 0;\n      this.relativeEnd = 1;\n      d.applyTheme(this, a, this.cname);\n    },\n    updateData: function () {\n      0 >= this.gridCountR && (this.gridCountR = 1);\n      this.totals = [];\n      this.data = this.chart.chartData;\n      var a = this.chart;\n      \"xy\" != a.type && (this.stackGraphs(\"smoothedLine\"), this.stackGraphs(\"line\"), this.stackGraphs(\"column\"), this.stackGraphs(\"step\"));\n      this.recalculateToPercents && this.recalculate();\n      if (this.synchronizationMultiplier && this.synchronizeWith) d.isString(this.synchronizeWith) && (this.synchronizeWith = a.getValueAxisById(this.synchronizeWith)), this.synchronizeWith && (this.synchronizeWithAxis(this.synchronizeWith), this.foundGraphs = !0);else if (this.foundGraphs = !1, this.getMinMax(), 0 === this.start && this.end == this.data.length - 1 && isNaN(this.minZoom) && isNaN(this.maxZoom) || isNaN(this.fullMin) && isNaN(this.fullMax)) this.fullMin = this.min, this.fullMax = this.max, \"date\" != this.type && this.strictMinMax && (isNaN(this.minimum) || (this.fullMin = this.minimum), isNaN(this.maximum) || (this.fullMax = this.maximum)), this.logarithmic && (this.fullMin = this.logMin, 0 === this.fullMin && (this.fullMin = this.treatZeroAs)), \"date\" == this.type && (this.minimumDate || (this.fullMin = this.minRR), this.maximumDate || (this.fullMax = this.maxRR), this.strictMinMax && (this.minimumDate && (this.fullMin = this.minimumDate.getTime()), this.maximumDate && (this.fullMax = this.maximumDate.getTime())));\n    },\n    draw: function () {\n      d.ValueAxis.base.draw.call(this);\n      var a = this.chart,\n          b = this.set;\n      this.labelRotationR = this.labelRotation;\n      d.setCN(a, this.set, \"value-axis value-axis-\" + this.id);\n      d.setCN(a, this.labelsSet, \"value-axis value-axis-\" + this.id);\n      d.setCN(a, this.axisLine.axisSet, \"value-axis value-axis-\" + this.id);\n      var c = this.type;\n      \"duration\" == c && (this.duration = \"ss\");\n      !0 === this.dataChanged && (this.updateData(), this.dataChanged = !1);\n      \"date\" == c && (this.logarithmic = !1, this.min = this.minRR, this.max = this.maxRR, this.reversed = !1, this.getDateMinMax());\n\n      if (this.logarithmic) {\n        var e = this.treatZeroAs,\n            h = this.getExtremes(0, this.data.length - 1).min;\n        !isNaN(this.minimum) && this.minimum < h && (h = this.minimum);\n        this.logMin = h;\n        this.minReal < h && (this.minReal = h);\n        isNaN(this.minReal) && (this.minReal = h);\n        0 < e && 0 === h && (this.minReal = h = e);\n\n        if (0 >= h || 0 >= this.minimum) {\n          this.fire({\n            type: \"logarithmicAxisFailed\",\n            chart: a\n          });\n          return;\n        }\n      }\n\n      this.grid0 = null;\n      var f,\n          g,\n          k = a.dx,\n          l = a.dy,\n          e = !1,\n          h = this.logarithmic;\n      if (isNaN(this.min) || isNaN(this.max) || !this.foundGraphs || Infinity == this.min || -Infinity == this.max) e = !0;else {\n        \"date\" == this.type && this.min == this.max && (this.max += this.minDuration(), this.min -= this.minDuration());\n        var m = this.labelFrequency,\n            p = this.showFirstLabel,\n            q = this.showLastLabel,\n            n = 1,\n            t = 0;\n        this.minCalc = this.min;\n        this.maxCalc = this.max;\n        if (this.strictMinMax && (isNaN(this.minimum) || (this.min = this.minimum), isNaN(this.maximum) || (this.max = this.maximum), this.min == this.max)) return;\n        isNaN(this.minZoom) || (this.minReal = this.min = this.minZoom);\n        isNaN(this.maxZoom) || (this.max = this.maxZoom);\n\n        if (this.logarithmic) {\n          g = this.fullMin;\n          var r = this.fullMax;\n          isNaN(this.minimum) || (g = this.minimum);\n          isNaN(this.maximum) || (r = this.maximum);\n          var r = Math.log(r) * Math.LOG10E - Math.log(g) * Math.LOG10E,\n              w = Math.log(this.max) / Math.LN10 - Math.log(g) * Math.LOG10E;\n          this.relativeStart = d.roundTo((Math.log(this.minReal) / Math.LN10 - Math.log(g) * Math.LOG10E) / r, 5);\n          this.relativeEnd = d.roundTo(w / r, 5);\n        } else this.relativeStart = d.roundTo(d.fitToBounds((this.min - this.fullMin) / (this.fullMax - this.fullMin), 0, 1), 5), this.relativeEnd = d.roundTo(d.fitToBounds((this.max - this.fullMin) / (this.fullMax - this.fullMin), 0, 1), 5);\n\n        var r = Math.round((this.maxCalc - this.minCalc) / this.step) + 1,\n            z;\n        !0 === h ? (z = Math.log(this.max) * Math.LOG10E - Math.log(this.minReal) * Math.LOG10E, this.stepWidth = this.axisWidth / z, z > this.logGridLimit && (r = Math.ceil(Math.log(this.max) * Math.LOG10E) + 1, t = Math.round(Math.log(this.minReal) * Math.LOG10E), r > this.gridCountR && (n = Math.ceil(r / this.gridCountR)))) : this.stepWidth = this.axisWidth / (this.max - this.min);\n        var x = 0;\n        1 > this.step && -1 < this.step && (x = d.getDecimals(this.step));\n        this.integersOnly && (x = 0);\n        x > this.maxDecCount && (x = this.maxDecCount);\n        w = this.precision;\n        isNaN(w) || (x = w);\n        isNaN(this.maxZoom) && (this.max = d.roundTo(this.max, this.maxDecCount), this.min = d.roundTo(this.min, this.maxDecCount));\n        g = {};\n        g.precision = x;\n        g.decimalSeparator = a.nf.decimalSeparator;\n        g.thousandsSeparator = a.nf.thousandsSeparator;\n        this.numberFormatter = g;\n        var u;\n        this.exponential = !1;\n\n        for (g = t; g < r; g += n) {\n          var A = d.roundTo(this.step * g + this.min, x);\n          -1 != String(A).indexOf(\"e\") && (this.exponential = !0);\n        }\n\n        this.duration && (this.maxInterval = d.getMaxInterval(this.max, this.duration));\n        var x = this.step,\n            y,\n            A = this.minorGridAlpha;\n        this.minorGridEnabled && (y = this.getMinorGridStep(x, this.stepWidth * x));\n        if (this.autoGridCount || 0 !== this.gridCount) if (\"date\" == c) this.generateDFObject(), this.timeDifference = this.max - this.min, this.maxTime = this.lastTime = this.max, this.startTime = this.firstTime = this.min, this.parseDatesDraw();else for (r >= this.autoRotateCount && !isNaN(this.autoRotateAngle) && (this.labelRotationR = this.autoRotateAngle), c = this.minCalc, h && (r++, c = this.maxCalc - r * x), this.gridCountReal = r, g = this.startCount = t; g < r; g += n) if (t = x * g + c, t = d.roundTo(t, this.maxDecCount + 1), !this.integersOnly || Math.round(t) == t) if (isNaN(w) || Number(d.toFixed(t, w)) == t) {\n          if (!0 === h) if (z > this.logGridLimit) t = Math.pow(10, g);else if (0 >= t && (t = c + x * g + x / 2, 0 >= t)) continue;\n          u = this.formatValue(t, !1, g);\n          Math.round(g / m) != g / m && (u = void 0);\n          if (0 === g && !p || g == r - 1 && !q) u = \" \";\n          f = this.getCoordinate(t);\n          var B;\n          this.rotate && this.autoWrap && (B = this.stepWidth * x - 10);\n          u = new this.axisItemRenderer(this, f, u, void 0, B, void 0, void 0, this.boldLabels);\n          this.pushAxisItem(u);\n\n          if (t == this.baseValue && \"radar\" != a.type) {\n            var D,\n                C,\n                I = this.width,\n                H = this.height;\n            \"H\" == this.orientation ? 0 <= f && f <= I + 1 && (D = [f, f, f + k], C = [H, 0, l]) : 0 <= f && f <= H + 1 && (D = [0, I, I + k], C = [f, f, f + l]);\n            D && (f = d.fitToBounds(2 * this.gridAlpha, 0, 1), isNaN(this.zeroGridAlpha) || (f = this.zeroGridAlpha), f = d.line(a.container, D, C, this.gridColor, f, 1, this.dashLength), f.translate(this.x, this.y), this.grid0 = f, a.axesSet.push(f), f.toBack(), d.setCN(a, f, this.bcn + \"zero-grid-\" + this.id), d.setCN(a, f, this.bcn + \"zero-grid\"));\n          }\n\n          if (!isNaN(y) && 0 < A && g < r - 1) {\n            f = x / y;\n            h && (y = x * (g + n) + this.minCalc, y = d.roundTo(y, this.maxDecCount + 1), z > this.logGridLimit && (y = Math.pow(10, g + n)), f = 9, y = (y - t) / f);\n            I = this.gridAlpha;\n            this.gridAlpha = this.minorGridAlpha;\n\n            for (H = 1; H < f; H++) {\n              var Q = this.getCoordinate(t + y * H),\n                  Q = new this.axisItemRenderer(this, Q, \"\", !1, 0, 0, !1, !1, 0, !0);\n              this.pushAxisItem(Q);\n            }\n\n            this.gridAlpha = I;\n          }\n        }\n        z = this.guides;\n        B = z.length;\n\n        if (0 < B) {\n          D = this.fillAlpha;\n\n          for (g = this.fillAlpha = 0; g < B; g++) C = z[g], k = NaN, y = C.above, isNaN(C.toValue) || (k = this.getCoordinate(C.toValue), u = new this.axisItemRenderer(this, k, \"\", !0, NaN, NaN, C), this.pushAxisItem(u, y)), l = NaN, isNaN(C.value) || (l = this.getCoordinate(C.value), u = new this.axisItemRenderer(this, l, C.label, !0, NaN, (k - l) / 2, C), this.pushAxisItem(u, y)), isNaN(k) && (l -= 3, k = l + 3), u && (m = u.label) && this.addEventListeners(m, C), isNaN(k - l) || 0 > l && 0 > k || (k = new this.guideFillRenderer(this, l, k, C), this.pushAxisItem(k, y), y = k.graphics(), C.graphics = y, this.addEventListeners(y, C));\n\n          this.fillAlpha = D;\n        }\n\n        u = this.baseValue;\n        this.min > this.baseValue && this.max > this.baseValue && (u = this.min);\n        this.min < this.baseValue && this.max < this.baseValue && (u = this.max);\n        h && u < this.minReal && (u = this.minReal);\n        this.baseCoord = this.getCoordinate(u, !0);\n        u = {\n          type: \"axisChanged\",\n          target: this,\n          chart: a\n        };\n        u.min = h ? this.minReal : this.min;\n        u.max = this.max;\n        this.fire(u);\n        this.axisCreated = !0;\n      }\n      h = this.axisLine.set;\n      u = this.labelsSet;\n      b.translate(this.x, this.y);\n      u.translate(this.x, this.y);\n      this.positionTitle();\n      \"radar\" != a.type && h.toFront();\n      !this.visible || e ? (b.hide(), h.hide(), u.hide()) : (b.show(), h.show(), u.show());\n      this.axisY = this.y;\n      this.axisX = this.x;\n    },\n    getDateMinMax: function () {\n      this.minimumDate && (this.minimumDate instanceof Date || (this.minimumDate = d.getDate(this.minimumDate, this.chart.dataDateFormat, \"fff\")), this.min = this.minimumDate.getTime());\n      this.maximumDate && (this.maximumDate instanceof Date || (this.maximumDate = d.getDate(this.maximumDate, this.chart.dataDateFormat, \"fff\")), this.max = this.maximumDate.getTime());\n    },\n    formatValue: function (a, b, c) {\n      var e = this.exponential,\n          h = this.logarithmic,\n          f = this.numberFormatter,\n          g = this.chart;\n      if (f) return !0 === this.logarithmic && (e = -1 != String(a).indexOf(\"e\") ? !0 : !1), this.useScientificNotation && (e = !0), this.usePrefixes && (e = !1), e ? (c = -1 == String(a).indexOf(\"e\") ? a.toExponential(15) : String(a), e = c.split(\"e\"), c = Number(e[0]), e = Number(e[1]), c = d.roundTo(c, 14), b || isNaN(this.precision) || (c = d.roundTo(c, this.precision)), 10 == c && (c = 1, e += 1), c = c + \"e\" + e, 0 === a && (c = \"0\"), 1 == a && (c = \"1\")) : (h && (e = String(a).split(\".\"), e[1] ? (f.precision = e[1].length, 0 > c && (f.precision = Math.abs(c)), b && 1 < a && (f.precision = 0), b || isNaN(this.precision) || (f.precision = this.precision)) : f.precision = -1), c = this.usePrefixes ? d.addPrefix(a, g.prefixesOfBigNumbers, g.prefixesOfSmallNumbers, f, !b) : d.formatNumber(a, f, f.precision)), this.duration && (b && (f.precision = 0), c = d.formatDuration(a, this.duration, \"\", this.durationUnits, this.maxInterval, f)), \"date\" == this.type && (c = d.formatDate(new Date(a), this.currentDateFormat, g)), this.recalculateToPercents ? c += \"%\" : (b = this.unit) && (c = \"left\" == this.unitPosition ? b + c : c + b), this.labelFunction && (c = \"date\" == this.type ? this.labelFunction(c, new Date(a), this).toString() : this.labelFunction(a, c, this).toString()), c;\n    },\n    getMinorGridStep: function (a, b) {\n      var c = [5, 4, 2];\n      60 > b && c.shift();\n\n      for (var e = Math.floor(Math.log(Math.abs(a)) * Math.LOG10E), d = 0; d < c.length; d++) {\n        var f = a / c[d],\n            g = Math.floor(Math.log(Math.abs(f)) * Math.LOG10E);\n        if (!(1 < Math.abs(e - g))) if (1 > a) {\n          if (g = Math.pow(10, -g) * f, g == Math.round(g)) return f;\n        } else if (f == Math.round(f)) return f;\n      }\n    },\n    stackGraphs: function (a) {\n      var b = this.stackType;\n      \"stacked\" == b && (b = \"regular\");\n      \"line\" == b && (b = \"none\");\n      \"100% stacked\" == b && (b = \"100%\");\n      this.stackType = b;\n      var c = [],\n          e = [],\n          h = [],\n          f = [],\n          g,\n          k = this.chart.graphs,\n          l,\n          m,\n          p,\n          q,\n          n,\n          t = this.baseValue,\n          r = !1;\n      if (\"line\" == a || \"step\" == a || \"smoothedLine\" == a) r = !0;\n      if (r && (\"regular\" == b || \"100%\" == b)) for (q = 0; q < k.length; q++) p = k[q], p.stackGraph = null, p.hidden || (m = p.type, p.chart == this.chart && p.valueAxis == this && a == m && p.stackable && (l && (p.stackGraph = l), l = p));\n      p = this.start - 10;\n      l = this.end + 10;\n      q = this.data.length - 1;\n      p = d.fitToBounds(p, 0, q);\n      l = d.fitToBounds(l, 0, q);\n\n      for (n = p; n <= l; n++) {\n        var w = 0;\n\n        for (q = 0; q < k.length; q++) if (p = k[q], p.hidden) p.newStack && (h[n] = NaN, e[n] = NaN);else if (m = p.type, p.chart == this.chart && p.valueAxis == this && a == m && p.stackable) if (m = this.data[n].axes[this.id].graphs[p.id], g = m.values.value, isNaN(g)) p.newStack && (h[n] = NaN, e[n] = NaN);else {\n          var z = d.getDecimals(g);\n          w < z && (w = z);\n          isNaN(f[n]) ? f[n] = Math.abs(g) : f[n] += Math.abs(g);\n          f[n] = d.roundTo(f[n], w);\n          z = p.fillToGraph;\n          r && z && (z = this.data[n].axes[this.id].graphs[z.id]) && (m.values.open = z.values.value);\n          \"regular\" == b && (r && (isNaN(c[n]) ? (c[n] = g, m.values.close = g, m.values.open = this.baseValue) : (isNaN(g) ? m.values.close = c[n] : m.values.close = g + c[n], m.values.open = c[n], c[n] = m.values.close)), \"column\" == a && (p.newStack && (h[n] = NaN, e[n] = NaN), m.values.close = g, 0 > g ? (m.values.close = g, isNaN(e[n]) ? m.values.open = t : (m.values.close += e[n], m.values.open = e[n]), e[n] = m.values.close) : (m.values.close = g, isNaN(h[n]) ? m.values.open = t : (m.values.close += h[n], m.values.open = h[n]), h[n] = m.values.close)));\n        }\n      }\n\n      for (n = this.start; n <= this.end; n++) for (q = 0; q < k.length; q++) (p = k[q], p.hidden) ? p.newStack && (h[n] = NaN, e[n] = NaN) : (m = p.type, p.chart == this.chart && p.valueAxis == this && a == m && p.stackable && (m = this.data[n].axes[this.id].graphs[p.id], g = m.values.value, isNaN(g) || (c = g / f[n] * 100, m.values.percents = c, m.values.total = f[n], p.newStack && (h[n] = NaN, e[n] = NaN), \"100%\" == b && (isNaN(e[n]) && (e[n] = 0), isNaN(h[n]) && (h[n] = 0), 0 > c ? (m.values.close = d.fitToBounds(c + e[n], -100, 100), m.values.open = e[n], e[n] = m.values.close) : (m.values.close = d.fitToBounds(c + h[n], -100, 100), m.values.open = h[n], h[n] = m.values.close)))));\n    },\n    recalculate: function () {\n      var a = this.chart,\n          b = a.graphs,\n          c;\n\n      for (c = 0; c < b.length; c++) {\n        var e = b[c];\n\n        if (e.valueAxis == this) {\n          var h = \"value\";\n          if (\"candlestick\" == e.type || \"ohlc\" == e.type) h = \"open\";\n          var f,\n              g,\n              k = this.end + 2,\n              k = d.fitToBounds(this.end + 1, 0, this.data.length - 1),\n              l = this.start;\n          0 < l && l--;\n          var m;\n          g = this.start;\n          e.compareFromStart && (g = 0);\n\n          if (!isNaN(a.startTime) && (m = a.categoryAxis)) {\n            var p = m.minDuration(),\n                p = new Date(a.startTime + p / 2),\n                q = d.resetDateToMin(new Date(a.startTime), m.minPeriod).getTime();\n            d.resetDateToMin(new Date(p), m.minPeriod).getTime() > q && g++;\n          }\n\n          if (m = a.recalculateFromDate) m = d.getDate(m, a.dataDateFormat, \"fff\"), g = a.getClosestIndex(a.chartData, \"time\", m.getTime(), !0, 0, a.chartData.length), k = a.chartData.length - 1;\n\n          for (m = g; m <= k && (g = this.data[m].axes[this.id].graphs[e.id], f = g.values[h], e.recalculateValue && (f = g.dataContext[e.valueField + e.recalculateValue]), isNaN(f)); m++);\n\n          this.recBaseValue = f;\n\n          for (h = l; h <= k; h++) {\n            g = this.data[h].axes[this.id].graphs[e.id];\n            g.percents = {};\n            var l = g.values,\n                n;\n\n            for (n in l) g.percents[n] = \"percents\" != n ? l[n] / f * 100 - 100 : l[n];\n          }\n        }\n      }\n    },\n    getMinMax: function () {\n      var a = !1,\n          b = this.chart,\n          c = b.graphs,\n          e;\n\n      for (e = 0; e < c.length; e++) {\n        var h = c[e].type;\n        (\"line\" == h || \"step\" == h || \"smoothedLine\" == h) && this.expandMinMax && (a = !0);\n      }\n\n      a && (0 < this.start && this.start--, this.end < this.data.length - 1 && this.end++);\n      \"serial\" == b.type && (!0 !== b.categoryAxis.parseDates || a || this.end < this.data.length - 1 && this.end++);\n      this.includeAllValues && (this.start = 0, this.end = this.data.length - 1);\n      a = this.minMaxMultiplier;\n      b = this.getExtremes(this.start, this.end);\n      this.min = b.min;\n      this.max = b.max;\n      this.minRR = this.min;\n      this.maxRR = this.max;\n      a = (this.max - this.min) * (a - 1);\n      this.min -= a;\n      this.max += a;\n      a = this.guides.length;\n      if (this.includeGuidesInMinMax && 0 < a) for (b = 0; b < a; b++) c = this.guides[b], c.toValue < this.min && (this.min = c.toValue), c.value < this.min && (this.min = c.value), c.toValue > this.max && (this.max = c.toValue), c.value > this.max && (this.max = c.value);\n      isNaN(this.minimum) || (this.min = this.minimum);\n      isNaN(this.maximum) || (this.max = this.maximum);\n      \"date\" == this.type && this.getDateMinMax();\n      this.min > this.max && (a = this.max, this.max = this.min, this.min = a);\n      isNaN(this.minZoom) || (this.min = this.minZoom);\n      isNaN(this.maxZoom) || (this.max = this.maxZoom);\n      this.minCalc = this.min;\n      this.maxCalc = this.max;\n      this.minReal = this.min;\n      this.maxReal = this.max;\n      0 === this.min && 0 === this.max && (this.max = 9);\n      this.min > this.max && (this.min = this.max - 1);\n      a = this.min;\n      b = this.max;\n      c = this.max - this.min;\n      e = 0 === c ? Math.pow(10, Math.floor(Math.log(Math.abs(this.max)) * Math.LOG10E)) / 10 : Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;\n      isNaN(this.maximum) && (this.max = Math.ceil(this.max / e) * e + e);\n      isNaN(this.minimum) && (this.min = Math.floor(this.min / e) * e - e);\n      0 > this.min && 0 <= a && (this.min = 0);\n      0 < this.max && 0 >= b && (this.max = 0);\n      \"100%\" == this.stackType && (this.min = 0 > this.min ? -100 : 0, this.max = 0 > this.max ? 0 : 100);\n      c = this.max - this.min;\n      e = Math.pow(10, Math.floor(Math.log(Math.abs(c)) * Math.LOG10E)) / 10;\n      this.step = Math.ceil(c / this.gridCountR / e) * e;\n      c = Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E));\n      c = d.fixStepE(c);\n      e = Math.ceil(this.step / c);\n      5 < e && (e = 10);\n      5 >= e && 2 < e && (e = 5);\n      this.step = Math.ceil(this.step / (c * e)) * c * e;\n      isNaN(this.setStep) || (this.step = this.setStep);\n      1 > c ? (this.maxDecCount = Math.abs(Math.log(Math.abs(c)) * Math.LOG10E), this.maxDecCount = Math.round(this.maxDecCount), this.step = d.roundTo(this.step, this.maxDecCount + 1)) : this.maxDecCount = 0;\n      this.min = this.step * Math.floor(this.min / this.step);\n      this.max = this.step * Math.ceil(this.max / this.step);\n      0 > this.min && 0 <= a && (this.min = 0);\n      0 < this.max && 0 >= b && (this.max = 0);\n      1 < this.minReal && 1 < this.max - this.minReal && (this.minReal = Math.floor(this.minReal));\n      c = Math.pow(10, Math.floor(Math.log(Math.abs(this.minReal)) * Math.LOG10E));\n      0 === this.min && (this.minReal = c);\n      0 === this.min && 1 < this.minReal && (this.minReal = 1);\n      0 < this.min && 0 < this.minReal - this.step && (this.minReal = this.min + this.step < this.minReal ? this.min + this.step : this.min);\n      this.logarithmic && (2 < Math.log(b) * Math.LOG10E - Math.log(a) * Math.LOG10E ? (this.minReal = this.min = Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)), this.maxReal = this.max = Math.pow(10, Math.ceil(Math.log(Math.abs(b)) * Math.LOG10E))) : (a = Math.pow(10, Math.floor(Math.log(Math.abs(a)) * Math.LOG10E)) / 10, Math.pow(10, Math.floor(Math.log(Math.abs(this.min)) * Math.LOG10E)) / 10 < a && (this.minReal = this.min = 10 * a)));\n    },\n    getExtremes: function (a, b) {\n      var c, e, d;\n\n      for (d = a; d <= b; d++) {\n        var f = this.data[d].axes[this.id].graphs,\n            g;\n\n        for (g in f) if (f.hasOwnProperty(g)) {\n          var k = this.chart.graphsById[g];\n\n          if (k.includeInMinMax && (!k.hidden || this.includeHidden)) {\n            isNaN(c) && (c = Infinity);\n            isNaN(e) && (e = -Infinity);\n            this.foundGraphs = !0;\n            k = f[g].values;\n            this.recalculateToPercents && (k = f[g].percents);\n            var l;\n            if (this.minMaxField) l = k[this.minMaxField], l < c && (c = l), l > e && (e = l);else for (var m in k) k.hasOwnProperty(m) && \"percents\" != m && \"total\" != m && \"error\" != m && (l = k[m], l < c && (c = l), l > e && (e = l));\n          }\n        }\n      }\n\n      return {\n        min: c,\n        max: e\n      };\n    },\n    zoomOut: function (a) {\n      this.maxZoom = this.minZoom = NaN;\n      this.zoomToRelativeValues(0, 1, a);\n    },\n    zoomToRelativeValues: function (a, b, c) {\n      if (this.reversed) {\n        var e = a;\n        a = 1 - b;\n        b = 1 - e;\n      }\n\n      var d = this.fullMax,\n          e = this.fullMin,\n          f = e + (d - e) * a,\n          g = e + (d - e) * b;\n      0 <= this.minimum && 0 > f && (f = 0);\n      this.logarithmic && (isNaN(this.minimum) || (e = this.minimum), isNaN(this.maximum) || (d = this.maximum), d = Math.log(d) * Math.LOG10E - Math.log(e) * Math.LOG10E, f = Math.pow(10, d * a + Math.log(e) * Math.LOG10E), g = Math.pow(10, d * b + Math.log(e) * Math.LOG10E));\n      return this.zoomToValues(f, g, c);\n    },\n    zoomToValues: function (a, b, c) {\n      if (b < a) {\n        var e = b;\n        b = a;\n        a = e;\n      }\n\n      var h = this.fullMax,\n          e = this.fullMin;\n      this.relativeStart = d.roundTo((a - e) / (h - e), 9);\n      this.relativeEnd = d.roundTo((b - e) / (h - e), 9);\n\n      if (this.logarithmic) {\n        isNaN(this.minimum) || (e = this.minimum);\n        isNaN(this.maximum) || (h = this.maximum);\n        var h = Math.log(h) * Math.LOG10E - Math.log(e) * Math.LOG10E,\n            f = Math.log(b) / Math.LN10 - Math.log(e) * Math.LOG10E;\n        this.relativeStart = d.roundTo((Math.log(a) / Math.LN10 - Math.log(e) * Math.LOG10E) / h, 9);\n        this.relativeEnd = d.roundTo(f / h, 9);\n      }\n\n      if (this.minZoom != a || this.maxZoom != b) return this.minZoom = a, this.maxZoom = b, e = {\n        type: \"axisZoomed\"\n      }, e.chart = this.chart, e.valueAxis = this, e.startValue = a, e.endValue = b, e.relativeStart = this.relativeStart, e.relativeEnd = this.relativeEnd, this.prevStartValue == a && this.prevEndValue == b || this.fire(e), this.prevStartValue = a, this.prevEndValue = b, c || (a = {}, d.copyProperties(e, a), a.type = \"axisIntZoomed\", this.fire(a)), 0 === this.relativeStart && 1 == this.relativeEnd && (this.maxZoom = this.minZoom = NaN), !0;\n    },\n    coordinateToValue: function (a) {\n      if (isNaN(a)) return NaN;\n      var b = this.axisWidth,\n          c = this.stepWidth,\n          e = this.reversed,\n          d = this.rotate,\n          f = this.min,\n          g = this.minReal;\n      return !0 === this.logarithmic ? Math.pow(10, (d ? !0 === e ? (b - a) / c : a / c : !0 === e ? a / c : (b - a) / c) + Math.log(g) * Math.LOG10E) : !0 === e ? d ? f - (a - b) / c : a / c + f : d ? a / c + f : f - (a - b) / c;\n    },\n    getCoordinate: function (a, b) {\n      if (isNaN(a)) return NaN;\n      var c = this.rotate,\n          e = this.reversed,\n          d = this.axisWidth,\n          f = this.stepWidth,\n          g = this.min,\n          k = this.minReal;\n      !0 === this.logarithmic ? (0 === a && (a = this.treatZeroAs), g = Math.log(a) * Math.LOG10E - Math.log(k) * Math.LOG10E, c = c ? !0 === e ? d - f * g : f * g : !0 === e ? f * g : d - f * g) : c = !0 === e ? c ? d - f * (a - g) : f * (a - g) : c ? f * (a - g) : d - f * (a - g);\n      1E7 < Math.abs(c) && (c = c / Math.abs(c) * 1E7);\n      b || (c = Math.round(c));\n      return c;\n    },\n    synchronizeWithAxis: function (a) {\n      this.synchronizeWith = a;\n      this.listenTo(this.synchronizeWith, \"axisChanged\", this.handleSynchronization);\n    },\n    handleSynchronization: function () {\n      if (this.synchronizeWith) {\n        d.isString(this.synchronizeWith) && (this.synchronizeWith = this.chart.getValueAxisById(this.synchronizeWith));\n        var a = this.synchronizeWith,\n            b = a.min,\n            c = a.max,\n            a = a.step,\n            e = this.synchronizationMultiplier;\n        e && (this.min = b * e, this.max = c * e, this.step = a * e, b = Math.abs(Math.log(Math.abs(Math.pow(10, Math.floor(Math.log(Math.abs(this.step)) * Math.LOG10E)))) * Math.LOG10E), this.maxDecCount = b = Math.round(b), this.draw());\n      }\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.RecAxis = d.Class({\n    construct: function (a) {\n      var b = a.chart,\n          c = a.axisThickness,\n          e = a.axisColor,\n          h = a.axisAlpha,\n          f = a.offset,\n          g = a.dx,\n          k = a.dy,\n          l = a.x,\n          m = a.y,\n          p = a.height,\n          q = a.width,\n          n = b.container;\n      \"H\" == a.orientation ? (e = d.line(n, [0, q], [0, 0], e, h, c), this.axisWidth = a.width, \"bottom\" == a.position ? (k = c / 2 + f + p + m - 1, c = l) : (k = -c / 2 - f + m + k, c = g + l)) : (this.axisWidth = a.height, \"right\" == a.position ? (e = d.line(n, [0, 0, -g], [0, p, p - k], e, h, c), k = m + k, c = c / 2 + f + g + q + l - 1) : (e = d.line(n, [0, 0], [0, p], e, h, c), k = m, c = -c / 2 - f + l));\n      e.translate(c, k);\n      c = b.container.set();\n      c.push(e);\n      b.axesSet.push(c);\n      d.setCN(b, e, a.bcn + \"line\");\n      this.axisSet = c;\n      this.set = e;\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.RecItem = d.Class({\n    construct: function (a, b, c, e, h, f, g, k, l, m, p, q) {\n      b = Math.round(b);\n      var n = a.chart;\n      this.value = c;\n      void 0 == c && (c = \"\");\n      l || (l = 0);\n      void 0 == e && (e = !0);\n      var t = n.fontFamily,\n          r = a.fontSize;\n      void 0 == r && (r = n.fontSize);\n      var w = a.color;\n      void 0 == w && (w = n.color);\n      void 0 !== p && (w = p);\n      var z = a.chart.container,\n          x = z.set();\n      this.set = x;\n      var u = a.axisThickness,\n          A = a.axisColor,\n          y = a.axisAlpha,\n          B = a.tickLength,\n          D = a.gridAlpha,\n          C = a.gridThickness,\n          I = a.gridColor,\n          H = a.dashLength,\n          Q = a.fillColor,\n          M = a.fillAlpha,\n          P = a.labelsEnabled;\n      p = a.labelRotationR;\n      var ia = a.counter,\n          J = a.inside,\n          aa = a.labelOffset,\n          ma = a.dx,\n          na = a.dy,\n          Pa = a.orientation,\n          Z = a.position,\n          da = a.previousCoord,\n          X = a.height,\n          xa = a.width,\n          ea = a.offset,\n          fa,\n          Ba;\n      g ? (void 0 !== g.id && (q = n.classNamePrefix + \"-guide-\" + g.id), P = !0, isNaN(g.tickLength) || (B = g.tickLength), void 0 != g.lineColor && (I = g.lineColor), void 0 != g.color && (w = g.color), isNaN(g.lineAlpha) || (D = g.lineAlpha), isNaN(g.dashLength) || (H = g.dashLength), isNaN(g.lineThickness) || (C = g.lineThickness), !0 === g.inside && (J = !0, 0 < ea && (ea = 0)), isNaN(g.labelRotation) || (p = g.labelRotation), isNaN(g.fontSize) || (r = g.fontSize), g.position && (Z = g.position), void 0 !== g.boldLabel && (k = g.boldLabel), isNaN(g.labelOffset) || (aa = g.labelOffset)) : \"\" === c && (B = 0);\n      m && !isNaN(a.minorTickLength) && (B = a.minorTickLength);\n      var ga = \"start\";\n      0 < h && (ga = \"middle\");\n      a.centerLabels && (ga = \"middle\");\n      var V = p * Math.PI / 180,\n          Y,\n          Da,\n          G = 0,\n          v = 0,\n          oa = 0,\n          ha = Y = 0,\n          Qa = 0;\n      \"V\" == Pa && (p = 0);\n      var ca;\n      P && \"\" !== c && (ca = a.autoWrap && 0 === p ? d.wrappedText(z, c, w, t, r, ga, k, Math.abs(h), 0) : d.text(z, c, w, t, r, ga, k), ga = ca.getBBox(), ha = ga.width, Qa = ga.height);\n\n      if (\"H\" == Pa) {\n        if (0 <= b && b <= xa + 1 && (0 < B && 0 < y && b + l <= xa + 1 && (fa = d.line(z, [b + l, b + l], [0, B], A, y, C), x.push(fa)), 0 < D && (Ba = d.line(z, [b, b + ma, b + ma], [X, X + na, na], I, D, C, H), x.push(Ba))), v = 0, G = b, g && 90 == p && J && (G -= r), !1 === e ? (ga = \"start\", v = \"bottom\" == Z ? J ? v + B : v - B : J ? v - B : v + B, G += 3, 0 < h && (G += h / 2 - 3, ga = \"middle\"), 0 < p && (ga = \"middle\")) : ga = \"middle\", 1 == ia && 0 < M && !g && !m && da < xa && (e = d.fitToBounds(b, 0, xa), da = d.fitToBounds(da, 0, xa), Y = e - da, 0 < Y && (Da = d.rect(z, Y, a.height, Q, M), Da.translate(e - Y + ma, na), x.push(Da))), \"bottom\" == Z ? (v += X + r / 2 + ea, J ? (0 < p ? (v = X - ha / 2 * Math.sin(V) - B - 3, a.centerRotatedLabels || (G += ha / 2 * Math.cos(V) - 4 + 2)) : 0 > p ? (v = X + ha * Math.sin(V) - B - 3 + 2, G += -ha * Math.cos(V) - Qa * Math.sin(V) - 4) : v -= B + r + 3 + 3, v -= aa) : (0 < p ? (v = X + ha / 2 * Math.sin(V) + B + 3, a.centerRotatedLabels || (G -= ha / 2 * Math.cos(V))) : 0 > p ? (v = X + B + 3 - ha / 2 * Math.sin(V) + 2, G += ha / 2 * Math.cos(V)) : v += B + u + 3 + 3, v += aa)) : (v += na + r / 2 - ea, G += ma, J ? (0 < p ? (v = ha / 2 * Math.sin(V) + B + 3, a.centerRotatedLabels || (G -= ha / 2 * Math.cos(V))) : v += B + 3, v += aa) : (0 < p ? (v = -(ha / 2) * Math.sin(V) - B - 6, a.centerRotatedLabels || (G += ha / 2 * Math.cos(V))) : v -= B + r + 3 + u + 3, v -= aa)), \"bottom\" == Z ? Y = (J ? X - B - 1 : X + u - 1) + ea : (oa = ma, Y = (J ? na : na - B - u + 1) - ea), f && (G += f), r = G, 0 < p && (r += ha / 2 * Math.cos(V)), ca && (f = 0, J && (f = ha / 2 * Math.cos(V)), r + f > xa + 2 || 0 > r)) ca.remove(), ca = null;\n      } else {\n        0 <= b && b <= X + 1 && (0 < B && 0 < y && b + l <= X + 1 && (fa = d.line(z, [0, B + 1], [b + l, b + l], A, y, C), x.push(fa)), 0 < D && (Ba = d.line(z, [0, ma, xa + ma], [b, b + na, b + na], I, D, C, H), x.push(Ba)));\n        ga = \"end\";\n        if (!0 === J && \"left\" == Z || !1 === J && \"right\" == Z) ga = \"start\";\n        v = b - Qa / 2 + 2;\n        1 == ia && 0 < M && !g && !m && (e = d.fitToBounds(b, 0, X), da = d.fitToBounds(da, 0, X), V = e - da, Da = d.polygon(z, [0, a.width, a.width, 0], [0, 0, V, V], Q, M), Da.translate(ma, e - V + na), x.push(Da));\n        v += r / 2;\n        \"right\" == Z ? (G += ma + xa + ea, v += na, J ? (f || (v -= r / 2 + 3), G = G - (B + 4) - aa) : (G += B + 4 + u, v -= 2, G += aa)) : J ? (G += B + 4 - ea, f || (v -= r / 2 + 3), g && (G += ma, v += na), G += aa) : (G += -B - u - 4 - 2 - ea, v -= 2, G -= aa);\n        fa && (\"right\" == Z ? (oa += ma + ea + xa - 1, Y += na, oa = J ? oa - u : oa + u) : (oa -= ea, J || (oa -= B + u)));\n        f && (v += f);\n        J = -3;\n        \"right\" == Z && (J += na);\n        ca && (v > X + 1 || v < J - r / 10) && (ca.remove(), ca = null);\n      }\n\n      fa && (fa.translate(oa, Y), d.setCN(n, fa, a.bcn + \"tick\"), d.setCN(n, fa, q, !0), g && d.setCN(n, fa, \"guide\"));\n      !1 === a.visible && (fa && fa.remove(), ca && (ca.remove(), ca = null));\n      ca && (ca.attr({\n        \"text-anchor\": ga\n      }), ca.translate(G, v, NaN, !0), 0 !== p && ca.rotate(-p, a.chart.backgroundColor), a.allLabels.push(ca), this.label = ca, d.setCN(n, ca, a.bcn + \"label\"), d.setCN(n, ca, q, !0), g && d.setCN(n, ca, \"guide\"));\n      Ba && (d.setCN(n, Ba, a.bcn + \"grid\"), d.setCN(n, Ba, q, !0), g && d.setCN(n, Ba, \"guide\"));\n      Da && (d.setCN(n, Da, a.bcn + \"fill\"), d.setCN(n, Da, q, !0));\n      m ? Ba && d.setCN(n, Ba, a.bcn + \"grid-minor\") : (a.counter = 0 === ia ? 1 : 0, a.previousCoord = b);\n      0 === this.set.node.childNodes.length && this.set.remove();\n    },\n    graphics: function () {\n      return this.set;\n    },\n    getLabel: function () {\n      return this.label;\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.RecFill = d.Class({\n    construct: function (a, b, c, e) {\n      var h = a.dx,\n          f = a.dy,\n          g = a.orientation,\n          k = 0;\n\n      if (c < b) {\n        var l = b;\n        b = c;\n        c = l;\n      }\n\n      var m = e.fillAlpha;\n      isNaN(m) && (m = 0);\n      var l = a.chart.container,\n          p = e.fillColor;\n      \"V\" == g ? (b = d.fitToBounds(b, 0, a.height), c = d.fitToBounds(c, 0, a.height)) : (b = d.fitToBounds(b, 0, a.width), c = d.fitToBounds(c, 0, a.width));\n      c -= b;\n      isNaN(c) && (c = 4, k = 2, m = 0);\n      0 > c && \"object\" == typeof p && (p = p.join(\",\").split(\",\").reverse());\n      \"V\" == g ? (g = d.rect(l, a.width, c, p, m), g.translate(h, b - k + f)) : (g = d.rect(l, c, a.height, p, m), g.translate(b - k + h, f));\n      d.setCN(a.chart, g, \"guide-fill\");\n      e.id && d.setCN(a.chart, g, \"guide-fill-\" + e.id);\n      this.set = l.set([g]);\n    },\n    graphics: function () {\n      return this.set;\n    },\n    getLabel: function () {}\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmChart = d.Class({\n    construct: function (a) {\n      this.svgIcons = this.tapToActivate = !0;\n      this.theme = a;\n      this.classNamePrefix = \"amcharts\";\n      this.addClassNames = !1;\n      this.version = \"3.21.5\";\n      d.addChart(this);\n      this.createEvents(\"buildStarted\", \"dataUpdated\", \"init\", \"rendered\", \"drawn\", \"failed\", \"resized\", \"animationFinished\");\n      this.height = this.width = \"100%\";\n      this.dataChanged = !0;\n      this.chartCreated = !1;\n      this.previousWidth = this.previousHeight = 0;\n      this.backgroundColor = \"#FFFFFF\";\n      this.borderAlpha = this.backgroundAlpha = 0;\n      this.color = this.borderColor = \"#000000\";\n      this.fontFamily = \"Verdana\";\n      this.fontSize = 11;\n      this.usePrefixes = !1;\n      this.autoResize = !0;\n      this.autoDisplay = !1;\n      this.addCodeCredits = this.accessible = !0;\n      this.touchStartTime = this.touchClickDuration = 0;\n      this.precision = -1;\n      this.percentPrecision = 2;\n      this.decimalSeparator = \".\";\n      this.thousandsSeparator = \",\";\n      this.labels = [];\n      this.allLabels = [];\n      this.titles = [];\n      this.marginRight = this.marginLeft = this.autoMarginOffset = 0;\n      this.timeOuts = [];\n      this.creditsPosition = \"top-left\";\n      var b = document.createElement(\"div\"),\n          c = b.style;\n      c.overflow = \"hidden\";\n      c.position = \"relative\";\n      c.textAlign = \"left\";\n      this.chartDiv = b;\n      b = document.createElement(\"div\");\n      c = b.style;\n      c.overflow = \"hidden\";\n      c.position = \"relative\";\n      c.textAlign = \"left\";\n      this.legendDiv = b;\n      this.titleHeight = 0;\n      this.hideBalloonTime = 150;\n      this.handDrawScatter = 2;\n      this.cssScale = this.handDrawThickness = 1;\n      this.cssAngle = 0;\n      this.prefixesOfBigNumbers = [{\n        number: 1E3,\n        prefix: \"k\"\n      }, {\n        number: 1E6,\n        prefix: \"M\"\n      }, {\n        number: 1E9,\n        prefix: \"G\"\n      }, {\n        number: 1E12,\n        prefix: \"T\"\n      }, {\n        number: 1E15,\n        prefix: \"P\"\n      }, {\n        number: 1E18,\n        prefix: \"E\"\n      }, {\n        number: 1E21,\n        prefix: \"Z\"\n      }, {\n        number: 1E24,\n        prefix: \"Y\"\n      }];\n      this.prefixesOfSmallNumbers = [{\n        number: 1E-24,\n        prefix: \"y\"\n      }, {\n        number: 1E-21,\n        prefix: \"z\"\n      }, {\n        number: 1E-18,\n        prefix: \"a\"\n      }, {\n        number: 1E-15,\n        prefix: \"f\"\n      }, {\n        number: 1E-12,\n        prefix: \"p\"\n      }, {\n        number: 1E-9,\n        prefix: \"n\"\n      }, {\n        number: 1E-6,\n        prefix: \"\\u03bc\"\n      }, {\n        number: .001,\n        prefix: \"m\"\n      }];\n      this.panEventsEnabled = !0;\n      this.product = \"amcharts\";\n      this.animations = [];\n      this.balloon = new d.AmBalloon(this.theme);\n      this.balloon.chart = this;\n      this.processTimeout = 0;\n      this.processCount = 1E3;\n      this.animatable = [];\n      this.langObj = {};\n      d.applyTheme(this, a, \"AmChart\");\n    },\n    drawChart: function () {\n      0 < this.realWidth && 0 < this.realHeight && (this.drawBackground(), this.redrawLabels(), this.drawTitles(), this.brr(), this.renderFix(), this.chartDiv && (this.boundingRect = this.chartDiv.getBoundingClientRect()));\n    },\n    makeAccessible: function (a, b, c) {\n      this.accessible && a && (c && a.setAttr(\"role\", c), a.setAttr(\"aria-label\", b));\n    },\n    drawBackground: function () {\n      d.remove(this.background);\n      var a = this.container,\n          b = this.backgroundColor,\n          c = this.backgroundAlpha,\n          e = this.set;\n      d.isModern || 0 !== c || (c = .001);\n      var h = this.updateWidth();\n      this.realWidth = h;\n      var f = this.updateHeight();\n      this.realHeight = f;\n      b = d.polygon(a, [0, h - 1, h - 1, 0], [0, 0, f - 1, f - 1], b, c, 1, this.borderColor, this.borderAlpha);\n      d.setCN(this, b, \"bg\");\n      this.background = b;\n      e.push(b);\n      if (b = this.backgroundImage) a = a.image(b, 0, 0, h, f), d.setCN(this, b, \"bg-image\"), this.bgImg = a, e.push(a);\n    },\n    drawTitles: function (a) {\n      var b = this.titles;\n      this.titleHeight = 0;\n\n      if (d.ifArray(b)) {\n        var c = 20,\n            e;\n\n        for (e = 0; e < b.length; e++) {\n          var h = b[e],\n              h = d.processObject(h, d.Title, this.theme);\n\n          if (!1 !== h.enabled) {\n            var f = h.color;\n            void 0 === f && (f = this.color);\n            var g = h.size;\n            isNaN(g) && (g = this.fontSize + 2);\n            isNaN(h.alpha);\n            var k = this.marginLeft,\n                l = !0;\n            void 0 !== h.bold && (l = h.bold);\n            f = d.wrappedText(this.container, h.text, f, this.fontFamily, g, \"middle\", l, this.realWidth - 35 - this.marginRight - k);\n            f.translate(k + (this.realWidth - this.marginRight - k) / 2, c);\n            f.node.style.pointerEvents = \"none\";\n            h.sprite = f;\n            void 0 !== h.tabIndex && f.setAttr(\"tabindex\", h.tabIndex);\n            d.setCN(this, f, \"title\");\n            h.id && d.setCN(this, f, \"title-\" + h.id);\n            f.attr({\n              opacity: h.alpha\n            });\n            c += f.getBBox().height + 5;\n            a ? f.remove() : this.freeLabelsSet.push(f);\n          }\n        }\n\n        this.titleHeight = c - 10;\n      }\n    },\n    write: function (a) {\n      var b = this;\n      if (b.listeners) for (var c = 0; c < b.listeners.length; c++) {\n        var e = b.listeners[c];\n        b.addListener(e.event, e.method);\n      }\n      b.fire({\n        type: \"buildStarted\",\n        chart: b\n      });\n      b.afterWriteTO && clearTimeout(b.afterWriteTO);\n      0 < b.processTimeout ? b.afterWriteTO = setTimeout(function () {\n        b.afterWrite.call(b, a);\n      }, b.processTimeout) : b.afterWrite(a);\n    },\n    afterWrite: function (a) {\n      var b;\n\n      if (b = \"object\" != typeof a ? document.getElementById(a) : a) {\n        for (; b.firstChild;) b.removeChild(b.firstChild);\n\n        this.div = b;\n        b.style.overflow = \"hidden\";\n        b.style.textAlign = \"left\";\n        a = this.chartDiv;\n        var c = this.legendDiv,\n            e = this.legend,\n            h = c.style,\n            f = a.style;\n        this.measure();\n        this.previousHeight = this.divRealHeight;\n        this.previousWidth = this.divRealWidth;\n        var g,\n            k = document.createElement(\"div\");\n        g = k.style;\n        g.position = \"relative\";\n        this.containerDiv = k;\n        k.className = this.classNamePrefix + \"-main-div\";\n        a.className = this.classNamePrefix + \"-chart-div\";\n        b.appendChild(k);\n        (b = this.exportConfig) && d.AmExport && !this.AmExport && (this.AmExport = new d.AmExport(this, b));\n        this.amExport && d.AmExport && (this.AmExport = d.extend(this.amExport, new d.AmExport(this), !0));\n        this.AmExport && this.AmExport.init && this.AmExport.init();\n\n        if (e) {\n          e = this.addLegend(e, e.divId);\n          if (e.enabled) switch (h.left = null, h.top = null, h.right = null, f.left = null, f.right = null, f.top = null, h.position = \"relative\", f.position = \"relative\", g.width = \"100%\", g.height = \"100%\", e.position) {\n            case \"bottom\":\n              k.appendChild(a);\n              k.appendChild(c);\n              break;\n\n            case \"top\":\n              k.appendChild(c);\n              k.appendChild(a);\n              break;\n\n            case \"absolute\":\n              h.position = \"absolute\";\n              f.position = \"absolute\";\n              void 0 !== e.left && (h.left = e.left + \"px\");\n              void 0 !== e.right && (h.right = e.right + \"px\");\n              void 0 !== e.top && (h.top = e.top + \"px\");\n              void 0 !== e.bottom && (h.bottom = e.bottom + \"px\");\n              e.marginLeft = 0;\n              e.marginRight = 0;\n              k.appendChild(a);\n              k.appendChild(c);\n              break;\n\n            case \"right\":\n              h.position = \"relative\";\n              f.position = \"absolute\";\n              k.appendChild(a);\n              k.appendChild(c);\n              break;\n\n            case \"left\":\n              h.position = \"absolute\";\n              f.position = \"relative\";\n              k.appendChild(a);\n              k.appendChild(c);\n              break;\n\n            case \"outside\":\n              k.appendChild(a);\n          } else k.appendChild(a);\n          this.prevLegendPosition = e.position;\n        } else k.appendChild(a);\n\n        this.listenersAdded || (this.addListeners(), this.listenersAdded = !0);\n        (this.mouseWheelScrollEnabled || this.mouseWheelZoomEnabled) && d.addWheelListeners();\n        this.initChart();\n      }\n    },\n    createLabelsSet: function () {\n      d.remove(this.labelsSet);\n      this.labelsSet = this.container.set();\n      this.freeLabelsSet.push(this.labelsSet);\n    },\n    initChart: function () {\n      this.balloon = d.processObject(this.balloon, d.AmBalloon, this.theme);\n      window.AmCharts_path && (this.path = window.AmCharts_path);\n      void 0 === this.path && (this.path = d.getPath());\n      void 0 === this.path && (this.path = \"amcharts/\");\n      this.path = d.normalizeUrl(this.path);\n      void 0 === this.pathToImages && (this.pathToImages = this.path + \"images/\");\n      this.initHC || (d.callInitHandler(this), this.initHC = !0);\n      d.applyLang(this.language, this);\n      var a = this.numberFormatter;\n      a && (isNaN(a.precision) || (this.precision = a.precision), void 0 !== a.thousandsSeparator && (this.thousandsSeparator = a.thousandsSeparator), void 0 !== a.decimalSeparator && (this.decimalSeparator = a.decimalSeparator));\n      (a = this.percentFormatter) && !isNaN(a.precision) && (this.percentPrecision = a.precision);\n      this.nf = {\n        precision: this.precision,\n        thousandsSeparator: this.thousandsSeparator,\n        decimalSeparator: this.decimalSeparator\n      };\n      this.pf = {\n        precision: this.percentPrecision,\n        thousandsSeparator: this.thousandsSeparator,\n        decimalSeparator: this.decimalSeparator\n      };\n      this.destroy();\n      (a = this.container) ? (a.container.innerHTML = \"\", a.width = this.realWidth, a.height = this.realHeight, a.addDefs(this), this.chartDiv.appendChild(a.container)) : a = new d.AmDraw(this.chartDiv, this.realWidth, this.realHeight, this);\n      this.container = a;\n      this.extension = \".png\";\n      this.svgIcons && d.SVG && (this.extension = \".svg\");\n      this.checkDisplay();\n      this.checkTransform(this.div);\n      a.chart = this;\n      d.VML || d.SVG ? (a.handDrawn = this.handDrawn, a.handDrawScatter = this.handDrawScatter, a.handDrawThickness = this.handDrawThickness, d.remove(this.set), this.set = a.set(), d.remove(this.gridSet), this.gridSet = a.set(), d.remove(this.cursorLineSet), this.cursorLineSet = a.set(), d.remove(this.graphsBehindSet), this.graphsBehindSet = a.set(), d.remove(this.bulletBehindSet), this.bulletBehindSet = a.set(), d.remove(this.columnSet), this.columnSet = a.set(), d.remove(this.graphsSet), this.graphsSet = a.set(), d.remove(this.trendLinesSet), this.trendLinesSet = a.set(), d.remove(this.axesSet), this.axesSet = a.set(), d.remove(this.cursorSet), this.cursorSet = a.set(), d.remove(this.scrollbarsSet), this.scrollbarsSet = a.set(), d.remove(this.bulletSet), this.bulletSet = a.set(), d.remove(this.freeLabelsSet), this.freeLabelsSet = a.set(), d.remove(this.axesLabelsSet), this.axesLabelsSet = a.set(), d.remove(this.balloonsSet), this.balloonsSet = a.set(), d.remove(this.plotBalloonsSet), this.plotBalloonsSet = a.set(), d.remove(this.zoomButtonSet), this.zoomButtonSet = a.set(), d.remove(this.zbSet), this.zbSet = null, d.remove(this.linkSet), this.linkSet = a.set()) : this.fire({\n        type: \"failed\",\n        chart: this\n      });\n    },\n    premeasure: function () {\n      var a = this.div;\n\n      if (a) {\n        try {\n          this.boundingRect = this.chartDiv.getBoundingClientRect();\n        } catch (e) {}\n\n        var b = a.offsetWidth,\n            c = a.offsetHeight;\n        a.clientHeight && (b = a.clientWidth, c = a.clientHeight);\n        if (b != this.mw || c != this.mh) this.mw = b, this.mh = c, this.measure();\n      }\n    },\n    measure: function () {\n      var a = this.div;\n\n      if (a) {\n        var b = this.chartDiv,\n            c = a.offsetWidth,\n            e = a.offsetHeight,\n            h = this.container;\n        a.clientHeight && (c = a.clientWidth, e = a.clientHeight);\n        var e = Math.round(e),\n            c = Math.round(c),\n            a = Math.round(d.toCoordinate(this.width, c)),\n            f = Math.round(d.toCoordinate(this.height, e));\n        (c != this.previousWidth || e != this.previousHeight) && 0 < a && 0 < f && (b.style.width = a + \"px\", b.style.height = f + \"px\", b.style.padding = 0, h && h.setSize(a, f), this.balloon = d.processObject(this.balloon, d.AmBalloon, this.theme));\n        this.balloon && this.balloon.setBounds && this.balloon.setBounds(2, 2, a - 2, f);\n        this.updateWidth();\n        this.balloon.chart = this;\n        this.realWidth = a;\n        this.realHeight = f;\n        this.divRealWidth = c;\n        this.divRealHeight = e;\n      }\n    },\n    checkDisplay: function () {\n      if (this.autoDisplay && this.container) {\n        var a = d.rect(this.container, 10, 10),\n            b = a.getBBox();\n        0 === b.width && 0 === b.height && (this.divRealHeight = this.divRealWidth = this.realHeight = this.realWidth = 0, this.previousWidth = this.previousHeight = NaN);\n        a.remove();\n      }\n    },\n    checkTransform: function (a) {\n      if (this.autoTransform && window.getComputedStyle && a) {\n        if (a.style) {\n          var b = window.getComputedStyle(a, null);\n\n          if (b && (b = b.getPropertyValue(\"-webkit-transform\") || b.getPropertyValue(\"-moz-transform\") || b.getPropertyValue(\"-ms-transform\") || b.getPropertyValue(\"-o-transform\") || b.getPropertyValue(\"transform\")) && \"none\" !== b) {\n            var c = b.split(\"(\")[1].split(\")\")[0].split(\",\"),\n                b = c[0],\n                c = c[1],\n                b = Math.sqrt(b * b + c * c);\n            isNaN(b) || (this.cssScale *= b);\n          }\n        }\n\n        a.parentNode && this.checkTransform(a.parentNode);\n      }\n    },\n    destroy: function () {\n      this.chartDiv.innerHTML = \"\";\n      this.clearTimeOuts();\n      this.legend && this.legend.destroy();\n    },\n    clearTimeOuts: function () {\n      var a = this.timeOuts;\n\n      if (a) {\n        var b;\n\n        for (b = 0; b < a.length; b++) clearTimeout(a[b]);\n      }\n\n      this.timeOuts = [];\n    },\n    clear: function (a) {\n      try {\n        document.removeEventListener(\"touchstart\", this.docfn1, !0), document.removeEventListener(\"touchend\", this.docfn2, !0);\n      } catch (b) {}\n\n      d.callMethod(\"clear\", [this.chartScrollbar, this.scrollbarV, this.scrollbarH, this.chartCursor]);\n      this.chartCursor = this.scrollbarH = this.scrollbarV = this.chartScrollbar = null;\n      this.clearTimeOuts();\n      this.container && (this.container.remove(this.chartDiv), this.container.remove(this.legendDiv));\n      a || d.removeChart(this);\n      if (a = this.div) for (; a.firstChild;) a.removeChild(a.firstChild);\n      this.legend && this.legend.destroy();\n      this.AmExport && this.AmExport.clear && this.AmExport.clear();\n    },\n    setMouseCursor: function (a) {\n      \"auto\" == a && d.isNN && (a = \"default\");\n      this.chartDiv.style.cursor = a;\n      this.legendDiv.style.cursor = a;\n    },\n    redrawLabels: function () {\n      this.labels = [];\n      var a = this.allLabels;\n      this.createLabelsSet();\n      var b;\n\n      for (b = 0; b < a.length; b++) this.drawLabel(a[b]);\n    },\n    drawLabel: function (a) {\n      var b = this;\n\n      if (b.container && !1 !== a.enabled) {\n        a = d.processObject(a, d.Label, b.theme);\n        var c = a.y,\n            e = a.text,\n            h = a.align,\n            f = a.size,\n            g = a.color,\n            k = a.rotation,\n            l = a.alpha,\n            m = a.bold,\n            p = d.toCoordinate(a.x, b.realWidth),\n            c = d.toCoordinate(c, b.realHeight);\n        p || (p = 0);\n        c || (c = 0);\n        void 0 === g && (g = b.color);\n        isNaN(f) && (f = b.fontSize);\n        h || (h = \"start\");\n        \"left\" == h && (h = \"start\");\n        \"right\" == h && (h = \"end\");\n        \"center\" == h && (h = \"middle\", k ? c = b.realHeight - c + c / 2 : p = b.realWidth / 2 - p);\n        void 0 === l && (l = 1);\n        void 0 === k && (k = 0);\n        c += f / 2;\n        e = d.text(b.container, e, g, b.fontFamily, f, h, m, l);\n        e.translate(p, c);\n        void 0 !== a.tabIndex && e.setAttr(\"tabindex\", a.tabIndex);\n        d.setCN(b, e, \"label\");\n        a.id && d.setCN(b, e, \"label-\" + a.id);\n        0 !== k && e.rotate(k);\n        a.url ? (e.setAttr(\"cursor\", \"pointer\"), e.click(function () {\n          d.getURL(a.url, b.urlTarget);\n        })) : e.node.style.pointerEvents = \"none\";\n        b.labelsSet.push(e);\n        b.labels.push(e);\n      }\n    },\n    addLabel: function (a, b, c, e, d, f, g, k, l, m) {\n      a = {\n        x: a,\n        y: b,\n        text: c,\n        align: e,\n        size: d,\n        color: f,\n        alpha: k,\n        rotation: g,\n        bold: l,\n        url: m,\n        enabled: !0\n      };\n      this.container && this.drawLabel(a);\n      this.allLabels.push(a);\n    },\n    clearLabels: function () {\n      var a = this.labels,\n          b;\n\n      for (b = a.length - 1; 0 <= b; b--) a[b].remove();\n\n      this.labels = [];\n      this.allLabels = [];\n    },\n    updateHeight: function () {\n      var a = this.divRealHeight,\n          b = this.legend;\n\n      if (b) {\n        var c = this.legendDiv.offsetHeight,\n            b = b.position;\n\n        if (\"top\" == b || \"bottom\" == b) {\n          a -= c;\n          if (0 > a || isNaN(a)) a = 0;\n          this.chartDiv.style.height = a + \"px\";\n        }\n      }\n\n      return a;\n    },\n    updateWidth: function () {\n      var a = this.divRealWidth,\n          b = this.divRealHeight,\n          c = this.legend;\n\n      if (c) {\n        var e = this.legendDiv,\n            d = e.offsetWidth;\n        isNaN(c.width) || (d = c.width);\n        c.ieW && (d = c.ieW);\n        var f = e.offsetHeight,\n            e = e.style,\n            g = this.chartDiv.style,\n            k = c.position;\n\n        if ((\"right\" == k || \"left\" == k) && void 0 === c.divId) {\n          a -= d;\n          if (0 > a || isNaN(a)) a = 0;\n          g.width = a + \"px\";\n          this.balloon && this.balloon.setBounds && this.balloon.setBounds(2, 2, a - 2, this.realHeight);\n          \"left\" == k ? (g.left = d + \"px\", e.left = \"0px\") : (g.left = \"0px\", e.left = a + \"px\");\n          b > f && (e.top = (b - f) / 2 + \"px\");\n        }\n      }\n\n      return a;\n    },\n    getTitleHeight: function () {\n      this.drawTitles(!0);\n      return this.titleHeight;\n    },\n    addTitle: function (a, b, c, e, d) {\n      isNaN(b) && (b = this.fontSize + 2);\n      a = {\n        text: a,\n        size: b,\n        color: c,\n        alpha: e,\n        bold: d,\n        enabled: !0\n      };\n      this.titles.push(a);\n      return a;\n    },\n    handleWheel: function (a) {\n      var b = 0;\n      a || (a = window.event);\n      a.wheelDelta ? b = a.wheelDelta / 120 : a.detail && (b = -a.detail / 3);\n      b && this.handleWheelReal(b, a.shiftKey);\n      a.preventDefault && a.preventDefault();\n    },\n    handleWheelReal: function () {},\n    handleDocTouchStart: function () {\n      this.handleMouseMove();\n      this.tmx = this.mouseX;\n      this.tmy = this.mouseY;\n      this.touchStartTime = new Date().getTime();\n    },\n    handleDocTouchEnd: function () {\n      -.5 < this.tmx && this.tmx < this.divRealWidth + 1 && 0 < this.tmy && this.tmy < this.divRealHeight ? (this.handleMouseMove(), 4 > Math.abs(this.mouseX - this.tmx) && 4 > Math.abs(this.mouseY - this.tmy) ? (this.tapped = !0, this.panRequired && this.panEventsEnabled && this.chartDiv && (this.chartDiv.style.msTouchAction = \"none\", this.chartDiv.style.touchAction = \"none\")) : this.mouseIsOver || this.resetTouchStyle()) : (this.tapped = !1, this.resetTouchStyle());\n    },\n    resetTouchStyle: function () {\n      this.panEventsEnabled && this.chartDiv && (this.chartDiv.style.msTouchAction = \"auto\", this.chartDiv.style.touchAction = \"auto\");\n    },\n    checkTouchDuration: function (a) {\n      var b = this,\n          c = new Date().getTime();\n      if (a) if (a.touches) b.isTouchEvent = !0;else if (!b.isTouchEvent) return !0;\n      if (c - b.touchStartTime > b.touchClickDuration) return !0;\n      setTimeout(function () {\n        b.resetTouchDuration();\n      }, 300);\n    },\n    resetTouchDuration: function () {\n      this.isTouchEvent = !1;\n    },\n    checkTouchMoved: function () {\n      if (4 < Math.abs(this.mouseX - this.tmx) || 4 < Math.abs(this.mouseY - this.tmy)) return !0;\n    },\n    addListeners: function () {\n      var a = this,\n          b = a.chartDiv;\n      document.addEventListener ? (\"ontouchstart\" in document.documentElement && (b.addEventListener(\"touchstart\", function (b) {\n        a.handleTouchStart.call(a, b);\n      }, !0), b.addEventListener(\"touchmove\", function (b) {\n        a.handleMouseMove.call(a, b);\n      }, !0), b.addEventListener(\"touchend\", function (b) {\n        a.handleTouchEnd.call(a, b);\n      }, !0), a.docfn1 = function (b) {\n        a.handleDocTouchStart.call(a, b);\n      }, a.docfn2 = function (b) {\n        a.handleDocTouchEnd.call(a, b);\n      }, document.addEventListener(\"touchstart\", a.docfn1, !0), document.addEventListener(\"touchend\", a.docfn2, !0)), b.addEventListener(\"mousedown\", function (b) {\n        a.mouseIsOver = !0;\n        a.handleMouseMove.call(a, b);\n        a.handleMouseDown.call(a, b);\n        a.handleDocTouchStart.call(a, b);\n      }, !0), b.addEventListener(\"mouseover\", function (b) {\n        a.handleMouseOver.call(a, b);\n      }, !0), b.addEventListener(\"mouseout\", function (b) {\n        a.handleMouseOut.call(a, b);\n      }, !0), b.addEventListener(\"mouseup\", function (b) {\n        a.handleDocTouchEnd.call(a, b);\n      }, !0)) : (b.attachEvent(\"onmousedown\", function (b) {\n        a.handleMouseDown.call(a, b);\n      }), b.attachEvent(\"onmouseover\", function (b) {\n        a.handleMouseOver.call(a, b);\n      }), b.attachEvent(\"onmouseout\", function (b) {\n        a.handleMouseOut.call(a, b);\n      }));\n    },\n    dispDUpd: function () {\n      this.skipEvents || (this.dispatchDataUpdated && (this.dispatchDataUpdated = !1, this.fire({\n        type: \"dataUpdated\",\n        chart: this\n      })), this.chartCreated || (this.chartCreated = !0, this.fire({\n        type: \"init\",\n        chart: this\n      })), this.chartRendered || (this.fire({\n        type: \"rendered\",\n        chart: this\n      }), this.chartRendered = !0), this.fire({\n        type: \"drawn\",\n        chart: this\n      }));\n      this.skipEvents = !1;\n    },\n    validateSize: function () {\n      var a = this;\n      a.premeasure();\n      a.checkDisplay();\n      a.cssScale = 1;\n      a.cssAngle = 0;\n      a.checkTransform(a.div);\n\n      if (a.divRealWidth != a.previousWidth || a.divRealHeight != a.previousHeight) {\n        var b = a.legend;\n\n        if (0 < a.realWidth && 0 < a.realHeight) {\n          a.sizeChanged = !0;\n\n          if (b) {\n            a.legendInitTO && clearTimeout(a.legendInitTO);\n            var c = setTimeout(function () {\n              b.invalidateSize();\n            }, 10);\n            a.timeOuts.push(c);\n            a.legendInitTO = c;\n          }\n\n          a.marginsUpdated = !1;\n          clearTimeout(a.initTO);\n          c = setTimeout(function () {\n            a.initChart();\n          }, 10);\n          a.timeOuts.push(c);\n          a.initTO = c;\n        }\n\n        a.renderFix();\n        b && b.renderFix && b.renderFix();\n        clearTimeout(a.resizedTO);\n        a.resizedTO = setTimeout(function () {\n          a.fire({\n            type: \"resized\",\n            chart: a\n          });\n        }, 10);\n        a.previousHeight = a.divRealHeight;\n        a.previousWidth = a.divRealWidth;\n      }\n    },\n    invalidateSize: function () {\n      this.previousHeight = this.previousWidth = NaN;\n      this.invalidateSizeReal();\n    },\n    invalidateSizeReal: function () {\n      var a = this;\n      a.marginsUpdated = !1;\n      clearTimeout(a.validateTO);\n      var b = setTimeout(function () {\n        a.validateSize();\n      }, 5);\n      a.timeOuts.push(b);\n      a.validateTO = b;\n    },\n    validateData: function (a) {\n      this.chartCreated && (this.dataChanged = !0, this.marginsUpdated = !1, this.initChart(a));\n    },\n    validateNow: function (a, b) {\n      this.initTO && clearTimeout(this.initTO);\n      a && (this.dataChanged = !0, this.marginsUpdated = !1);\n      this.skipEvents = b;\n      this.chartRendered = !1;\n      var c = this.legend;\n      c && c.position != this.prevLegendPosition && (this.previousWidth = this.mw = 0, c.invalidateSize && (c.invalidateSize(), this.validateSize()));\n      this.write(this.div);\n    },\n    showItem: function (a) {\n      a.hidden = !1;\n      this.initChart();\n    },\n    hideItem: function (a) {\n      a.hidden = !0;\n      this.initChart();\n    },\n    hideBalloon: function () {\n      var a = this;\n      clearTimeout(a.hoverInt);\n      clearTimeout(a.balloonTO);\n      a.hoverInt = setTimeout(function () {\n        a.hideBalloonReal.call(a);\n      }, a.hideBalloonTime);\n    },\n    cleanChart: function () {},\n    hideBalloonReal: function () {\n      var a = this.balloon;\n      a && a.hide && a.hide();\n    },\n    showBalloon: function (a, b, c, e, d) {\n      var f = this;\n      clearTimeout(f.balloonTO);\n      clearTimeout(f.hoverInt);\n      f.balloonTO = setTimeout(function () {\n        f.showBalloonReal.call(f, a, b, c, e, d);\n      }, 1);\n    },\n    showBalloonReal: function (a, b, c, e, d) {\n      this.handleMouseMove();\n      var f = this.balloon;\n      f.enabled && (f.followCursor(!1), f.changeColor(b), !c || f.fixedPosition ? (f.setPosition(e, d), isNaN(e) || isNaN(d) ? f.followCursor(!0) : f.followCursor(!1)) : f.followCursor(!0), a && f.showBalloon(a));\n    },\n    handleMouseOver: function () {\n      this.outTO && clearTimeout(this.outTO);\n      d.resetMouseOver();\n      this.mouseIsOver = !0;\n    },\n    handleMouseOut: function () {\n      var a = this;\n      d.resetMouseOver();\n      a.outTO && clearTimeout(a.outTO);\n      a.outTO = setTimeout(function () {\n        a.handleMouseOutReal();\n      }, 10);\n    },\n    handleMouseOutReal: function () {\n      this.mouseIsOver = !1;\n    },\n    handleMouseMove: function (a) {\n      a || (a = window.event);\n      this.mouse2Y = this.mouse2X = NaN;\n      var b, c, e, d;\n\n      if (a) {\n        if (a.touches) {\n          var f = a.touches.item(1);\n          f && this.panEventsEnabled && this.boundingRect && (e = f.clientX - this.boundingRect.left, d = f.clientY - this.boundingRect.top);\n          a = a.touches.item(0);\n          if (!a) return;\n        } else this.wasTouched = !1;\n\n        this.boundingRect && a.clientX && (b = a.clientX - this.boundingRect.left, c = a.clientY - this.boundingRect.top);\n        isNaN(e) ? this.mouseX = b : (this.mouseX = Math.min(b, e), this.mouse2X = Math.max(b, e));\n        isNaN(d) ? this.mouseY = c : (this.mouseY = Math.min(c, d), this.mouse2Y = Math.max(c, d));\n        this.autoTransform && (this.mouseX /= this.cssScale, this.mouseY /= this.cssScale);\n      }\n    },\n    handleTouchStart: function (a) {\n      this.hideBalloonReal();\n      a && (a.touches && this.tapToActivate && !this.tapped || !this.panRequired) || (this.handleMouseMove(a), this.handleMouseDown(a));\n    },\n    handleTouchEnd: function (a) {\n      this.wasTouched = !0;\n      this.handleMouseMove(a);\n      d.resetMouseOver();\n      this.handleReleaseOutside(a);\n    },\n    handleReleaseOutside: function () {\n      this.handleDocTouchEnd.call(this);\n    },\n    handleMouseDown: function (a) {\n      d.resetMouseOver();\n      this.mouseIsOver = !0;\n      a && a.preventDefault && (this.panEventsEnabled ? a.preventDefault() : a.touches || a.preventDefault());\n    },\n    addLegend: function (a, b) {\n      a = d.processObject(a, d.AmLegend, this.theme);\n      a.divId = b;\n      a.ieW = 0;\n      var c;\n      c = \"object\" != typeof b && b ? document.getElementById(b) : b;\n      this.legend = a;\n      a.chart = this;\n      c ? (a.div = c, a.position = \"outside\", a.autoMargins = !1) : a.div = this.legendDiv;\n      return a;\n    },\n    removeLegend: function () {\n      this.legend = void 0;\n      this.previousWidth = 0;\n      this.legendDiv.innerHTML = \"\";\n    },\n    handleResize: function () {\n      (d.isPercents(this.width) || d.isPercents(this.height)) && this.invalidateSizeReal();\n      this.renderFix();\n    },\n    renderFix: function () {\n      if (!d.VML) {\n        var a = this.container;\n        a && a.renderFix();\n      }\n    },\n    getSVG: function () {\n      if (d.hasSVG) return this.container;\n    },\n    animate: function (a, b, c, e, h, f, g) {\n      a[\"an_\" + b] && d.removeFromArray(this.animations, a[\"an_\" + b]);\n      c = {\n        obj: a,\n        frame: 0,\n        attribute: b,\n        from: c,\n        to: e,\n        time: h,\n        effect: f,\n        suffix: g\n      };\n      a[\"an_\" + b] = c;\n      this.animations.push(c);\n      return c;\n    },\n    setLegendData: function (a) {\n      var b = this.legend;\n      b && b.setData(a);\n    },\n    stopAnim: function (a) {\n      d.removeFromArray(this.animations, a);\n    },\n    updateAnimations: function () {\n      var a;\n      this.container && this.container.update();\n      if (this.animations) for (a = this.animations.length - 1; 0 <= a; a--) {\n        var b = this.animations[a],\n            c = d.updateRate * b.time,\n            e = b.frame + 1,\n            h = b.obj,\n            f = b.attribute;\n\n        if (e <= c) {\n          b.frame++;\n          var g = Number(b.from),\n              k = Number(b.to) - g,\n              c = d[b.effect](0, e, g, k, c);\n          0 === k ? (this.animations.splice(a, 1), h.node.style[f] = Number(b.to) + b.suffix) : h.node.style[f] = c + b.suffix;\n        } else h.node.style[f] = Number(b.to) + b.suffix, h.animationFinished = !0, this.animations.splice(a, 1);\n      }\n    },\n    update: function () {\n      this.updateAnimations();\n      var a = this.animatable;\n\n      if (0 < a.length) {\n        for (var b = !0, c = a.length - 1; 0 <= c; c--) {\n          var e = a[c];\n          e && (e.animationFinished ? a.splice(c, 1) : b = !1);\n        }\n\n        b && (this.fire({\n          type: \"animationFinished\",\n          chart: this\n        }), this.animatable = []);\n      }\n    },\n    inIframe: function () {\n      try {\n        return window.self !== window.top;\n      } catch (a) {\n        return !0;\n      }\n    },\n    brr: function () {\n      if (!this.hideCredits) {\n        var a = \"amcharts.com\",\n            b = window.location.hostname.split(\".\"),\n            c;\n        2 <= b.length && (c = b[b.length - 2] + \".\" + b[b.length - 1]);\n        this.amLink && (b = this.amLink.parentNode) && b.removeChild(this.amLink);\n        b = this.creditsPosition;\n\n        if (c != a || !0 === this.inIframe()) {\n          var a = \"http://www.\" + a,\n              e = c = 0,\n              d = this.realWidth,\n              f = this.realHeight,\n              g = this.type;\n          if (\"serial\" == g || \"xy\" == g || \"gantt\" == g) c = this.marginLeftReal, e = this.marginTopReal, d = c + this.plotAreaWidth, f = e + this.plotAreaHeight;\n          var g = a + \"/javascript-charts/\",\n              k = \"JavaScript charts\",\n              l = \"JS chart by amCharts\";\n          \"ammap\" == this.product && (g = a + \"/javascript-maps/\", k = \"Interactive JavaScript maps\", l = \"JS map by amCharts\");\n          a = document.createElement(\"a\");\n          l = document.createTextNode(l);\n          a.setAttribute(\"href\", g);\n          a.setAttribute(\"title\", k);\n          this.urlTarget && a.setAttribute(\"target\", this.urlTarget);\n          a.appendChild(l);\n          this.chartDiv.appendChild(a);\n          this.amLink = a;\n          g = a.style;\n          g.position = \"absolute\";\n          g.textDecoration = \"none\";\n          g.color = this.color;\n          g.fontFamily = this.fontFamily;\n          g.fontSize = \"11px\";\n          g.opacity = .7;\n          g.display = \"block\";\n          var k = a.offsetWidth,\n              a = a.offsetHeight,\n              l = 5 + c,\n              m = e + 5;\n          \"bottom-left\" == b && (l = 5 + c, m = f - a - 3);\n          \"bottom-right\" == b && (l = d - k - 5, m = f - a - 3);\n          \"top-right\" == b && (l = d - k - 5, m = e + 5);\n          g.left = l + \"px\";\n          g.top = m + \"px\";\n        }\n      }\n    }\n  });\n  d.Slice = d.Class({\n    construct: function () {}\n  });\n  d.SerialDataItem = d.Class({\n    construct: function () {}\n  });\n  d.GraphDataItem = d.Class({\n    construct: function () {}\n  });\n  d.Guide = d.Class({\n    construct: function (a) {\n      this.cname = \"Guide\";\n      d.applyTheme(this, a, this.cname);\n    }\n  });\n  d.Title = d.Class({\n    construct: function (a) {\n      this.cname = \"Title\";\n      d.applyTheme(this, a, this.cname);\n    }\n  });\n  d.Label = d.Class({\n    construct: function (a) {\n      this.cname = \"Label\";\n      d.applyTheme(this, a, this.cname);\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmGraph = d.Class({\n    construct: function (a) {\n      this.cname = \"AmGraph\";\n      this.createEvents(\"rollOverGraphItem\", \"rollOutGraphItem\", \"clickGraphItem\", \"doubleClickGraphItem\", \"rightClickGraphItem\", \"clickGraph\", \"rollOverGraph\", \"rollOutGraph\");\n      this.type = \"line\";\n      this.stackable = !0;\n      this.columnCount = 1;\n      this.columnIndex = 0;\n      this.centerCustomBullets = this.showBalloon = !0;\n      this.maxBulletSize = 50;\n      this.minBulletSize = 4;\n      this.balloonText = \"[[value]]\";\n      this.hidden = this.scrollbar = this.animationPlayed = !1;\n      this.pointPosition = \"middle\";\n      this.depthCount = 1;\n      this.includeInMinMax = !0;\n      this.negativeBase = 0;\n      this.visibleInLegend = !0;\n      this.showAllValueLabels = !1;\n      this.showBulletsAt = this.showBalloonAt = \"close\";\n      this.lineThickness = 1;\n      this.dashLength = 0;\n      this.connect = !0;\n      this.lineAlpha = 1;\n      this.bullet = \"none\";\n      this.bulletBorderThickness = 2;\n      this.bulletBorderAlpha = 0;\n      this.bulletAlpha = 1;\n      this.bulletSize = 8;\n      this.cornerRadiusTop = this.hideBulletsCount = this.bulletOffset = 0;\n      this.cursorBulletAlpha = 1;\n      this.gradientOrientation = \"vertical\";\n      this.dy = this.dx = 0;\n      this.periodValue = \"\";\n      this.clustered = !0;\n      this.periodSpan = 1;\n      this.accessibleLabel = \"[[title]] [[category]] [[value]]\";\n      this.accessibleSkipText = \"Press enter to skip [[title]]\";\n      this.y = this.x = 0;\n      this.switchable = !0;\n      this.tcc = this.minDistance = 1;\n      this.labelRotation = 0;\n      this.labelAnchor = \"auto\";\n      this.labelOffset = 3;\n      this.bcn = \"graph-\";\n      this.dateFormat = \"MMM DD, YYYY\";\n      this.noRounding = !0;\n      d.applyTheme(this, a, this.cname);\n    },\n    init: function () {\n      this.createBalloon();\n    },\n    draw: function () {\n      var a = this.chart;\n      a.isRolledOverBullet = !1;\n      var b = a.type;\n\n      if (a.drawGraphs) {\n        isNaN(this.precision) || (this.numberFormatter ? this.numberFormatter.precision = this.precision : this.numberFormatter = {\n          precision: this.precision,\n          decimalSeparator: a.decimalSeparator,\n          thousandsSeparator: a.thousandsSeparator\n        });\n        var c = a.container;\n        this.container = c;\n        this.destroy();\n        var e = c.set();\n        this.set = e;\n        e.translate(this.x, this.y);\n        var h = c.set();\n        this.bulletSet = h;\n        h.translate(this.x, this.y);\n        this.behindColumns ? (a.graphsBehindSet.push(e), a.bulletBehindSet.push(h)) : (a.graphsSet.push(e), a.bulletSet.push(h));\n        var f = this.bulletAxis;\n        d.isString(f) && (this.bulletAxis = a.getValueAxisById(f));\n        c = c.set();\n        d.remove(this.columnsSet);\n        this.columnsSet = c;\n        d.setCN(a, e, \"graph-\" + this.type);\n        d.setCN(a, e, \"graph-\" + this.id);\n        d.setCN(a, h, \"graph-\" + this.type);\n        d.setCN(a, h, \"graph-\" + this.id);\n        this.columnsArray = [];\n        this.ownColumns = [];\n        this.allBullets = [];\n        this.animationArray = [];\n        h = this.labelPosition;\n        h || (f = this.valueAxis.stackType, h = \"top\", \"column\" == this.type && (a.rotate && (h = \"right\"), \"100%\" == f || \"regular\" == f) && (h = \"middle\"), this.labelPosition = h);\n        d.ifArray(this.data) && (a = !1, \"xy\" == b ? this.xAxis.axisCreated && this.yAxis.axisCreated && (a = !0) : this.valueAxis.axisCreated && (a = !0), !this.hidden && a && this.createGraph());\n        e.push(c);\n      }\n    },\n    createGraph: function () {\n      var a = this,\n          b = a.chart;\n      a.startAlpha = b.startAlpha;\n      a.seqAn = b.sequencedAnimation;\n      a.baseCoord = a.valueAxis.baseCoord;\n      void 0 === a.fillAlphas && (a.fillAlphas = 0);\n      a.bulletColorR = a.bulletColor;\n      void 0 === a.bulletColorR && (a.bulletColorR = a.lineColorR, a.bulletColorNegative = a.negativeLineColor);\n      void 0 === a.bulletAlpha && (a.bulletAlpha = a.lineAlpha);\n      if (\"step\" == c || d.VML) a.noRounding = !1;\n      var c = b.type;\n      \"gantt\" == c && (c = \"serial\");\n      clearTimeout(a.playedTO);\n\n      if (!isNaN(a.valueAxis.min) && !isNaN(a.valueAxis.max)) {\n        switch (c) {\n          case \"serial\":\n            a.categoryAxis && (a.createSerialGraph(), \"candlestick\" == a.type && 1 > a.valueAxis.minMaxMultiplier && a.positiveClip(a.set));\n            break;\n\n          case \"radar\":\n            a.createRadarGraph();\n            break;\n\n          case \"xy\":\n            a.createXYGraph();\n        }\n\n        a.playedTO = setTimeout(function () {\n          a.setAnimationPlayed.call(a);\n        }, 500 * a.chart.startDuration);\n      }\n    },\n    setAnimationPlayed: function () {\n      this.animationPlayed = !0;\n    },\n    createXYGraph: function () {\n      var a = [],\n          b = [],\n          c = this.xAxis,\n          e = this.yAxis;\n      this.pmh = e.height;\n      this.pmw = c.width;\n      this.pmy = this.pmx = 0;\n      var d;\n\n      for (d = this.start; d <= this.end; d++) {\n        var f = this.data[d].axes[c.id].graphs[this.id],\n            g = f.values,\n            k = g.x,\n            l = g.y,\n            g = c.getCoordinate(k, this.noRounding),\n            m = e.getCoordinate(l, this.noRounding);\n\n        if (!isNaN(k) && !isNaN(l) && (a.push(g), b.push(m), f.x = g, f.y = m, k = this.createBullet(f, g, m, d), l = this.labelText)) {\n          var l = this.createLabel(f, l),\n              p = 0;\n          k && (p = k.size);\n          this.positionLabel(f, g, m, l, p);\n        }\n      }\n\n      this.drawLineGraph(a, b);\n      this.launchAnimation();\n    },\n    createRadarGraph: function () {\n      var a = this.valueAxis.stackType,\n          b = [],\n          c = [],\n          e = [],\n          d = [],\n          f,\n          g,\n          k,\n          l,\n          m;\n\n      for (m = this.start; m <= this.end; m++) {\n        var p = this.data[m].axes[this.valueAxis.id].graphs[this.id],\n            q,\n            n;\n        \"none\" == a || \"3d\" == a ? q = p.values.value : (q = p.values.close, n = p.values.open);\n        if (isNaN(q)) this.connect || (this.drawLineGraph(b, c, e, d), b = [], c = [], e = [], d = []);else {\n          var t = this.valueAxis.getCoordinate(q, this.noRounding) - this.height,\n              t = t * this.valueAxis.rMultiplier,\n              r = -360 / (this.end - this.start + 1) * m;\n          \"middle\" == this.valueAxis.pointPosition && (r -= 180 / (this.end - this.start + 1));\n          q = t * Math.sin(r / 180 * Math.PI);\n          t *= Math.cos(r / 180 * Math.PI);\n          b.push(q);\n          c.push(t);\n\n          if (!isNaN(n)) {\n            var w = this.valueAxis.getCoordinate(n, this.noRounding) - this.height,\n                w = w * this.valueAxis.rMultiplier,\n                z = w * Math.sin(r / 180 * Math.PI),\n                r = w * Math.cos(r / 180 * Math.PI);\n            e.push(z);\n            d.push(r);\n            isNaN(k) && (k = z);\n            isNaN(l) && (l = r);\n          }\n\n          r = this.createBullet(p, q, t, m);\n          p.x = q;\n          p.y = t;\n          if (z = this.labelText) z = this.createLabel(p, z), w = 0, r && (w = r.size), this.positionLabel(p, q, t, z, w);\n          isNaN(f) && (f = q);\n          isNaN(g) && (g = t);\n        }\n      }\n\n      b.push(f);\n      c.push(g);\n      isNaN(k) || (e.push(k), d.push(l));\n      this.drawLineGraph(b, c, e, d);\n      this.launchAnimation();\n    },\n    positionLabel: function (a, b, c, e, d) {\n      if (e) {\n        var f = this.chart,\n            g = this.valueAxis,\n            k = \"middle\",\n            l = !1,\n            m = this.labelPosition,\n            p = e.getBBox(),\n            q = this.chart.rotate,\n            n = a.isNegative,\n            t = this.fontSize;\n        void 0 === t && (t = this.chart.fontSize);\n        c -= p.height / 2 - t / 2 - 1;\n        void 0 !== a.labelIsNegative && (n = a.labelIsNegative);\n\n        switch (m) {\n          case \"right\":\n            m = q ? n ? \"left\" : \"right\" : \"right\";\n            break;\n\n          case \"top\":\n            m = q ? \"top\" : n ? \"bottom\" : \"top\";\n            break;\n\n          case \"bottom\":\n            m = q ? \"bottom\" : n ? \"top\" : \"bottom\";\n            break;\n\n          case \"left\":\n            m = q ? n ? \"right\" : \"left\" : \"left\";\n        }\n\n        var t = a.columnGraphics,\n            r = 0,\n            w = 0;\n        t && (r = t.x, w = t.y);\n        var z = this.labelOffset;\n\n        switch (m) {\n          case \"right\":\n            k = \"start\";\n            b += d / 2 + z;\n            break;\n\n          case \"top\":\n            c = g.reversed ? c + (d / 2 + p.height / 2 + z) : c - (d / 2 + p.height / 2 + z);\n            break;\n\n          case \"bottom\":\n            c = g.reversed ? c - (d / 2 + p.height / 2 + z) : c + (d / 2 + p.height / 2 + z);\n            break;\n\n          case \"left\":\n            k = \"end\";\n            b -= d / 2 + z;\n            break;\n\n          case \"inside\":\n            \"column\" == this.type && (l = !0, q ? n ? (k = \"end\", b = r - 3 - z) : (k = \"start\", b = r + 3 + z) : c = n ? w + 7 + z : w - 10 - z);\n            break;\n\n          case \"middle\":\n            \"column\" == this.type && (l = !0, q ? b -= (b - r) / 2 + z - 3 : c -= (c - w) / 2 + z - 3);\n        }\n\n        \"auto\" != this.labelAnchor && (k = this.labelAnchor);\n        e.attr({\n          \"text-anchor\": k\n        });\n        this.labelRotation && e.rotate(this.labelRotation);\n        e.translate(b, c);\n        !this.showAllValueLabels && t && l && (p = e.getBBox(), p.height > a.columnHeight || p.width > a.columnWidth) && (e.remove(), e = null);\n        if (e && \"radar\" != f.type) if (q) {\n          if (0 > c || c > this.height) e.remove(), e = null;\n          !this.showAllValueLabels && e && (0 > b || b > this.width) && (e.remove(), e = null);\n        } else {\n          if (0 > b || b > this.width) e.remove(), e = null;\n          !this.showAllValueLabels && e && (0 > c || c > this.height) && (e.remove(), e = null);\n        }\n        e && this.allBullets.push(e);\n        return e;\n      }\n    },\n    getGradRotation: function () {\n      var a = 270;\n      \"horizontal\" == this.gradientOrientation && (a = 0);\n      return this.gradientRotation = a;\n    },\n    createSerialGraph: function () {\n      this.dashLengthSwitched = this.fillColorsSwitched = this.lineColorSwitched = void 0;\n      var a = this.chart,\n          b = this.id,\n          c = this.index,\n          e = this.data,\n          h = this.chart.container,\n          f = this.valueAxis,\n          g = this.type,\n          k = this.columnWidthReal,\n          l = this.showBulletsAt;\n      isNaN(this.columnWidth) || (k = this.columnWidth);\n      isNaN(k) && (k = .8);\n      var m = this.useNegativeColorIfDown,\n          p = this.width,\n          q = this.height,\n          n = this.y,\n          t = this.rotate,\n          r = this.columnCount,\n          w = d.toCoordinate(this.cornerRadiusTop, k / 2),\n          z = this.connect,\n          x = [],\n          u = [],\n          A,\n          y,\n          B,\n          D,\n          C = this.chart.graphs.length,\n          I,\n          H = this.dx / this.tcc,\n          Q = this.dy / this.tcc,\n          M = f.stackType,\n          P = this.start,\n          ia = this.end,\n          J = this.scrollbar,\n          aa = \"graph-column-\";\n      J && (aa = \"scrollbar-graph-column-\");\n      var ma = this.categoryAxis,\n          na = this.baseCoord,\n          Pa = this.negativeBase,\n          Z = this.columnIndex,\n          da = this.lineThickness,\n          X = this.lineAlpha,\n          xa = this.lineColorR,\n          ea = this.dashLength,\n          fa = this.set,\n          Ba,\n          ga = this.getGradRotation(),\n          V = this.chart.columnSpacing,\n          Y = ma.cellWidth,\n          Da = (Y * k - r) / r;\n      V > Da && (V = Da);\n      var G,\n          v,\n          oa,\n          ha = q,\n          Qa = p,\n          ca = 0,\n          tb = 0,\n          ub = 0,\n          vb = 0,\n          gb = 0,\n          hb = 0,\n          wb = this.fillColorsR,\n          Ra = this.negativeFillColors,\n          Ja = this.negativeLineColor,\n          Ya = this.fillAlphas,\n          Za = this.negativeFillAlphas;\n      \"object\" == typeof Ya && (Ya = Ya[0]);\n      \"object\" == typeof Za && (Za = Za[0]);\n      var xb = this.noRounding;\n      \"step\" == g && (xb = !1);\n      var ib = f.getCoordinate(f.min);\n      f.logarithmic && (ib = f.getCoordinate(f.minReal));\n      this.minCoord = ib;\n      this.resetBullet && (this.bullet = \"none\");\n\n      if (!(J || \"line\" != g && \"smoothedLine\" != g && \"step\" != g || (1 == e.length && \"step\" != g && \"none\" == this.bullet && (this.bullet = \"round\", this.resetBullet = !0), !Ra && void 0 == Ja || m))) {\n        var Ua = Pa;\n        Ua > f.max && (Ua = f.max);\n        Ua < f.min && (Ua = f.min);\n        f.logarithmic && (Ua = f.minReal);\n        var Ka = f.getCoordinate(Ua),\n            Mb = f.getCoordinate(f.max);\n        t ? (ha = q, Qa = Math.abs(Mb - Ka), ub = q, vb = Math.abs(ib - Ka), hb = tb = 0, f.reversed ? (ca = 0, gb = Ka) : (ca = Ka, gb = 0)) : (Qa = p, ha = Math.abs(Mb - Ka), vb = p, ub = Math.abs(ib - Ka), gb = ca = 0, f.reversed ? (hb = n, tb = Ka) : hb = Ka);\n      }\n\n      var La = Math.round;\n      this.pmx = La(ca);\n      this.pmy = La(tb);\n      this.pmh = La(ha);\n      this.pmw = La(Qa);\n      this.nmx = La(gb);\n      this.nmy = La(hb);\n      this.nmh = La(ub);\n      this.nmw = La(vb);\n      d.isModern || (this.nmy = this.nmx = 0, this.nmh = this.height);\n      this.clustered || (r = 1);\n      k = \"column\" == g ? (Y * k - V * (r - 1)) / r : Y * k;\n      1 > k && (k = 1);\n      var Nb = this.fixedColumnWidth;\n      isNaN(Nb) || (k = Nb);\n      var L;\n\n      if (\"line\" == g || \"step\" == g || \"smoothedLine\" == g) {\n        if (0 < P) {\n          for (L = P - 1; -1 < L; L--) if (G = e[L], v = G.axes[f.id].graphs[b], oa = v.values.value, !isNaN(oa)) {\n            P = L;\n            break;\n          }\n\n          if (this.lineColorField) for (L = P; -1 < L; L--) if (G = e[L], v = G.axes[f.id].graphs[b], v.lineColor) {\n            this.lineColorSwitched = v.lineColor;\n            void 0 === this.bulletColor && (this.bulletColorSwitched = this.lineColorSwitched);\n            break;\n          }\n          if (this.fillColorsField) for (L = P; -1 < L; L--) if (G = e[L], v = G.axes[f.id].graphs[b], v.fillColors) {\n            this.fillColorsSwitched = v.fillColors;\n            break;\n          }\n          if (this.dashLengthField) for (L = P; -1 < L; L--) if (G = e[L], v = G.axes[f.id].graphs[b], !isNaN(v.dashLength)) {\n            this.dashLengthSwitched = v.dashLength;\n            break;\n          }\n        }\n\n        if (ia < e.length - 1) for (L = ia + 1; L < e.length; L++) if (G = e[L], v = G.axes[f.id].graphs[b], oa = v.values.value, !isNaN(oa)) {\n          ia = L;\n          break;\n        }\n      }\n\n      ia < e.length - 1 && ia++;\n      var T = [],\n          U = [],\n          Ma = !1;\n      if (\"line\" == g || \"step\" == g || \"smoothedLine\" == g) if (this.stackable && \"regular\" == M || \"100%\" == M || this.fillToGraph) Ma = !0;\n      var Ob = this.noStepRisers,\n          jb = -1E3,\n          kb = -1E3,\n          lb = this.minDistance,\n          Sa = !0,\n          $a = !1;\n\n      for (L = P; L <= ia; L++) {\n        G = e[L];\n        v = G.axes[f.id].graphs[b];\n        v.index = L;\n        var ab,\n            Ta = NaN;\n        if (m && void 0 == this.openField) for (var yb = L + 1; yb < e.length && (!e[yb] || !(ab = e[L + 1].axes[f.id].graphs[b]) || !ab.values || (Ta = ab.values.value, isNaN(Ta))); yb++);\n        var S,\n            R,\n            K,\n            ba,\n            ja = NaN,\n            E = NaN,\n            F = NaN,\n            O = NaN,\n            N = NaN,\n            qa = NaN,\n            ra = NaN,\n            sa = NaN,\n            ta = NaN,\n            ya = NaN,\n            Ea = NaN,\n            ka = NaN,\n            la = NaN,\n            W = NaN,\n            zb = NaN,\n            Ab = NaN,\n            ua = NaN,\n            va = void 0,\n            Na = wb,\n            Va = Ya,\n            Ha = xa,\n            Ca,\n            za,\n            Bb = this.proCandlesticks,\n            mb = this.topRadius,\n            Fa = q - 1,\n            pa = p - 1,\n            bb = this.pattern;\n        void 0 != v.pattern && (bb = v.pattern);\n        isNaN(v.alpha) || (Va = v.alpha);\n        isNaN(v.dashLength) || (ea = v.dashLength);\n        var Ia = v.values;\n        f.recalculateToPercents && (Ia = v.percents);\n        \"none\" == M && (Z = isNaN(v.columnIndex) ? this.columnIndex : v.columnIndex);\n\n        if (Ia) {\n          W = this.stackable && \"none\" != M && \"3d\" != M ? Ia.close : Ia.value;\n          if (\"candlestick\" == g || \"ohlc\" == g) W = Ia.close, Ab = Ia.low, ra = f.getCoordinate(Ab), zb = Ia.high, ta = f.getCoordinate(zb);\n          ua = Ia.open;\n          F = f.getCoordinate(W, xb);\n          isNaN(ua) || (N = f.getCoordinate(ua, xb), m && \"regular\" != M && \"100%\" != M && (Ta = ua, ua = N = NaN));\n          m && (void 0 == this.openField ? ab && (ab.isNegative = Ta < W ? !0 : !1, isNaN(Ta) && (v.isNegative = !Sa)) : v.isNegative = Ta > W ? !0 : !1);\n          if (!J) switch (this.showBalloonAt) {\n            case \"close\":\n              v.y = F;\n              break;\n\n            case \"open\":\n              v.y = N;\n              break;\n\n            case \"high\":\n              v.y = ta;\n              break;\n\n            case \"low\":\n              v.y = ra;\n          }\n          var ja = G.x[ma.id],\n              Wa = this.periodSpan - 1;\n          \"step\" != g || isNaN(G.cellWidth) || (Y = G.cellWidth);\n          var wa = Math.floor(Y / 2) + Math.floor(Wa * Y / 2),\n              Ga = wa,\n              nb = 0;\n          \"left\" == this.stepDirection && (nb = (2 * Y + Wa * Y) / 2, ja -= nb);\n          \"center\" == this.stepDirection && (nb = Y / 2, ja -= nb);\n          \"start\" == this.pointPosition && (ja -= Y / 2 + Math.floor(Wa * Y / 2), wa = 0, Ga = Math.floor(Y) + Math.floor(Wa * Y));\n          \"end\" == this.pointPosition && (ja += Y / 2 + Math.floor(Wa * Y / 2), wa = Math.floor(Y) + Math.floor(Wa * Y), Ga = 0);\n\n          if (Ob) {\n            var Cb = this.columnWidth;\n            isNaN(Cb) || (wa *= Cb, Ga *= Cb);\n          }\n\n          J || (v.x = ja);\n          -1E5 > ja && (ja = -1E5);\n          ja > p + 1E5 && (ja = p + 1E5);\n          t ? (E = F, O = N, N = F = ja, isNaN(ua) && !this.fillToGraph && (O = na), qa = ra, sa = ta) : (O = E = ja, isNaN(ua) && !this.fillToGraph && (N = na));\n          if (!Bb && W < ua || Bb && W < Ba) v.isNegative = !0, Ra && (Na = Ra), Za && (Va = Za), void 0 != Ja && (Ha = Ja);\n          $a = !1;\n          isNaN(W) || (m ? W > Ta ? (Sa && ($a = !0), Sa = !1) : (Sa || ($a = !0), Sa = !0) : v.isNegative = W < Pa ? !0 : !1, Ba = W);\n          var Pb = !1;\n          J && a.chartScrollbar.ignoreCustomColors && (Pb = !0);\n          Pb || (void 0 != v.color && (Na = v.color), v.fillColors && (Na = v.fillColors));\n          F = d.fitToBounds(F, -3E4, 3E4);\n\n          switch (g) {\n            case \"line\":\n              if (isNaN(W)) z || (this.drawLineGraph(x, u, T, U), x = [], u = [], T = [], U = []);else {\n                if (Math.abs(E - jb) >= lb || Math.abs(F - kb) >= lb) x.push(E), u.push(F), jb = E, kb = F;\n                ya = E;\n                Ea = F;\n                ka = E;\n                la = F;\n                !Ma || isNaN(N) || isNaN(O) || (T.push(O), U.push(N));\n                if ($a || void 0 != v.lineColor && v.lineColor != this.lineColorSwitched || void 0 != v.fillColors && v.fillColors != this.fillColorsSwitched || !isNaN(v.dashLength)) this.drawLineGraph(x, u, T, U), x = [E], u = [F], T = [], U = [], !Ma || isNaN(N) || isNaN(O) || (T.push(O), U.push(N)), m ? (Sa ? (this.lineColorSwitched = xa, this.fillColorsSwitched = wb) : (this.lineColorSwitched = Ja, this.fillColorsSwitched = Ra), void 0 === this.bulletColor && (this.bulletColorSwitched = xa)) : (this.lineColorSwitched = v.lineColor, this.fillColorsSwitched = v.fillColors, void 0 === this.bulletColor && (this.bulletColorSwitched = this.lineColorSwitched)), this.dashLengthSwitched = v.dashLength;\n                v.gap && (this.drawLineGraph(x, u, T, U), x = [], u = [], T = [], U = []);\n              }\n              break;\n\n            case \"smoothedLine\":\n              if (isNaN(W)) z || (this.drawSmoothedGraph(x, u, T, U), x = [], u = [], T = [], U = []);else {\n                if (Math.abs(E - jb) >= lb || Math.abs(F - kb) >= lb) x.push(E), u.push(F), jb = E, kb = F;\n                ya = E;\n                Ea = F;\n                ka = E;\n                la = F;\n                !Ma || isNaN(N) || isNaN(O) || (T.push(O), U.push(N));\n                void 0 == v.lineColor && void 0 == v.fillColors && isNaN(v.dashLength) || (this.drawSmoothedGraph(x, u, T, U), x = [E], u = [F], T = [], U = [], !Ma || isNaN(N) || isNaN(O) || (T.push(O), U.push(N)), this.lineColorSwitched = v.lineColor, this.fillColorsSwitched = v.fillColors, this.dashLengthSwitched = v.dashLength);\n                v.gap && (this.drawSmoothedGraph(x, u, T, U), x = [], u = [], T = [], U = []);\n              }\n              break;\n\n            case \"step\":\n              if (!isNaN(W)) {\n                t ? (isNaN(A) || (x.push(A), u.push(F - wa)), u.push(F - wa), x.push(E), u.push(F + Ga), x.push(E), !Ma || isNaN(N) || isNaN(O) || (isNaN(B) || (T.push(B), U.push(N - wa)), T.push(O), U.push(N - wa), T.push(O), U.push(N + Ga))) : (isNaN(y) || (u.push(y), x.push(E - wa)), x.push(E - wa), u.push(F), x.push(E + Ga), u.push(F), !Ma || isNaN(N) || isNaN(O) || (isNaN(D) || (T.push(O - wa), U.push(D)), T.push(O - wa), U.push(N), T.push(O + Ga), U.push(N)));\n                A = E;\n                y = F;\n                B = O;\n                D = N;\n                ya = E;\n                Ea = F;\n                ka = E;\n                la = F;\n\n                if ($a || void 0 != v.lineColor || void 0 != v.fillColors || !isNaN(v.dashLength)) {\n                  var Db = x[x.length - 2],\n                      dc = u[u.length - 2];\n                  x.pop();\n                  u.pop();\n                  T.pop();\n                  U.pop();\n                  this.drawLineGraph(x, u, T, U);\n                  x = [Db];\n                  u = [dc];\n                  T = [];\n                  U = [];\n                  Ma && (T = [Db, Db + wa + Ga], U = [D, D]);\n                  t ? (u.push(F + Ga), x.push(E)) : (x.push(E + Ga), u.push(F));\n                  this.lineColorSwitched = v.lineColor;\n                  this.fillColorsSwitched = v.fillColors;\n                  this.dashLengthSwitched = v.dashLength;\n                  m && (Sa ? (this.lineColorSwitched = xa, this.fillColorsSwitched = wb) : (this.lineColorSwitched = Ja, this.fillColorsSwitched = Ra));\n                }\n\n                if (Ob || v.gap) A = y = NaN, this.drawLineGraph(x, u, T, U), x = [], u = [], T = [], U = [];\n              } else if (!z) {\n                if (1 >= this.periodSpan || 1 < this.periodSpan && E - A > wa + Ga) A = y = NaN;\n                this.drawLineGraph(x, u, T, U);\n                x = [];\n                u = [];\n                T = [];\n                U = [];\n              }\n\n              break;\n\n            case \"column\":\n              Ca = Ha;\n              void 0 != v.lineColor && (Ca = v.lineColor);\n\n              if (!isNaN(W)) {\n                m || (v.isNegative = W < Pa ? !0 : !1);\n                v.isNegative && (Ra && (Na = Ra), void 0 != Ja && (Ca = Ja));\n                var Qb = f.min,\n                    Rb = f.max,\n                    ob = ua;\n                isNaN(ob) && (ob = Pa);\n\n                if (!(W < Qb && ob < Qb || W > Rb && ob > Rb)) {\n                  var Aa;\n\n                  if (t) {\n                    \"3d\" == M ? (R = F - (r / 2 - this.depthCount + 1) * (k + V) + V / 2 + Q * Z, S = O + H * Z, Aa = Z) : (R = Math.floor(F - (r / 2 - Z) * (k + V) + V / 2), S = O, Aa = 0);\n                    K = k;\n                    ya = E;\n                    Ea = R + k / 2;\n                    ka = E;\n                    la = R + k / 2;\n                    R + K > q + Aa * Q && (K = q - R + Aa * Q);\n                    R < Aa * Q && (K += R, R = Aa * Q);\n                    ba = E - O;\n                    var ec = S;\n                    S = d.fitToBounds(S, 0, p);\n                    ba += ec - S;\n                    ba = d.fitToBounds(ba, -S, p - S + H * Z);\n                    v.labelIsNegative = 0 > ba ? !0 : !1;\n                    0 === ba && 1 / W === 1 / -0 && (v.labelIsNegative = !0);\n                    isNaN(G.percentWidthValue) || (K = this.height * G.percentWidthValue / 100, R = ja - K / 2, Ea = R + K / 2);\n                    K = d.roundTo(K, 2);\n                    ba = d.roundTo(ba, 2);\n                    R < q && 0 < K && (va = new d.Cuboid(h, ba, K, H - a.d3x, Q - a.d3y, Na, Va, da, Ca, X, ga, w, t, ea, bb, mb, aa), v.columnWidth = Math.abs(ba), v.columnHeight = Math.abs(K));\n                  } else {\n                    \"3d\" == M ? (S = E - (r / 2 - this.depthCount + 1) * (k + V) + V / 2 + H * Z, R = N + Q * Z, Aa = Z) : (S = E - (r / 2 - Z) * (k + V) + V / 2, R = N, Aa = 0);\n                    K = k;\n                    ya = S + k / 2;\n                    Ea = F;\n                    ka = S + k / 2;\n                    la = F;\n                    S + K > p + Aa * H && (K = p - S + Aa * H);\n                    S < Aa * H && (K += S - Aa * H, S = Aa * H);\n                    ba = F - N;\n                    v.labelIsNegative = 0 < ba ? !0 : !1;\n                    0 === ba && 1 / W !== 1 / Math.abs(W) && (v.labelIsNegative = !0);\n                    var fc = R;\n                    R = d.fitToBounds(R, this.dy, q);\n                    ba += fc - R;\n                    ba = d.fitToBounds(ba, -R + Q * Aa, q - R);\n                    isNaN(G.percentWidthValue) || (K = this.width * G.percentWidthValue / 100, S = ja - K / 2, ya = S + K / 2);\n                    K = d.roundTo(K, 2);\n                    ba = d.roundTo(ba, 2);\n                    S < p + Z * H && 0 < K && (this.showOnAxis && (R -= Q / 2), va = new d.Cuboid(h, K, ba, H - a.d3x, Q - a.d3y, Na, Va, da, Ca, this.lineAlpha, ga, w, t, ea, bb, mb, aa), v.columnHeight = Math.abs(ba), v.columnWidth = Math.abs(K));\n                  }\n                }\n\n                if (va) {\n                  za = va.set;\n                  d.setCN(a, va.set, \"graph-\" + this.type);\n                  d.setCN(a, va.set, \"graph-\" + this.id);\n                  v.className && d.setCN(a, va.set, v.className, !0);\n                  v.columnGraphics = za;\n                  S = d.roundTo(S, 2);\n                  R = d.roundTo(R, 2);\n                  za.translate(S, R);\n                  (v.url || this.showHandOnHover) && za.setAttr(\"cursor\", \"pointer\");\n\n                  if (!J) {\n                    \"none\" == M && (I = t ? (this.end + 1 - L) * C - c : C * L + c);\n                    \"3d\" == M && (t ? (I = (this.end + 1 - L) * C - c - 1E3 * this.depthCount, ya += H * Z, ka += H * Z, v.y += H * Z) : (I = (C - c) * (L + 1) + 1E3 * this.depthCount, Ea += Q * Z, la += Q * Z, v.y += Q * Z));\n                    if (\"regular\" == M || \"100%\" == M) I = t ? 0 < Ia.value ? (this.end + 1 - L) * C + c : (this.end + 1 - L) * C - c : 0 < Ia.value ? C * L + c : C * L - c;\n                    this.columnsArray.push({\n                      column: va,\n                      depth: I\n                    });\n                    v.x = t ? R + K / 2 : S + K / 2;\n                    this.ownColumns.push(va);\n                    this.animateColumns(va, L, E, O, F, N);\n                    this.addListeners(za, v);\n                    void 0 !== this.tabIndex && za.setAttr(\"tabindex\", this.tabIndex);\n                  }\n\n                  this.columnsSet.push(za);\n                }\n              }\n\n              break;\n\n            case \"candlestick\":\n              if (!isNaN(ua) && !isNaN(W)) {\n                var Xa, cb;\n                Ca = Ha;\n                void 0 != v.lineColor && (Ca = v.lineColor);\n                ya = E;\n                la = Ea = F;\n                ka = E;\n\n                if (t) {\n                  \"open\" == l && (ka = O);\n                  \"high\" == l && (ka = sa);\n                  \"low\" == l && (ka = qa);\n                  E = d.fitToBounds(E, 0, pa);\n                  O = d.fitToBounds(O, 0, pa);\n                  qa = d.fitToBounds(qa, 0, pa);\n                  sa = d.fitToBounds(sa, 0, pa);\n                  if (0 === E && 0 === O && 0 === qa && 0 === sa) continue;\n                  if (E == pa && O == pa && qa == pa && sa == pa) continue;\n                  R = F - k / 2;\n                  S = O;\n                  K = k;\n                  R + K > q && (K = q - R);\n                  0 > R && (K += R, R = 0);\n\n                  if (R < q && 0 < K) {\n                    var Eb, Fb;\n                    W > ua ? (Eb = [E, sa], Fb = [O, qa]) : (Eb = [O, sa], Fb = [E, qa]);\n                    !isNaN(sa) && !isNaN(qa) && F < q && 0 < F && (Xa = d.line(h, Eb, [F, F], Ca, X, da), cb = d.line(h, Fb, [F, F], Ca, X, da));\n                    ba = E - O;\n                    va = new d.Cuboid(h, ba, K, H, Q, Na, Ya, da, Ca, X, ga, w, t, ea, bb, mb, aa);\n                  }\n                } else {\n                  \"open\" == l && (la = N);\n                  \"high\" == l && (la = ta);\n                  \"low\" == l && (la = ra);\n                  F = d.fitToBounds(F, 0, Fa);\n                  N = d.fitToBounds(N, 0, Fa);\n                  ra = d.fitToBounds(ra, 0, Fa);\n                  ta = d.fitToBounds(ta, 0, Fa);\n                  if (0 === F && 0 === N && 0 === ra && 0 === ta) continue;\n                  if (F == Fa && N == Fa && ra == Fa && ta == Fa) continue;\n                  S = E - k / 2;\n                  R = N + da / 2;\n                  K = k;\n                  S + K > p && (K = p - S);\n                  0 > S && (K += S, S = 0);\n                  ba = F - N;\n\n                  if (S < p && 0 < K) {\n                    Bb && W >= ua && (Va = 0);\n                    var va = new d.Cuboid(h, K, ba, H, Q, Na, Va, da, Ca, X, ga, w, t, ea, bb, mb, aa),\n                        Gb,\n                        Hb;\n                    W > ua ? (Gb = [F, ta], Hb = [N, ra]) : (Gb = [N, ta], Hb = [F, ra]);\n                    !isNaN(ta) && !isNaN(ra) && E < p && 0 < E && (Xa = d.line(h, [E, E], Gb, Ca, X, da), cb = d.line(h, [E, E], Hb, Ca, X, da), d.setCN(a, Xa, this.bcn + \"line-high\"), v.className && d.setCN(a, Xa, v.className, !0), d.setCN(a, cb, this.bcn + \"line-low\"), v.className && d.setCN(a, cb, v.className, !0));\n                  }\n                }\n\n                va && (za = va.set, v.columnGraphics = za, fa.push(za), za.translate(S, R - da / 2), (v.url || this.showHandOnHover) && za.setAttr(\"cursor\", \"pointer\"), Xa && (fa.push(Xa), fa.push(cb)), J || (v.x = t ? R + K / 2 : S + K / 2, this.animateColumns(va, L, E, O, F, N), this.addListeners(za, v), void 0 !== this.tabIndex && za.setAttr(\"tabindex\", this.tabIndex)));\n              }\n\n              break;\n\n            case \"ohlc\":\n              if (!(isNaN(ua) || isNaN(zb) || isNaN(Ab) || isNaN(W))) {\n                var Sb = h.set();\n                fa.push(Sb);\n                W < ua && (v.isNegative = !0, void 0 != Ja && (Ha = Ja));\n                void 0 != v.lineColor && (Ha = v.lineColor);\n                var pb, qb, rb;\n\n                if (t) {\n                  la = F;\n                  ka = E;\n                  \"open\" == l && (ka = O);\n                  \"high\" == l && (ka = sa);\n                  \"low\" == l && (ka = qa);\n                  qa = d.fitToBounds(qa, 0, pa);\n                  sa = d.fitToBounds(sa, 0, pa);\n                  if (0 === E && 0 === O && 0 === qa && 0 === sa) continue;\n                  if (E == pa && O == pa && qa == pa && sa == pa) continue;\n                  var Ib = F - k / 2,\n                      Ib = d.fitToBounds(Ib, 0, q),\n                      Tb = d.fitToBounds(F, 0, q),\n                      Jb = F + k / 2,\n                      Jb = d.fitToBounds(Jb, 0, q);\n                  0 <= O && O <= pa && (qb = d.line(h, [O, O], [Ib, Tb], Ha, X, da, ea));\n                  0 < F && F < q && (pb = d.line(h, [qa, sa], [F, F], Ha, X, da, ea));\n                  0 <= E && E <= pa && (rb = d.line(h, [E, E], [Tb, Jb], Ha, X, da, ea));\n                } else {\n                  la = F;\n                  \"open\" == l && (la = N);\n                  \"high\" == l && (la = ta);\n                  \"low\" == l && (la = ra);\n                  var ka = E,\n                      ra = d.fitToBounds(ra, 0, Fa),\n                      ta = d.fitToBounds(ta, 0, Fa),\n                      Kb = E - k / 2,\n                      Kb = d.fitToBounds(Kb, 0, p),\n                      Ub = d.fitToBounds(E, 0, p),\n                      Lb = E + k / 2,\n                      Lb = d.fitToBounds(Lb, 0, p);\n                  0 <= N && N <= Fa && (qb = d.line(h, [Kb, Ub], [N, N], Ha, X, da, ea));\n                  0 < E && E < p && (pb = d.line(h, [E, E], [ra, ta], Ha, X, da, ea));\n                  0 <= F && F <= Fa && (rb = d.line(h, [Ub, Lb], [F, F], Ha, X, da, ea));\n                }\n\n                fa.push(qb);\n                fa.push(pb);\n                fa.push(rb);\n                d.setCN(a, qb, this.bcn + \"stroke-open\");\n                d.setCN(a, rb, this.bcn + \"stroke-close\");\n                d.setCN(a, pb, this.bcn + \"stroke\");\n                v.className && d.setCN(a, Sb, v.className, !0);\n                ya = E;\n                Ea = F;\n              }\n\n          }\n\n          if (!J && !isNaN(W)) {\n            var Vb = this.hideBulletsCount;\n\n            if (this.end - this.start <= Vb || 0 === Vb) {\n              var Wb = this.createBullet(v, ka, la, L),\n                  Xb = this.labelText;\n\n              if (Xb && !isNaN(ya) && !isNaN(ya)) {\n                var gc = this.createLabel(v, Xb),\n                    Yb = 0;\n                Wb && (Yb = Wb.size);\n                this.positionLabel(v, ya, Ea, gc, Yb);\n              }\n\n              if (\"regular\" == M || \"100%\" == M) {\n                var Zb = f.totalText;\n\n                if (Zb) {\n                  var Oa = this.createLabel(v, Zb, f.totalTextColor);\n                  d.setCN(a, Oa, this.bcn + \"label-total\");\n                  this.allBullets.push(Oa);\n\n                  if (Oa) {\n                    var $b = Oa.getBBox(),\n                        ac = $b.width,\n                        bc = $b.height,\n                        db,\n                        eb,\n                        sb = f.totalTextOffset,\n                        cc = f.totals[L];\n                    cc && cc.remove();\n                    var fb = 0;\n                    \"column\" != g && (fb = this.bulletSize);\n                    t ? (eb = Ea, db = 0 > W ? E - ac / 2 - 2 - fb - sb : E + ac / 2 + 3 + fb + sb) : (db = ya, eb = 0 > W ? F + bc / 2 + fb + sb : F - bc / 2 - 3 - fb - sb);\n                    Oa.translate(db, eb);\n                    f.totals[L] = Oa;\n                    t ? (0 > eb || eb > q) && Oa.remove() : (0 > db || db > p) && Oa.remove();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      this.lastDataItem = v;\n      if (\"line\" == g || \"step\" == g || \"smoothedLine\" == g) \"smoothedLine\" == g ? this.drawSmoothedGraph(x, u, T, U) : this.drawLineGraph(x, u, T, U), J || this.launchAnimation();\n      this.bulletsHidden && this.hideBullets();\n      this.customBulletsHidden && this.hideCustomBullets();\n    },\n    animateColumns: function (a, b) {\n      var c = this,\n          e = c.chart.startDuration;\n      0 < e && !c.animationPlayed && (c.seqAn ? (a.set.hide(), c.animationArray.push(a), e = setTimeout(function () {\n        c.animate.call(c);\n      }, e / (c.end - c.start + 1) * (b - c.start) * 1E3), c.timeOuts.push(e)) : c.animate(a), c.chart.animatable.push(a));\n    },\n    createLabel: function (a, b, c) {\n      var e = this.chart,\n          h = a.labelColor;\n      h || (h = this.color);\n      h || (h = e.color);\n      c && (h = c);\n      c = this.fontSize;\n      void 0 === c && (this.fontSize = c = e.fontSize);\n      var f = this.labelFunction;\n      b = e.formatString(b, a);\n      b = d.cleanFromEmpty(b);\n      f && (b = f(a, b));\n      if (void 0 !== b && \"\" !== b) return a = d.text(this.container, b, h, e.fontFamily, c), a.node.style.pointerEvents = \"none\", d.setCN(e, a, this.bcn + \"label\"), this.bulletSet.push(a), a;\n    },\n    positiveClip: function (a) {\n      a.clipRect(this.pmx, this.pmy, this.pmw, this.pmh);\n    },\n    negativeClip: function (a) {\n      a.clipRect(this.nmx, this.nmy, this.nmw, this.nmh);\n    },\n    drawLineGraph: function (a, b, c, e) {\n      var h = this;\n\n      if (1 < a.length) {\n        var f = h.noRounding,\n            g = h.set,\n            k = h.chart,\n            l = h.container,\n            m = l.set(),\n            p = l.set();\n        g.push(p);\n        g.push(m);\n        var q = h.lineAlpha,\n            n = h.lineThickness,\n            g = h.fillAlphas,\n            t = h.lineColorR,\n            r = h.negativeLineAlpha;\n        isNaN(r) && (r = q);\n        var w = h.lineColorSwitched;\n        w && (t = w);\n        var w = h.fillColorsR,\n            z = h.fillColorsSwitched;\n        z && (w = z);\n        var x = h.dashLength;\n        (z = h.dashLengthSwitched) && (x = z);\n        var z = h.negativeLineColor,\n            u = h.negativeFillColors,\n            A = h.negativeFillAlphas,\n            y = h.baseCoord;\n        0 !== h.negativeBase && (y = h.valueAxis.getCoordinate(h.negativeBase, f), y > h.height && (y = h.height), 0 > y && (y = 0));\n        q = d.line(l, a, b, t, q, n, x, !1, !0, f);\n        q.node.setAttribute(\"stroke-linejoin\", \"round\");\n        d.setCN(k, q, h.bcn + \"stroke\");\n        m.push(q);\n        m.click(function (a) {\n          h.handleGraphEvent(a, \"clickGraph\");\n        }).mouseover(function (a) {\n          h.handleGraphEvent(a, \"rollOverGraph\");\n        }).mouseout(function (a) {\n          h.handleGraphEvent(a, \"rollOutGraph\");\n        }).touchmove(function (a) {\n          h.chart.handleMouseMove(a);\n        }).touchend(function (a) {\n          h.chart.handleTouchEnd(a);\n        });\n        void 0 === z || h.useNegativeColorIfDown || (n = d.line(l, a, b, z, r, n, x, !1, !0, f), n.node.setAttribute(\"stroke-linejoin\", \"round\"), d.setCN(k, n, h.bcn + \"stroke\"), d.setCN(k, n, h.bcn + \"stroke-negative\"), p.push(n));\n        if (0 < g || 0 < A) if (n = a.join(\";\").split(\";\"), r = b.join(\";\").split(\";\"), q = k.type, \"serial\" == q || \"radar\" == q ? 0 < c.length ? (c.reverse(), e.reverse(), n = a.concat(c), r = b.concat(e)) : \"radar\" == q ? (r.push(0), n.push(0)) : h.rotate ? (r.push(r[r.length - 1]), n.push(y), r.push(r[0]), n.push(y), r.push(r[0]), n.push(n[0])) : (n.push(n[n.length - 1]), r.push(y), n.push(n[0]), r.push(y), n.push(a[0]), r.push(r[0])) : \"xy\" == q && (b = h.fillToAxis) && (d.isString(b) && (b = k.getValueAxisById(b)), \"H\" == b.orientation ? (y = \"top\" == b.position ? 0 : b.height, n.push(n[n.length - 1]), r.push(y), n.push(n[0]), r.push(y), n.push(a[0]), r.push(r[0])) : (y = \"left\" == b.position ? 0 : b.width, r.push(r[r.length - 1]), n.push(y), r.push(r[0]), n.push(y), r.push(r[0]), n.push(n[0]))), a = h.gradientRotation, 0 < g && (b = d.polygon(l, n, r, w, g, 1, \"#000\", 0, a, f), b.pattern(h.pattern, NaN, k.path), d.setCN(k, b, h.bcn + \"fill\"), m.push(b)), u || void 0 !== z) isNaN(A) && (A = g), u || (u = z), f = d.polygon(l, n, r, u, A, 1, \"#000\", 0, a, f), d.setCN(k, f, h.bcn + \"fill\"), d.setCN(k, f, h.bcn + \"fill-negative\"), f.pattern(h.pattern, NaN, k.path), p.push(f), p.click(function (a) {\n          h.handleGraphEvent(a, \"clickGraph\");\n        }).mouseover(function (a) {\n          h.handleGraphEvent(a, \"rollOverGraph\");\n        }).mouseout(function (a) {\n          h.handleGraphEvent(a, \"rollOutGraph\");\n        }).touchmove(function (a) {\n          h.chart.handleMouseMove(a);\n        }).touchend(function (a) {\n          h.chart.handleTouchEnd(a);\n        });\n        h.applyMask(p, m);\n      }\n    },\n    applyMask: function (a, b) {\n      var c = a.length();\n      \"serial\" != this.chart.type || this.scrollbar || (this.positiveClip(b), 0 < c && this.negativeClip(a));\n    },\n    drawSmoothedGraph: function (a, b, c, e) {\n      if (1 < a.length) {\n        var h = this.set,\n            f = this.chart,\n            g = this.container,\n            k = g.set(),\n            l = g.set();\n        h.push(l);\n        h.push(k);\n        var m = this.lineAlpha,\n            p = this.lineThickness,\n            h = this.dashLength,\n            q = this.fillAlphas,\n            n = this.lineColorR,\n            t = this.fillColorsR,\n            r = this.negativeLineColor,\n            w = this.negativeFillColors,\n            z = this.negativeFillAlphas,\n            x = this.baseCoord,\n            u = this.lineColorSwitched;\n        u && (n = u);\n        (u = this.fillColorsSwitched) && (t = u);\n        var A = this.negativeLineAlpha;\n        isNaN(A) && (A = m);\n        u = this.getGradRotation();\n        m = new d.Bezier(g, a, b, n, m, p, t, 0, h, void 0, u);\n        d.setCN(f, m, this.bcn + \"stroke\");\n        k.push(m.path);\n        void 0 !== r && (p = new d.Bezier(g, a, b, r, A, p, t, 0, h, void 0, u), d.setCN(f, p, this.bcn + \"stroke\"), d.setCN(f, p, this.bcn + \"stroke-negative\"), l.push(p.path));\n        0 < q && (p = a.join(\";\").split(\";\"), m = b.join(\";\").split(\";\"), n = \"\", 0 < c.length ? (c.push(\"M\"), e.push(\"M\"), c.reverse(), e.reverse(), p = a.concat(c), m = b.concat(e)) : (this.rotate ? (n += \" L\" + x + \",\" + b[b.length - 1], n += \" L\" + x + \",\" + b[0]) : (n += \" L\" + a[a.length - 1] + \",\" + x, n += \" L\" + a[0] + \",\" + x), n += \" L\" + a[0] + \",\" + b[0]), a = new d.Bezier(g, p, m, NaN, 0, 0, t, q, h, n, u), d.setCN(f, a, this.bcn + \"fill\"), a.path.pattern(this.pattern, NaN, f.path), k.push(a.path), w || void 0 !== r) && (z || (z = q), w || (w = r), g = new d.Bezier(g, p, m, NaN, 0, 0, w, z, h, n, u), g.path.pattern(this.pattern, NaN, f.path), d.setCN(f, g, this.bcn + \"fill\"), d.setCN(f, g, this.bcn + \"fill-negative\"), l.push(g.path));\n        this.applyMask(l, k);\n      }\n    },\n    launchAnimation: function () {\n      var a = this,\n          b = a.chart.startDuration;\n\n      if (0 < b && !a.animationPlayed) {\n        var c = a.set,\n            e = a.bulletSet;\n        d.VML || (c.attr({\n          opacity: a.startAlpha\n        }), e.attr({\n          opacity: a.startAlpha\n        }));\n        c.hide();\n        e.hide();\n        a.seqAn ? (b = setTimeout(function () {\n          a.animateGraphs.call(a);\n        }, a.index * b * 1E3), a.timeOuts.push(b)) : a.animateGraphs();\n      }\n    },\n    animateGraphs: function () {\n      var a = this.chart,\n          b = this.set,\n          c = this.bulletSet,\n          e = this.x,\n          d = this.y;\n      b.show();\n      c.show();\n      var f = a.startDuration,\n          g = a.startEffect;\n      b && (this.rotate ? (b.translate(-1E3, d), c.translate(-1E3, d)) : (b.translate(e, -1E3), c.translate(e, -1E3)), b.animate({\n        opacity: 1,\n        translate: e + \",\" + d\n      }, f, g), c.animate({\n        opacity: 1,\n        translate: e + \",\" + d\n      }, f, g), a.animatable.push(b));\n    },\n    animate: function (a) {\n      var b = this.chart,\n          c = this.animationArray;\n      !a && 0 < c.length && (a = c[0], c.shift());\n      c = d[d.getEffect(b.startEffect)];\n      b = b.startDuration;\n      a && (this.rotate ? a.animateWidth(b, c) : a.animateHeight(b, c), a.set.show());\n    },\n    legendKeyColor: function () {\n      var a = this.legendColor,\n          b = this.lineAlpha;\n      void 0 === a && (a = this.lineColorR, 0 === b && (b = this.fillColorsR) && (a = \"object\" == typeof b ? b[0] : b));\n      return a;\n    },\n    legendKeyAlpha: function () {\n      var a = this.legendAlpha;\n      void 0 === a && (a = this.lineAlpha, this.fillAlphas > a && (a = this.fillAlphas), 0 === a && (a = this.bulletAlpha), 0 === a && (a = 1));\n      return a;\n    },\n    createBullet: function (a, b, c) {\n      if (!isNaN(b) && !isNaN(c) && (\"none\" != this.bullet || this.customBullet || a.bullet || a.customBullet)) {\n        var e = this.chart,\n            h = this.container,\n            f = this.bulletOffset,\n            g = this.bulletSize;\n        isNaN(a.bulletSize) || (g = a.bulletSize);\n        var k = a.values.value,\n            l = this.maxValue,\n            m = this.minValue,\n            p = this.maxBulletSize,\n            q = this.minBulletSize;\n        isNaN(l) || (isNaN(k) || (g = (k - m) / (l - m) * (p - q) + q), m == l && (g = p));\n        l = g;\n        this.bulletAxis && (g = a.values.error, isNaN(g) || (k = g), g = this.bulletAxis.stepWidth * k);\n        g < this.minBulletSize && (g = this.minBulletSize);\n        this.rotate ? b = a.isNegative ? b - f : b + f : c = a.isNegative ? c + f : c - f;\n        q = this.bulletColorR;\n        a.lineColor && void 0 === this.bulletColor && (this.bulletColorSwitched = a.lineColor);\n        this.bulletColorSwitched && (q = this.bulletColorSwitched);\n        a.isNegative && void 0 !== this.bulletColorNegative && (q = this.bulletColorNegative);\n        void 0 !== a.color && (q = a.color);\n        var n;\n        \"xy\" == e.type && this.valueField && (n = this.pattern, a.pattern && (n = a.pattern));\n        f = this.bullet;\n        a.bullet && (f = a.bullet);\n        var k = this.bulletBorderThickness,\n            m = this.bulletBorderColorR,\n            p = this.bulletBorderAlpha,\n            t = this.bulletAlpha;\n        m || (m = q);\n        this.useLineColorForBulletBorder && (m = this.lineColorR, a.isNegative && this.negativeLineColor && (m = this.negativeLineColor), this.lineColorSwitched && (m = this.lineColorSwitched));\n        var r = a.alpha;\n        isNaN(r) || (t = r);\n        n = d.bullet(h, f, g, q, t, k, m, p, l, 0, n, e.path);\n        l = this.customBullet;\n        a.customBullet && (l = a.customBullet);\n        l && (n && n.remove(), \"function\" == typeof l ? (l = new l(), l.chart = e, a.bulletConfig && (l.availableSpace = c, l.graph = this, l.graphDataItem = a, l.bulletY = c, a.bulletConfig.minCoord = this.minCoord - c, l.bulletConfig = a.bulletConfig), l.write(h), n && l.showBullet && l.set.push(n), a.customBulletGraphics = l.cset, n = l.set) : (n = h.set(), l = h.image(l, 0, 0, g, g), n.push(l), this.centerCustomBullets && l.translate(-g / 2, -g / 2)));\n\n        if (n) {\n          (a.url || this.showHandOnHover) && n.setAttr(\"cursor\", \"pointer\");\n          if (\"serial\" == e.type || \"gantt\" == e.type) if (-.5 > b || b > this.width || c < -g / 2 || c > this.height) n.remove(), n = null;\n          n && (this.bulletSet.push(n), n.translate(b, c), this.addListeners(n, a), this.allBullets.push(n));\n          a.bx = b;\n          a.by = c;\n          d.setCN(e, n, this.bcn + \"bullet\");\n          a.className && d.setCN(e, n, a.className, !0);\n        }\n\n        if (n) {\n          n.size = g || 0;\n          if (e = this.bulletHitAreaSize) h = d.circle(h, e, \"#FFFFFF\", .001, 0), h.translate(b, c), a.hitBullet = h, this.bulletSet.push(h), this.addListeners(h, a);\n          a.bulletGraphics = n;\n          void 0 !== this.tabIndex && n.setAttr(\"tabindex\", this.tabIndex);\n        } else n = {\n          size: 0\n        };\n\n        n.graphDataItem = a;\n        return n;\n      }\n    },\n    showBullets: function () {\n      var a = this.allBullets,\n          b;\n      this.bulletsHidden = !1;\n\n      for (b = 0; b < a.length; b++) a[b].show();\n    },\n    hideBullets: function () {\n      var a = this.allBullets,\n          b;\n      this.bulletsHidden = !0;\n\n      for (b = 0; b < a.length; b++) a[b].hide();\n    },\n    showCustomBullets: function () {\n      var a = this.allBullets,\n          b;\n      this.customBulletsHidden = !1;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b].graphDataItem;\n        c && c.customBulletGraphics && c.customBulletGraphics.show();\n      }\n    },\n    hideCustomBullets: function () {\n      var a = this.allBullets,\n          b;\n      this.customBulletsHidden = !0;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b].graphDataItem;\n        c && c.customBulletGraphics && c.customBulletGraphics.hide();\n      }\n    },\n    addListeners: function (a, b) {\n      var c = this;\n      a.mouseover(function (a) {\n        c.handleRollOver(b, a);\n      }).mouseout(function (a) {\n        c.handleRollOut(b, a);\n      }).touchend(function (a) {\n        c.handleRollOver(b, a);\n        c.chart.panEventsEnabled && c.handleClick(b, a);\n      }).touchstart(function (a) {\n        c.handleRollOver(b, a);\n      }).click(function (a) {\n        c.handleClick(b, a);\n      }).dblclick(function (a) {\n        c.handleDoubleClick(b, a);\n      }).contextmenu(function (a) {\n        c.handleRightClick(b, a);\n      });\n      var e = c.chart;\n\n      if (e.accessible && c.accessibleLabel) {\n        var d = e.formatString(c.accessibleLabel, b);\n        e.makeAccessible(a, d);\n      }\n    },\n    handleRollOver: function (a, b) {\n      this.handleGraphEvent(b, \"rollOverGraph\");\n\n      if (a) {\n        var c = this.chart;\n        a.bulletConfig && (c.isRolledOverBullet = !0);\n        var e = {\n          type: \"rollOverGraphItem\",\n          item: a,\n          index: a.index,\n          graph: this,\n          target: this,\n          chart: this.chart,\n          event: b\n        };\n        this.fire(e);\n        c.fire(e);\n        clearTimeout(c.hoverInt);\n        (c = c.chartCursor) && c.valueBalloonsEnabled || this.showGraphBalloon(a, \"V\", !0);\n      }\n    },\n    handleRollOut: function (a, b) {\n      var c = this.chart;\n\n      if (a) {\n        var e = {\n          type: \"rollOutGraphItem\",\n          item: a,\n          index: a.index,\n          graph: this,\n          target: this,\n          chart: this.chart,\n          event: b\n        };\n        this.fire(e);\n        c.fire(e);\n        c.isRolledOverBullet = !1;\n      }\n\n      this.handleGraphEvent(b, \"rollOutGraph\");\n      (c = c.chartCursor) && c.valueBalloonsEnabled || this.hideBalloon();\n    },\n    handleClick: function (a, b) {\n      if (!this.chart.checkTouchMoved() && this.chart.checkTouchDuration(b)) {\n        if (a) {\n          var c = {\n            type: \"clickGraphItem\",\n            item: a,\n            index: a.index,\n            graph: this,\n            target: this,\n            chart: this.chart,\n            event: b\n          };\n          this.fire(c);\n          this.chart.fire(c);\n          d.getURL(a.url, this.urlTarget);\n        }\n\n        this.handleGraphEvent(b, \"clickGraph\");\n      }\n    },\n    handleGraphEvent: function (a, b) {\n      var c = {\n        type: b,\n        graph: this,\n        target: this,\n        chart: this.chart,\n        event: a\n      };\n      this.fire(c);\n      this.chart.fire(c);\n    },\n    handleRightClick: function (a, b) {\n      if (a) {\n        var c = {\n          type: \"rightClickGraphItem\",\n          item: a,\n          index: a.index,\n          graph: this,\n          target: this,\n          chart: this.chart,\n          event: b\n        };\n        this.fire(c);\n        this.chart.fire(c);\n      }\n    },\n    handleDoubleClick: function (a, b) {\n      if (a) {\n        var c = {\n          type: \"doubleClickGraphItem\",\n          item: a,\n          index: a.index,\n          graph: this,\n          target: this,\n          chart: this.chart,\n          event: b\n        };\n        this.fire(c);\n        this.chart.fire(c);\n      }\n    },\n    zoom: function (a, b) {\n      this.start = a;\n      this.end = b;\n      this.draw();\n    },\n    changeOpacity: function (a) {\n      var b = this.set;\n      b && b.setAttr(\"opacity\", a);\n\n      if (b = this.ownColumns) {\n        var c;\n\n        for (c = 0; c < b.length; c++) {\n          var e = b[c].set;\n          e && e.setAttr(\"opacity\", a);\n        }\n      }\n\n      (b = this.bulletSet) && b.setAttr(\"opacity\", a);\n    },\n    destroy: function () {\n      d.remove(this.set);\n      d.remove(this.bulletSet);\n      var a = this.timeOuts;\n\n      if (a) {\n        var b;\n\n        for (b = 0; b < a.length; b++) clearTimeout(a[b]);\n      }\n\n      this.timeOuts = [];\n    },\n    createBalloon: function () {\n      var a = this.chart;\n      this.balloon ? this.balloon.destroy && this.balloon.destroy() : this.balloon = {};\n      var b = this.balloon;\n      d.extend(b, a.balloon, !0);\n      b.chart = a;\n      b.mainSet = a.plotBalloonsSet;\n      b.className = this.id;\n    },\n    hideBalloon: function () {\n      var a = this,\n          b = a.chart;\n      b.chartCursor ? b.chartCursor.valueBalloonsEnabled || b.hideBalloon() : b.hideBalloon();\n      clearTimeout(a.hoverInt);\n      a.hoverInt = setTimeout(function () {\n        a.hideBalloonReal.call(a);\n      }, b.hideBalloonTime);\n    },\n    hideBalloonReal: function () {\n      this.balloon && this.balloon.hide();\n      this.fixBulletSize();\n    },\n    fixBulletSize: function () {\n      if (d.isModern) {\n        var a = this.resizedDItem;\n\n        if (a) {\n          var b = a.bulletGraphics;\n\n          if (b && !b.doNotScale) {\n            b.translate(a.bx, a.by, 1);\n            var c = this.bulletAlpha;\n            isNaN(a.alpha) || (c = a.alpha);\n            b.setAttr(\"fill-opacity\", c);\n            b.setAttr(\"stroke-opacity\", this.bulletBorderAlpha);\n          }\n        }\n\n        this.resizedDItem = null;\n      }\n    },\n    showGraphBalloon: function (a, b, c, e, h) {\n      if (a) {\n        var f = this.chart,\n            g = this.balloon,\n            k = 0,\n            l = 0,\n            m = f.chartCursor,\n            p = !0;\n        m ? m.valueBalloonsEnabled || (g = f.balloon, k = this.x, l = this.y, p = !1) : (g = f.balloon, k = this.x, l = this.y, p = !1);\n        clearTimeout(this.hoverInt);\n\n        if (f.chartCursor && (this.currentDataItem = a, \"serial\" == f.type && f.isRolledOverBullet && f.chartCursor.valueBalloonsEnabled)) {\n          this.hideBalloonReal();\n          return;\n        }\n\n        this.resizeBullet(a, e, h);\n\n        if (g && g.enabled && this.showBalloon && !this.hidden) {\n          var m = f.formatString(this.balloonText, a, !0),\n              q = this.balloonFunction;\n          q && (m = q(a, a.graph));\n          m && (m = d.cleanFromEmpty(m));\n          m && \"\" !== m ? (e = f.getBalloonColor(this, a), g.drop || (g.pointerOrientation = b), b = a.x, h = a.y, f.rotate && (b = a.y, h = a.x), b += k, h += l, isNaN(b) || isNaN(h) ? this.hideBalloonReal() : (a = this.width, q = this.height, p && g.setBounds(k, l, a + k, q + l), g.changeColor(e), g.setPosition(b, h), g.fixPrevious(), g.fixedPosition && (c = !1), !c && \"radar\" != f.type && (b < k - .5 || b > a + k || h < l - .5 || h > q + l) ? (g.showBalloon(m), g.hide(0)) : (g.followCursor(c), g.showBalloon(m)))) : (this.hideBalloonReal(), g.hide(), this.resizeBullet(a, e, h));\n        } else this.hideBalloonReal();\n      }\n    },\n    resizeBullet: function (a, b, c) {\n      this.fixBulletSize();\n\n      if (a && d.isModern && (1 != b || !isNaN(c))) {\n        var e = a.bulletGraphics;\n        e && !e.doNotScale && (e.translate(a.bx, a.by, b), isNaN(c) || (e.setAttr(\"fill-opacity\", c), e.setAttr(\"stroke-opacity\", c)), this.resizedDItem = a);\n      }\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.ChartCursor = d.Class({\n    construct: function (a) {\n      this.cname = \"ChartCursor\";\n      this.createEvents(\"changed\", \"zoomed\", \"onHideCursor\", \"onShowCursor\", \"draw\", \"selected\", \"moved\", \"panning\", \"zoomStarted\");\n      this.enabled = !0;\n      this.cursorAlpha = 1;\n      this.selectionAlpha = .2;\n      this.cursorColor = \"#CC0000\";\n      this.categoryBalloonAlpha = 1;\n      this.color = \"#FFFFFF\";\n      this.type = \"cursor\";\n      this.zoomed = !1;\n      this.zoomable = !0;\n      this.pan = !1;\n      this.categoryBalloonDateFormat = \"MMM DD, YYYY\";\n      this.categoryBalloonText = \"[[category]]\";\n      this.categoryBalloonEnabled = this.valueBalloonsEnabled = !0;\n      this.rolledOver = !1;\n      this.cursorPosition = \"middle\";\n      this.bulletsEnabled = this.skipZoomDispatch = !1;\n      this.bulletSize = 8;\n      this.selectWithoutZooming = this.oneBalloonOnly = !1;\n      this.graphBulletSize = 1.7;\n      this.animationDuration = .3;\n      this.zooming = !1;\n      this.adjustment = 0;\n      this.avoidBalloonOverlapping = !0;\n      this.leaveCursor = !1;\n      this.leaveAfterTouch = !0;\n      this.valueZoomable = !1;\n      this.balloonPointerOrientation = \"horizontal\";\n      this.hLineEnabled = this.vLineEnabled = !0;\n      this.vZoomEnabled = this.hZoomEnabled = !1;\n      d.applyTheme(this, a, this.cname);\n    },\n    draw: function () {\n      this.destroy();\n      var a = this.chart;\n      a.panRequired = !0;\n      var b = a.container;\n      this.rotate = a.rotate;\n      this.container = b;\n      this.prevLineHeight = this.prevLineWidth = NaN;\n      b = b.set();\n      b.translate(this.x, this.y);\n      this.set = b;\n      a.cursorSet.push(b);\n      this.createElements();\n      d.isString(this.limitToGraph) && (this.limitToGraph = d.getObjById(a.graphs, this.limitToGraph), this.fullWidth = !1, this.cursorPosition = \"middle\");\n      this.pointer = this.balloonPointerOrientation.substr(0, 1).toUpperCase();\n      this.isHidden = !1;\n      this.hideLines();\n      this.valueLineAxis || (this.valueLineAxis = a.valueAxes[0]);\n    },\n    createElements: function () {\n      var a = this,\n          b = a.chart,\n          c = b.dx,\n          e = b.dy,\n          h = a.width,\n          f = a.height,\n          g,\n          k,\n          l = a.cursorAlpha,\n          m = a.valueLineAlpha;\n      a.rotate ? (g = m, k = l) : (k = m, g = l);\n      \"xy\" == b.type && (k = l, void 0 !== m && (k = m), g = l);\n      a.vvLine = d.line(a.container, [c, 0, 0], [e, 0, f], a.cursorColor, g, 1);\n      d.setCN(b, a.vvLine, \"cursor-line\");\n      d.setCN(b, a.vvLine, \"cursor-line-vertical\");\n      a.hhLine = d.line(a.container, [0, h, h + c], [0, 0, e], a.cursorColor, k, 1);\n      d.setCN(b, a.hhLine, \"cursor-line\");\n      d.setCN(b, a.hhLine, \"cursor-line-horizontal\");\n      a.vLine = a.rotate ? a.vvLine : a.hhLine;\n      a.set.push(a.vvLine);\n      a.set.push(a.hhLine);\n      a.set.node.style.pointerEvents = \"none\";\n      a.fullLines = a.container.set();\n      b = b.cursorLineSet;\n      b.push(a.fullLines);\n      b.translate(a.x, a.y);\n      b.clipRect(-1, -1, h + 2, f + 2);\n      void 0 !== a.tabIndex && (b.setAttr(\"tabindex\", a.tabIndex), b.keyup(function (b) {\n        a.handleKeys(b);\n      }).focus(function (b) {\n        a.showCursor();\n      }).blur(function (b) {\n        a.hideCursor();\n      }));\n      a.set.clipRect(0, 0, h, f);\n    },\n    handleKeys: function (a) {\n      var b = this.prevIndex,\n          c = this.chart;\n\n      if (c) {\n        var e = c.chartData;\n        e && (isNaN(b) && (b = e.length - 1), 37 != a.keyCode && 40 != a.keyCode || b--, 39 != a.keyCode && 38 != a.keyCode || b++, b = d.fitToBounds(b, c.startIndex, c.endIndex), (a = this.chart.chartData[b]) && this.setPosition(a.x.categoryAxis), this.prevIndex = b);\n      }\n    },\n    update: function () {\n      var a = this.chart;\n\n      if (a) {\n        var b = a.mouseX - this.x,\n            c = a.mouseY - this.y;\n        this.mouseX = b;\n        this.mouseY = c;\n        this.mouse2X = a.mouse2X - this.x;\n        this.mouse2Y = a.mouse2Y - this.y;\n        var e;\n\n        if (a.chartData && 0 < a.chartData.length) {\n          this.mouseIsOver() ? (this.hideGraphBalloons = !1, this.rolledOver = e = !0, this.updateDrawing(), this.vvLine && isNaN(this.fx) && (a.rotate || !this.limitToGraph) && this.vvLine.translate(b, 0), !this.hhLine || !isNaN(this.fy) || a.rotate && this.limitToGraph || this.hhLine.translate(0, c), isNaN(this.mouse2X) ? this.dispatchMovedEvent(b, c) : e = !1) : this.forceShow || this.hideCursor();\n\n          if (this.zooming) {\n            if (!isNaN(this.mouse2X)) {\n              isNaN(this.mouse2X0) || this.dispatchPanEvent();\n              return;\n            }\n\n            if (this.pan) {\n              this.dispatchPanEvent();\n              return;\n            }\n\n            (this.hZoomEnabled || this.vZoomEnabled) && this.zooming && this.updateSelection();\n          }\n\n          e && this.showCursor();\n        }\n      }\n    },\n    updateDrawing: function () {\n      this.drawing && this.chart.setMouseCursor(\"crosshair\");\n\n      if (this.drawingNow && (d.remove(this.drawingLine), 1 < Math.abs(this.drawStartX - this.mouseX) || 1 < Math.abs(this.drawStartY - this.mouseY))) {\n        var a = this.chart,\n            b = a.marginTop,\n            a = a.marginLeft;\n        this.drawingLine = d.line(this.container, [this.drawStartX + a, this.mouseX + a], [this.drawStartY + b, this.mouseY + b], this.cursorColor, 1, 1);\n      }\n    },\n    fixWidth: function (a) {\n      if (this.fullWidth && this.prevLineWidth != a) {\n        var b = this.vvLine,\n            c = 0;\n        b && (b.remove(), c = b.x);\n        b = this.container.set();\n        b.translate(c, 0);\n        c = d.rect(this.container, a, this.height, this.cursorColor, this.cursorAlpha, this.cursorAlpha, this.cursorColor);\n        d.setCN(this.chart, c, \"cursor-fill\");\n        c.translate(-a / 2 - 1, 0);\n        b.push(c);\n        this.vvLine = b;\n        this.fullLines.push(b);\n        this.prevLineWidth = a;\n      }\n    },\n    fixHeight: function (a) {\n      if (this.fullWidth && this.prevLineHeight != a) {\n        var b = this.hhLine,\n            c = 0;\n        b && (b.remove(), c = b.y);\n        b = this.container.set();\n        b.translate(0, c);\n        c = d.rect(this.container, this.width, a, this.cursorColor, this.cursorAlpha);\n        c.translate(0, -a / 2);\n        b.push(c);\n        this.fullLines.push(b);\n        this.hhLine = b;\n        this.prevLineHeight = a;\n      }\n    },\n    fixVLine: function (a, b) {\n      if (!isNaN(a)) {\n        if (isNaN(this.prevLineX)) {\n          var c = 0,\n              e = this.mouseX;\n\n          if (this.limitToGraph) {\n            var d = this.chart.categoryAxis;\n            d && (this.chart.rotate || (c = \"bottom\" == d.position ? this.height : -this.height), e = a);\n          }\n\n          this.vvLine.translate(e, c);\n        } else this.prevLineX != a && this.vvLine.translate(this.prevLineX, this.prevLineY);\n\n        this.fx = a;\n        this.prevLineX != a && (c = this.animationDuration, this.zooming && (c = 0), this.vvLine.stop(), this.vvLine.animate({\n          translate: a + \",\" + b\n        }, c, \"easeOutSine\"), this.prevLineX = a, this.prevLineY = b);\n      }\n    },\n    fixHLine: function (a, b) {\n      if (!isNaN(a)) {\n        if (isNaN(this.prevLineY)) {\n          var c = 0,\n              e = this.mouseY;\n\n          if (this.limitToGraph) {\n            var d = this.chart.categoryAxis;\n            d && (this.chart.rotate && (c = \"right\" == d.position ? this.width : -this.width), e = a);\n          }\n\n          this.hhLine.translate(c, e);\n        } else this.prevLineY != a && this.hhLine.translate(this.prevLineX, this.prevLineY);\n\n        this.fy = a;\n        this.prevLineY != a && (c = this.animationDuration, this.zooming && (c = 0), this.hhLine.stop(), this.hhLine.animate({\n          translate: b + \",\" + a\n        }, c, \"easeOutSine\"), this.prevLineY = a, this.prevLineX = b);\n      }\n    },\n    hideCursor: function (a) {\n      this.forceShow = !1;\n      this.chart.wasTouched && this.leaveAfterTouch || this.isHidden || this.leaveCursor || (this.hideCursorReal(), a ? this.chart.handleCursorHide() : this.fire({\n        target: this,\n        chart: this.chart,\n        type: \"onHideCursor\"\n      }), this.chart.setMouseCursor(\"auto\"));\n    },\n    hideCursorReal: function () {\n      this.hideLines();\n      this.isHidden = !0;\n      this.index = this.prevLineY = this.prevLineX = this.mouseY0 = this.mouseX0 = this.fy = this.fx = NaN;\n    },\n    hideLines: function () {\n      this.vvLine && this.vvLine.hide();\n      this.hhLine && this.hhLine.hide();\n      this.fullLines && this.fullLines.hide();\n      this.isHidden = !0;\n      this.chart.handleCursorHide();\n    },\n    showCursor: function (a) {\n      !this.drawing && this.enabled && (this.vLineEnabled && this.vvLine && this.vvLine.show(), this.hLineEnabled && this.hhLine && this.hhLine.show(), this.isHidden = !1, this.updateFullLine(), a || this.fire({\n        target: this,\n        chart: this.chart,\n        type: \"onShowCursor\"\n      }), this.pan && this.chart.setMouseCursor(\"move\"));\n    },\n    updateFullLine: function () {\n      this.zooming && this.fullWidth && this.selection && (this.rotate ? 0 < this.selection.height && this.hhLine.hide() : 0 < this.selection.width && this.vvLine.hide());\n    },\n    updateSelection: function () {\n      if (!this.pan && this.enabled) {\n        var a = this.mouseX,\n            b = this.mouseY;\n        isNaN(this.fx) || (a = this.fx);\n        isNaN(this.fy) || (b = this.fy);\n        this.clearSelection();\n        var c = this.mouseX0,\n            e = this.mouseY0,\n            h = this.width,\n            f = this.height,\n            a = d.fitToBounds(a, 0, h),\n            b = d.fitToBounds(b, 0, f),\n            g;\n        a < c && (g = a, a = c, c = g);\n        b < e && (g = b, b = e, e = g);\n        this.hZoomEnabled ? h = a - c : c = 0;\n        this.vZoomEnabled ? f = b - e : e = 0;\n        isNaN(this.mouse2X) && 0 < Math.abs(h) && 0 < Math.abs(f) && (a = this.chart, b = d.rect(this.container, h, f, this.cursorColor, this.selectionAlpha), d.setCN(a, b, \"cursor-selection\"), b.width = h, b.height = f, b.translate(c, e), this.set.push(b), this.selection = b);\n        this.updateFullLine();\n      }\n    },\n    mouseIsOver: function () {\n      var a = this.mouseX,\n          b = this.mouseY;\n      if (this.justReleased) return this.justReleased = !1, !0;\n      if (this.mouseIsDown) return !0;\n      if (!this.chart.mouseIsOver) return this.handleMouseOut(), !1;\n      if (0 < a && a < this.width && 0 < b && b < this.height) return !0;\n      this.handleMouseOut();\n    },\n    fixPosition: function () {\n      this.prevY = this.prevX = NaN;\n    },\n    handleMouseDown: function () {\n      this.update();\n      if (this.mouseIsOver()) if (this.mouseIsDown = !0, this.mouseX0 = this.mouseX, this.mouseY0 = this.mouseY, this.mouse2X0 = this.mouse2X, this.mouse2Y0 = this.mouse2Y, this.drawing) this.drawStartY = this.mouseY, this.drawStartX = this.mouseX, this.drawingNow = !0;else if (this.dispatchMovedEvent(this.mouseX, this.mouseY), !this.pan && isNaN(this.mouse2X0) && (isNaN(this.fx) || (this.mouseX0 = this.fx), isNaN(this.fy) || (this.mouseY0 = this.fy)), this.hZoomEnabled || this.vZoomEnabled) {\n        this.zooming = !0;\n        var a = {\n          chart: this.chart,\n          target: this,\n          type: \"zoomStarted\"\n        };\n        a.x = this.mouseX / this.width;\n        a.y = this.mouseY / this.height;\n        this.index0 = a.index = this.index;\n        this.timestamp0 = this.timestamp;\n        this.fire(a);\n      }\n    },\n    registerInitialMouse: function () {},\n    handleReleaseOutside: function () {\n      this.mouseIsDown = !1;\n\n      if (this.drawingNow) {\n        this.drawingNow = !1;\n        d.remove(this.drawingLine);\n        var a = this.drawStartX,\n            b = this.drawStartY,\n            c = this.mouseX,\n            e = this.mouseY,\n            h = this.chart;\n        (2 < Math.abs(a - c) || 2 < Math.abs(b - e)) && this.fire({\n          type: \"draw\",\n          target: this,\n          chart: h,\n          initialX: a,\n          initialY: b,\n          finalX: c,\n          finalY: e\n        });\n      }\n\n      this.zooming && (this.zooming = !1, this.selectWithoutZooming ? this.dispatchZoomEvent(\"selected\") : (this.hZoomEnabled || this.vZoomEnabled) && this.dispatchZoomEvent(\"zoomed\"), this.rolledOver && this.dispatchMovedEvent(this.mouseX, this.mouseY));\n      this.mouse2Y0 = this.mouse2X0 = this.mouseY0 = this.mouseX0 = NaN;\n    },\n    dispatchZoomEvent: function (a) {\n      if (!this.pan) {\n        var b = this.selection;\n\n        if (b && 3 < Math.abs(b.width) && 3 < Math.abs(b.height)) {\n          var c = Math.min(this.index, this.index0),\n              e = Math.max(this.index, this.index0),\n              d = c,\n              f = e,\n              g = this.chart,\n              k = g.chartData,\n              l = g.categoryAxis;\n          l && l.parseDates && !l.equalSpacing && (d = k[c] ? k[c].time : Math.min(this.timestamp0, this.timestamp), f = k[e] ? g.getEndTime(k[e].time) : Math.max(this.timestamp0, this.timestamp));\n          var b = {\n            type: a,\n            chart: this.chart,\n            target: this,\n            end: f,\n            start: d,\n            startIndex: c,\n            endIndex: e,\n            selectionHeight: b.height,\n            selectionWidth: b.width,\n            selectionY: b.y,\n            selectionX: b.x\n          },\n              m;\n          this.hZoomEnabled && 4 < Math.abs(this.mouseX0 - this.mouseX) && (b.startX = this.mouseX0 / this.width, b.endX = this.mouseX / this.width, m = !0);\n          this.vZoomEnabled && 4 < Math.abs(this.mouseY0 - this.mouseY) && (b.startY = 1 - this.mouseY0 / this.height, b.endY = 1 - this.mouseY / this.height, m = !0);\n          m && (this.prevY = this.prevX = NaN, this.fire(b), \"selected\" != a && this.clearSelection());\n          this.hideCursor();\n        }\n      }\n    },\n    dispatchMovedEvent: function (a, b, c, e) {\n      a = Math.round(a);\n      b = Math.round(b);\n\n      if (!this.isHidden && (a != this.prevX || b != this.prevY || \"changed\" == c)) {\n        c || (c = \"moved\");\n        var d = this.fx,\n            f = this.fy;\n        isNaN(d) && (d = a);\n        isNaN(f) && (f = b);\n        var g = !1;\n        this.zooming && this.pan && (g = !0);\n        g = {\n          hidden: this.isHidden,\n          type: c,\n          chart: this.chart,\n          target: this,\n          x: a,\n          y: b,\n          finalX: d,\n          finalY: f,\n          zooming: this.zooming,\n          panning: g,\n          mostCloseGraph: this.mostCloseGraph,\n          index: this.index,\n          skip: e,\n          hideBalloons: this.hideGraphBalloons\n        };\n        this.prevIndex = this.index;\n        this.rotate ? (g.position = b, g.finalPosition = f) : (g.position = a, g.finalPosition = d);\n        this.prevX = a;\n        this.prevY = b;\n        e ? this.chart.handleCursorMove(g) : (this.fire(g), \"changed\" == c && this.chart.fire(g));\n      }\n    },\n    dispatchPanEvent: function () {\n      if (this.mouseIsDown) {\n        var a = d.roundTo((this.mouseX - this.mouseX0) / this.width, 3),\n            b = d.roundTo((this.mouseY - this.mouseY0) / this.height, 3),\n            c = d.roundTo((this.mouse2X - this.mouse2X0) / this.width, 3),\n            e = d.roundTo((this.mouse2Y - this.mouse2Y0) / this.height, 2),\n            h = !1;\n        0 !== Math.abs(a) && 0 !== Math.abs(b) && (h = !0);\n        if (this.prevDeltaX == a || this.prevDeltaY == b) h = !1;\n        isNaN(c) || isNaN(e) || (0 !== Math.abs(c) && 0 !== Math.abs(e) && (h = !0), this.prevDelta2X != c && this.prevDelta2Y != e) || (h = !1);\n        h && (this.hideLines(), this.fire({\n          type: \"panning\",\n          chart: this.chart,\n          target: this,\n          deltaX: a,\n          deltaY: b,\n          delta2X: c,\n          delta2Y: e,\n          index: this.index\n        }), this.prevDeltaX = a, this.prevDeltaY = b, this.prevDelta2X = c, this.prevDelta2Y = e);\n      }\n    },\n    clearSelection: function () {\n      var a = this.selection;\n      a && (a.width = 0, a.height = 0, a.remove());\n    },\n    destroy: function () {\n      this.clear();\n      d.remove(this.selection);\n      this.selection = null;\n      clearTimeout(this.syncTO);\n      d.remove(this.set);\n    },\n    clear: function () {},\n    setTimestamp: function (a) {\n      this.timestamp = a;\n    },\n    setIndex: function (a, b) {\n      a != this.index && (this.index = a, b || this.isHidden || this.dispatchMovedEvent(this.mouseX, this.mouseY, \"changed\"));\n    },\n    handleMouseOut: function () {\n      this.enabled && this.rolledOver && (this.leaveCursor || this.setIndex(void 0), this.forceShow = !1, this.hideCursor(), this.rolledOver = !1);\n    },\n    showCursorAt: function (a) {\n      var b = this.chart.categoryAxis;\n      b && this.setPosition(b.categoryToCoordinate(a), a);\n    },\n    setPosition: function (a, b) {\n      var c = this.chart,\n          e = c.categoryAxis;\n\n      if (e) {\n        var d, f;\n        void 0 === b && (b = e.coordinateToValue(a));\n        e.showBalloonAt(b, a);\n        this.forceShow = !0;\n        e.stickBalloonToCategory ? c.rotate ? this.fixHLine(a, 0) : this.fixVLine(a, 0) : (this.showCursor(), c.rotate ? this.hhLine.translate(0, a) : this.vvLine.translate(a, 0));\n        c.rotate ? d = a : f = a;\n        c.rotate ? (this.vvLine && this.vvLine.hide(), this.hhLine && this.hhLine.show()) : (this.hhLine && this.hhLine.hide(), this.vvLine && this.vvLine.show());\n        this.updateFullLine();\n        this.isHidden = !1;\n        this.dispatchMovedEvent(f, d, \"moved\", !0);\n      }\n    },\n    enableDrawing: function (a) {\n      this.enabled = !a;\n      this.hideCursor();\n      this.drawing = a;\n    },\n    syncWithCursor: function (a, b) {\n      clearTimeout(this.syncTO);\n      a && (a.isHidden ? this.hideCursor(!0) : this.syncWithCursorReal(a, b));\n    },\n    isZooming: function (a) {\n      this.zooming = a;\n    },\n    syncWithCursorReal: function (a, b) {\n      var c = a.vvLine,\n          e = a.hhLine;\n      this.index = a.index;\n      this.forceShow = !0;\n      this.zooming && this.pan || this.showCursor(!0);\n      this.hideGraphBalloons = b;\n      this.justReleased = a.justReleased;\n      this.zooming = a.zooming;\n      this.index0 = a.index0;\n      this.mouseX0 = a.mouseX0;\n      this.mouseY0 = a.mouseY0;\n      this.mouse2X0 = a.mouse2X0;\n      this.mouse2Y0 = a.mouse2Y0;\n      this.timestamp0 = a.timestamp0;\n      this.prevDeltaX = a.prevDeltaX;\n      this.prevDeltaY = a.prevDeltaY;\n      this.prevDelta2X = a.prevDelta2X;\n      this.prevDelta2Y = a.prevDelta2Y;\n      this.fx = a.fx;\n      this.fy = a.fy;\n      a.zooming && this.updateSelection();\n      var d = a.mouseX,\n          f = a.mouseY;\n      this.rotate ? (d = NaN, this.vvLine && this.vvLine.hide(), this.hhLine && e && (isNaN(a.fy) ? this.hhLine.translate(0, a.mouseY) : this.fixHLine(a.fy, 0))) : (f = NaN, this.hhLine && this.hhLine.hide(), this.vvLine && c && (isNaN(a.fx) ? this.vvLine.translate(a.mouseX, 0) : this.fixVLine(a.fx, 0)));\n      this.dispatchMovedEvent(d, f, \"moved\", !0);\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.SimpleChartScrollbar = d.Class({\n    construct: function (a) {\n      this.createEvents(\"zoomed\", \"zoomStarted\", \"zoomEnded\");\n      this.backgroundColor = \"#D4D4D4\";\n      this.backgroundAlpha = 1;\n      this.selectedBackgroundColor = \"#EFEFEF\";\n      this.scrollDuration = this.selectedBackgroundAlpha = 1;\n      this.resizeEnabled = !0;\n      this.hideResizeGrips = !1;\n      this.scrollbarHeight = 20;\n      this.updateOnReleaseOnly = !1;\n      9 > document.documentMode && (this.updateOnReleaseOnly = !0);\n      this.dragIconHeight = this.dragIconWidth = 35;\n      this.dragIcon = \"dragIconRoundBig\";\n      this.dragCursorHover = \"cursor: move; cursor: grab; cursor: -moz-grab; cursor: -webkit-grab;\";\n      this.dragCursorDown = \"cursor: move; cursor: grab; cursor: -moz-grabbing; cursor: -webkit-grabbing;\";\n      this.vResizeCursor = \"ns-resize\";\n      this.hResizeCursor = \"ew-resize\";\n      this.enabled = !0;\n      this.percentStart = this.offset = 0;\n      this.percentEnd = 1;\n      d.applyTheme(this, a, \"SimpleChartScrollbar\");\n    },\n    getPercents: function () {\n      var a = this.getDBox(),\n          b = a.x,\n          c = a.y,\n          e = a.width,\n          a = a.height;\n      this.rotate ? (b = 1 - c / this.height, c = 1 - (c + a) / this.height) : (c = b / this.width, b = (b + e) / this.width);\n      this.percentStart = c;\n      this.percentEnd = b;\n    },\n    draw: function () {\n      var a = this;\n      a.destroy();\n\n      if (a.enabled) {\n        var b = a.chart.container,\n            c = a.rotate,\n            e = a.chart;\n        e.panRequired = !0;\n        var h = b.set();\n        a.set = h;\n        c ? d.setCN(e, h, \"scrollbar-vertical\") : d.setCN(e, h, \"scrollbar-horizontal\");\n        e.scrollbarsSet.push(h);\n        var f, g;\n        c ? (f = a.scrollbarHeight, g = e.plotAreaHeight) : (g = a.scrollbarHeight, f = e.plotAreaWidth);\n        a.width = f;\n\n        if ((a.height = g) && f) {\n          var k = d.rect(b, f, g, a.backgroundColor, a.backgroundAlpha, 1, a.backgroundColor, a.backgroundAlpha);\n          d.setCN(e, k, \"scrollbar-bg\");\n          a.bg = k;\n          h.push(k);\n          k = d.rect(b, f, g, \"#000\", .005);\n          h.push(k);\n          a.invisibleBg = k;\n          k.click(function () {\n            a.handleBgClick();\n          }).mouseover(function () {\n            a.handleMouseOver();\n          }).mouseout(function () {\n            a.handleMouseOut();\n          }).touchend(function () {\n            a.handleBgClick();\n          });\n          k = d.rect(b, f, g, a.selectedBackgroundColor, a.selectedBackgroundAlpha);\n          d.setCN(e, k, \"scrollbar-bg-selected\");\n          a.selectedBG = k;\n          h.push(k);\n          f = d.rect(b, f, g, \"#000\", .005);\n          a.dragger = f;\n          h.push(f);\n          f.mousedown(function (b) {\n            a.handleDragStart(b);\n          }).mouseup(function () {\n            a.handleDragStop();\n          }).mouseover(function () {\n            a.handleDraggerOver();\n          }).mouseout(function () {\n            a.handleMouseOut();\n          }).touchstart(function (b) {\n            a.handleDragStart(b);\n          }).touchend(function () {\n            a.handleDragStop();\n          });\n          g = e.pathToImages;\n          var l,\n              k = a.dragIcon.replace(/\\.[a-z]*$/i, \"\");\n          d.isAbsolute(k) && (g = \"\");\n          c ? (l = g + k + \"H\" + e.extension, g = a.dragIconWidth, c = a.dragIconHeight) : (l = g + k + e.extension, c = a.dragIconWidth, g = a.dragIconHeight);\n          k = b.image(l, 0, 0, c, g);\n          d.setCN(e, k, \"scrollbar-grip-left\");\n          l = b.image(l, 0, 0, c, g);\n          d.setCN(e, l, \"scrollbar-grip-right\");\n          var m = 10,\n              p = 20;\n          e.panEventsEnabled && (m = 25, p = a.scrollbarHeight);\n          var q = d.rect(b, m, p, \"#000\", .005),\n              n = d.rect(b, m, p, \"#000\", .005);\n          n.translate(-(m - c) / 2, -(p - g) / 2);\n          q.translate(-(m - c) / 2, -(p - g) / 2);\n          c = b.set([k, n]);\n          b = b.set([l, q]);\n          a.iconLeft = c;\n          h.push(a.iconLeft);\n          a.iconRight = b;\n          h.push(b);\n          a.updateGripCursor(!1);\n          e.makeAccessible(c, a.accessibleLabel);\n          e.makeAccessible(b, a.accessibleLabel);\n          e.makeAccessible(f, a.accessibleLabel);\n          c.setAttr(\"role\", \"menuitem\");\n          b.setAttr(\"role\", \"menuitem\");\n          f.setAttr(\"role\", \"menuitem\");\n          void 0 !== a.tabIndex && (c.setAttr(\"tabindex\", a.tabIndex), c.keyup(function (b) {\n            a.handleKeys(b, 1, 0);\n          }));\n          void 0 !== a.tabIndex && (f.setAttr(\"tabindex\", a.tabIndex), f.keyup(function (b) {\n            a.handleKeys(b, 1, 1);\n          }));\n          void 0 !== a.tabIndex && (b.setAttr(\"tabindex\", a.tabIndex), b.keyup(function (b) {\n            a.handleKeys(b, 0, 1);\n          }));\n          c.mousedown(function () {\n            a.leftDragStart();\n          }).mouseup(function () {\n            a.leftDragStop();\n          }).mouseover(function () {\n            a.iconRollOver();\n          }).mouseout(function () {\n            a.iconRollOut();\n          }).touchstart(function () {\n            a.leftDragStart();\n          }).touchend(function () {\n            a.leftDragStop();\n          });\n          b.mousedown(function () {\n            a.rightDragStart();\n          }).mouseup(function () {\n            a.rightDragStop();\n          }).mouseover(function () {\n            a.iconRollOver();\n          }).mouseout(function () {\n            a.iconRollOut();\n          }).touchstart(function () {\n            a.rightDragStart();\n          }).touchend(function () {\n            a.rightDragStop();\n          });\n          d.ifArray(e.chartData) ? h.show() : h.hide();\n          a.hideDragIcons();\n          a.clipDragger(!1);\n        }\n\n        h.translate(a.x, a.y);\n        h.node.style.msTouchAction = \"none\";\n        h.node.style.touchAction = \"none\";\n      }\n    },\n    handleKeys: function (a, b, c) {\n      this.getPercents();\n      var e = this.percentStart,\n          d = this.percentEnd;\n      if (this.rotate) var f = d,\n          d = e,\n          e = f;\n      if (37 == a.keyCode || 40 == a.keyCode) e -= .02 * b, d -= .02 * c;\n      if (39 == a.keyCode || 38 == a.keyCode) e += .02 * b, d += .02 * c;\n      this.rotate && (a = d, d = e, e = a);\n      isNaN(d) || isNaN(e) || this.percentZoom(e, d, !0);\n    },\n    updateScrollbarSize: function (a, b) {\n      if (!isNaN(a) && !isNaN(b)) {\n        a = Math.round(a);\n        b = Math.round(b);\n        var c = this.dragger,\n            e,\n            d,\n            f,\n            g,\n            k;\n        this.rotate ? (e = 0, d = a, f = this.width + 1, g = b - a, c.setAttr(\"height\", b - a), c.setAttr(\"y\", d)) : (e = a, d = 0, f = b - a, g = this.height + 1, k = b - a, c.setAttr(\"x\", e), c.setAttr(\"width\", k));\n        this.clipAndUpdate(e, d, f, g);\n      }\n    },\n    update: function () {\n      var a,\n          b = !1,\n          c,\n          e,\n          d = this.x,\n          f = this.y,\n          g = this.dragger,\n          k = this.getDBox();\n\n      if (k) {\n        c = k.x + d;\n        e = k.y + f;\n        var l = k.width,\n            k = k.height,\n            m = this.rotate,\n            p = this.chart,\n            q = this.width,\n            n = this.height,\n            t = p.mouseX,\n            p = p.mouseY;\n        a = this.initialMouse;\n        this.forceClip && this.clipDragger(!0);\n\n        if (this.dragging) {\n          var r = this.initialCoord;\n          m ? (a = r + (p - a), 0 > a && (a = 0), r = n - k, a > r && (a = r), g.setAttr(\"y\", a)) : (a = r + (t - a), 0 > a && (a = 0), r = q - l, a > r && (a = r), g.setAttr(\"x\", a));\n          this.clipDragger(!0);\n        }\n\n        if (this.resizingRight) {\n          if (m) {\n            if (a = p - e, !isNaN(this.maxHeight) && a > this.maxHeight && (a = this.maxHeight), a + e > n + f && (a = n - e + f), 0 > a) this.resizingRight = !1, b = this.resizingLeft = !0;else {\n              if (0 === a || isNaN(a)) a = .1;\n              g.setAttr(\"height\", a);\n            }\n          } else if (a = t - c, !isNaN(this.maxWidth) && a > this.maxWidth && (a = this.maxWidth), a + c > q + d && (a = q - c + d), 0 > a) this.resizingRight = !1, b = this.resizingLeft = !0;else {\n            if (0 === a || isNaN(a)) a = .1;\n            g.setAttr(\"width\", a);\n          }\n          this.clipDragger(!0);\n        }\n\n        if (this.resizingLeft) {\n          if (m) {\n            if (c = e, e = p, e < f && (e = f), isNaN(e) && (e = f), e > n + f && (e = n + f), a = !0 === b ? c - e : k + c - e, !isNaN(this.maxHeight) && a > this.maxHeight && (a = this.maxHeight, e = c), 0 > a) this.resizingRight = !0, this.resizingLeft = !1, g.setAttr(\"y\", c + k - f);else {\n              if (0 === a || isNaN(a)) a = .1;\n              g.setAttr(\"y\", e - f);\n              g.setAttr(\"height\", a);\n            }\n          } else if (e = t, e < d && (e = d), isNaN(e) && (e = d), e > q + d && (e = q + d), a = !0 === b ? c - e : l + c - e, !isNaN(this.maxWidth) && a > this.maxWidth && (a = this.maxWidth, e = c), 0 > a) this.resizingRight = !0, this.resizingLeft = !1, g.setAttr(\"x\", c + l - d);else {\n            if (0 === a || isNaN(a)) a = .1;\n            g.setAttr(\"x\", e - d);\n            g.setAttr(\"width\", a);\n          }\n          this.clipDragger(!0);\n        }\n      }\n    },\n    stopForceClip: function () {\n      this.animating = this.forceClip = !1;\n    },\n    clipDragger: function (a) {\n      var b = this.getDBox();\n\n      if (b) {\n        var c = b.x,\n            e = b.y,\n            d = b.width,\n            b = b.height,\n            f = !1;\n\n        if (this.rotate) {\n          if (c = 0, d = this.width + 1, this.clipY != e || this.clipH != b) f = !0;\n        } else if (e = 0, b = this.height + 1, this.clipX != c || this.clipW != d) f = !0;\n\n        f && (this.clipAndUpdate(c, e, d, b), a && (this.updateOnReleaseOnly || this.dispatchScrollbarEvent()));\n      }\n    },\n    maskGraphs: function () {},\n    clipAndUpdate: function (a, b, c, d) {\n      this.clipX = a;\n      this.clipY = b;\n      this.clipW = c;\n      this.clipH = d;\n      this.selectedBG.setAttr(\"width\", c);\n      this.selectedBG.setAttr(\"height\", d);\n      this.selectedBG.translate(a, b);\n      this.updateDragIconPositions();\n      this.maskGraphs(a, b, c, d);\n    },\n    dispatchScrollbarEvent: function () {\n      if (this.skipEvent) this.skipEvent = !1;else {\n        var a = this.chart;\n        a.hideBalloon();\n        var b = this.getDBox(),\n            c = b.x,\n            d = b.y,\n            h = b.width,\n            b = b.height;\n        this.getPercents();\n        this.rotate ? (c = d, h = this.height / b) : h = this.width / h;\n        this.fire({\n          type: \"zoomed\",\n          position: c,\n          chart: a,\n          target: this,\n          multiplier: h,\n          relativeStart: this.percentStart,\n          relativeEnd: this.percentEnd\n        });\n      }\n    },\n    updateDragIconPositions: function () {\n      var a = this.getDBox(),\n          b = a.x,\n          c = a.y,\n          d = this.iconLeft,\n          h = this.iconRight,\n          f,\n          g,\n          k = this.scrollbarHeight;\n      this.rotate ? (f = this.dragIconWidth, g = this.dragIconHeight, d.translate((k - g) / 2, c - f / 2), h.translate((k - g) / 2, c + a.height - f / 2)) : (f = this.dragIconHeight, g = this.dragIconWidth, d.translate(b - g / 2, (k - f) / 2), h.translate(b - g / 2 + a.width, (k - f) / 2));\n    },\n    showDragIcons: function () {\n      this.resizeEnabled && (this.iconLeft.show(), this.iconRight.show());\n    },\n    hideDragIcons: function () {\n      if (!this.resizingLeft && !this.resizingRight && !this.dragging) {\n        if (this.hideResizeGrips || !this.resizeEnabled) this.iconLeft.hide(), this.iconRight.hide();\n        this.removeCursors();\n      }\n    },\n    removeCursors: function () {\n      this.chart.setMouseCursor(\"auto\");\n    },\n    fireZoomEvent: function (a) {\n      this.fire({\n        type: a,\n        chart: this.chart,\n        target: this\n      });\n    },\n    percentZoom: function (a, b, c) {\n      a = d.fitToBounds(a, 0, b);\n      b = d.fitToBounds(b, a, 1);\n\n      if (this.dragger && this.enabled) {\n        this.dragger.stop();\n        isNaN(a) && (a = 0);\n        isNaN(b) && (b = 1);\n        var e, h;\n        this.rotate ? (e = this.height, b = e - e * b, h = e - e * a) : (e = this.width, h = e * b, b = e * a);\n        this.updateScrollbarSize(b, h);\n        this.clipDragger(!1);\n        this.getPercents();\n        c && this.dispatchScrollbarEvent();\n      }\n    },\n    destroy: function () {\n      this.clear();\n      d.remove(this.set);\n      d.remove(this.iconRight);\n      d.remove(this.iconLeft);\n    },\n    clear: function () {},\n    handleDragStart: function () {\n      if (this.enabled) {\n        this.fireZoomEvent(\"zoomStarted\");\n        var a = this.chart;\n        this.dragger.stop();\n        this.removeCursors();\n        d.isModern && (this.dragger.node.style.cssText = this.dragCursorDown);\n        this.dragging = !0;\n        var b = this.getDBox();\n        this.rotate ? (this.initialCoord = b.y, this.initialMouse = a.mouseY) : (this.initialCoord = b.x, this.initialMouse = a.mouseX);\n      }\n    },\n    handleDragStop: function () {\n      this.updateOnReleaseOnly && (this.update(), this.skipEvent = !1, this.dispatchScrollbarEvent());\n      this.dragging = !1;\n      this.mouseIsOver && this.removeCursors();\n      d.isModern && (this.dragger.node.style.cssText = this.dragCursorHover);\n      this.update();\n      this.fireZoomEvent(\"zoomEnded\");\n    },\n    handleDraggerOver: function () {\n      this.handleMouseOver();\n      d.isModern && (this.dragger.node.style.cssText = this.dragCursorHover);\n    },\n    leftDragStart: function () {\n      this.fireZoomEvent(\"zoomStarted\");\n      this.dragger.stop();\n      this.resizingLeft = !0;\n      this.updateGripCursor(!0);\n    },\n    updateGripCursor: function (a) {\n      d.isModern && (a = this.rotate ? a ? this.vResizeCursorDown : this.vResizeCursorHover : a ? this.hResizeCursorDown : this.hResizeCursorHover) && (this.iconRight && (this.iconRight.node.style.cssText = a), this.iconLeft && (this.iconLeft.node.style.cssText = a));\n    },\n    leftDragStop: function () {\n      this.resizingLeft && (this.resizingLeft = !1, this.mouseIsOver || this.removeCursors(), this.updateOnRelease(), this.fireZoomEvent(\"zoomEnded\"));\n      this.updateGripCursor(!1);\n    },\n    rightDragStart: function () {\n      this.fireZoomEvent(\"zoomStarted\");\n      this.dragger.stop();\n      this.resizingRight = !0;\n      this.updateGripCursor(!0);\n    },\n    rightDragStop: function () {\n      this.resizingRight && (this.resizingRight = !1, this.mouseIsOver || this.removeCursors(), this.updateOnRelease(), this.fireZoomEvent(\"zoomEnded\"));\n      this.updateGripCursor(!1);\n    },\n    iconRollOut: function () {\n      this.removeCursors();\n    },\n    iconRollOver: function () {\n      this.rotate ? this.vResizeCursor && this.chart.setMouseCursor(this.vResizeCursor) : this.hResizeCursor && this.chart.setMouseCursor(this.hResizeCursor);\n      this.handleMouseOver();\n    },\n    getDBox: function () {\n      if (this.dragger) return this.dragger.getBBox();\n    },\n    handleBgClick: function () {\n      var a = this;\n\n      if (!a.resizingRight && !a.resizingLeft) {\n        a.zooming = !0;\n        var b,\n            c,\n            e = a.scrollDuration,\n            h = a.dragger;\n        b = a.getDBox();\n        var f = b.height,\n            g = b.width;\n        c = a.chart;\n        var k = a.y,\n            l = a.x,\n            m = a.rotate;\n        m ? (b = \"y\", c = c.mouseY - f / 2 - k, c = d.fitToBounds(c, 0, a.height - f)) : (b = \"x\", c = c.mouseX - g / 2 - l, c = d.fitToBounds(c, 0, a.width - g));\n        a.updateOnReleaseOnly ? (a.skipEvent = !1, h.setAttr(b, c), a.dispatchScrollbarEvent(), a.clipDragger()) : (a.animating = !0, c = Math.round(c), m ? h.animate({\n          y: c\n        }, e, \">\") : h.animate({\n          x: c\n        }, e, \">\"), a.forceClip = !0, clearTimeout(a.forceTO), a.forceTO = setTimeout(function () {\n          a.stopForceClip.call(a);\n        }, 5E3 * e));\n      }\n    },\n    updateOnRelease: function () {\n      this.updateOnReleaseOnly && (this.update(), this.skipEvent = !1, this.dispatchScrollbarEvent());\n    },\n    handleReleaseOutside: function () {\n      if (this.set) {\n        if (this.resizingLeft || this.resizingRight || this.dragging) this.dragging = this.resizingRight = this.resizingLeft = !1, this.updateOnRelease(), this.removeCursors();\n        this.animating = this.mouseIsOver = !1;\n        this.hideDragIcons();\n        this.update();\n      }\n    },\n    handleMouseOver: function () {\n      this.mouseIsOver = !0;\n      this.showDragIcons();\n    },\n    handleMouseOut: function () {\n      this.mouseIsOver = !1;\n      this.hideDragIcons();\n      this.removeCursors();\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.ChartScrollbar = d.Class({\n    inherits: d.SimpleChartScrollbar,\n    construct: function (a) {\n      this.cname = \"ChartScrollbar\";\n      d.ChartScrollbar.base.construct.call(this, a);\n      this.graphLineColor = \"#BBBBBB\";\n      this.graphLineAlpha = 0;\n      this.graphFillColor = \"#BBBBBB\";\n      this.graphFillAlpha = 1;\n      this.selectedGraphLineColor = \"#888888\";\n      this.selectedGraphLineAlpha = 0;\n      this.selectedGraphFillColor = \"#888888\";\n      this.selectedGraphFillAlpha = 1;\n      this.gridCount = 0;\n      this.gridColor = \"#FFFFFF\";\n      this.gridAlpha = .7;\n      this.skipEvent = this.autoGridCount = !1;\n      this.color = \"#FFFFFF\";\n      this.scrollbarCreated = !1;\n      this.oppositeAxis = !0;\n      this.accessibleLabel = \"Zoom chart using cursor arrows\";\n      d.applyTheme(this, a, this.cname);\n    },\n    init: function () {\n      var a = this.categoryAxis,\n          b = this.chart,\n          c = this.gridAxis;\n      a || (\"CategoryAxis\" == this.gridAxis.cname ? (this.catScrollbar = !0, a = new d.CategoryAxis(), a.id = \"scrollbar\") : (a = new d.ValueAxis(), a.data = b.chartData, a.id = c.id, a.type = c.type, a.maximumDate = c.maximumDate, a.minimumDate = c.minimumDate, a.minPeriod = c.minPeriod, a.minMaxField = c.minMaxField), this.categoryAxis = a);\n      a.chart = b;\n      var e = b.categoryAxis;\n      e && (a.firstDayOfWeek = e.firstDayOfWeek);\n      a.dateFormats = c.dateFormats;\n      a.markPeriodChange = c.markPeriodChange;\n      a.boldPeriodBeginning = c.boldPeriodBeginning;\n      a.labelFunction = c.labelFunction;\n      a.axisItemRenderer = d.RecItem;\n      a.axisRenderer = d.RecAxis;\n      a.guideFillRenderer = d.RecFill;\n      a.inside = !0;\n      a.fontSize = this.fontSize;\n      a.tickLength = 0;\n      a.axisAlpha = 0;\n      d.isString(this.graph) && (this.graph = d.getObjById(b.graphs, this.graph));\n      (a = this.graph) && this.catScrollbar && (c = this.valueAxis, c || (this.valueAxis = c = new d.ValueAxis(), c.visible = !1, c.scrollbar = !0, c.axisItemRenderer = d.RecItem, c.axisRenderer = d.RecAxis, c.guideFillRenderer = d.RecFill, c.labelsEnabled = !1, c.chart = b), b = this.unselectedGraph, b || (b = new d.AmGraph(), b.scrollbar = !0, this.unselectedGraph = b, b.negativeBase = a.negativeBase, b.noStepRisers = a.noStepRisers), b = this.selectedGraph, b || (b = new d.AmGraph(), b.scrollbar = !0, this.selectedGraph = b, b.negativeBase = a.negativeBase, b.noStepRisers = a.noStepRisers));\n      this.scrollbarCreated = !0;\n    },\n    draw: function () {\n      var a = this;\n      d.ChartScrollbar.base.draw.call(a);\n\n      if (a.enabled) {\n        a.scrollbarCreated || a.init();\n        var b = a.chart,\n            c = b.chartData,\n            e = a.categoryAxis,\n            h = a.rotate,\n            f = a.x,\n            g = a.y,\n            k = a.width,\n            l = a.height,\n            m = a.gridAxis,\n            p = a.set;\n        e.setOrientation(!h);\n        e.parseDates = m.parseDates;\n        \"ValueAxis\" == a.categoryAxis.cname && (e.rotate = !h);\n        e.equalSpacing = m.equalSpacing;\n        e.minPeriod = m.minPeriod;\n        e.startOnAxis = m.startOnAxis;\n        e.width = k - 1;\n        e.height = l;\n        e.gridCount = a.gridCount;\n        e.gridColor = a.gridColor;\n        e.gridAlpha = a.gridAlpha;\n        e.color = a.color;\n        e.tickLength = 0;\n        e.axisAlpha = 0;\n        e.autoGridCount = a.autoGridCount;\n        e.parseDates && !e.equalSpacing && e.timeZoom(b.firstTime, b.lastTime);\n        e.minimum = a.gridAxis.fullMin;\n        e.maximum = a.gridAxis.fullMax;\n        e.strictMinMax = !0;\n        e.zoom(0, c.length - 1);\n\n        if ((m = a.graph) && a.catScrollbar) {\n          var q = a.valueAxis,\n              n = m.valueAxis;\n          q.id = n.id;\n          q.rotate = h;\n          q.setOrientation(h);\n          q.width = k;\n          q.height = l;\n          q.dataProvider = c;\n          q.reversed = n.reversed;\n          q.logarithmic = n.logarithmic;\n          q.gridAlpha = 0;\n          q.axisAlpha = 0;\n          p.push(q.set);\n          h ? (q.y = g, q.x = 0) : (q.x = f, q.y = 0);\n          var f = Infinity,\n              g = -Infinity,\n              t;\n\n          for (t = 0; t < c.length; t++) {\n            var r = c[t].axes[n.id].graphs[m.id].values,\n                w;\n\n            for (w in r) if (r.hasOwnProperty(w) && \"percents\" != w && \"total\" != w) {\n              var z = r[w];\n              z < f && (f = z);\n              z > g && (g = z);\n            }\n          }\n\n          Infinity != f && (q.minimum = f);\n          -Infinity != g && (q.maximum = g + .1 * (g - f));\n          f == g && (--q.minimum, q.maximum += 1);\n          void 0 !== a.minimum && (q.minimum = a.minimum);\n          void 0 !== a.maximum && (q.maximum = a.maximum);\n          q.zoom(0, c.length - 1);\n          w = a.unselectedGraph;\n          w.id = m.id;\n          w.bcn = \"scrollbar-graph-\";\n          w.rotate = h;\n          w.chart = b;\n          w.data = c;\n          w.valueAxis = q;\n          w.chart = m.chart;\n          w.categoryAxis = a.categoryAxis;\n          w.periodSpan = m.periodSpan;\n          w.valueField = m.valueField;\n          w.openField = m.openField;\n          w.closeField = m.closeField;\n          w.highField = m.highField;\n          w.lowField = m.lowField;\n          w.lineAlpha = a.graphLineAlpha;\n          w.lineColorR = a.graphLineColor;\n          w.fillAlphas = a.graphFillAlpha;\n          w.fillColorsR = a.graphFillColor;\n          w.connect = m.connect;\n          w.hidden = m.hidden;\n          w.width = k;\n          w.height = l;\n          w.pointPosition = m.pointPosition;\n          w.stepDirection = m.stepDirection;\n          w.periodSpan = m.periodSpan;\n          n = a.selectedGraph;\n          n.id = m.id;\n          n.bcn = w.bcn + \"selected-\";\n          n.rotate = h;\n          n.chart = b;\n          n.data = c;\n          n.valueAxis = q;\n          n.chart = m.chart;\n          n.categoryAxis = e;\n          n.periodSpan = m.periodSpan;\n          n.valueField = m.valueField;\n          n.openField = m.openField;\n          n.closeField = m.closeField;\n          n.highField = m.highField;\n          n.lowField = m.lowField;\n          n.lineAlpha = a.selectedGraphLineAlpha;\n          n.lineColorR = a.selectedGraphLineColor;\n          n.fillAlphas = a.selectedGraphFillAlpha;\n          n.fillColorsR = a.selectedGraphFillColor;\n          n.connect = m.connect;\n          n.hidden = m.hidden;\n          n.width = k;\n          n.height = l;\n          n.pointPosition = m.pointPosition;\n          n.stepDirection = m.stepDirection;\n          n.periodSpan = m.periodSpan;\n          b = a.graphType;\n          b || (b = m.type);\n          w.type = b;\n          n.type = b;\n          c = c.length - 1;\n          w.zoom(0, c);\n          n.zoom(0, c);\n          n.set.click(function () {\n            a.handleBackgroundClick();\n          }).mouseover(function () {\n            a.handleMouseOver();\n          }).mouseout(function () {\n            a.handleMouseOut();\n          });\n          w.set.click(function () {\n            a.handleBackgroundClick();\n          }).mouseover(function () {\n            a.handleMouseOver();\n          }).mouseout(function () {\n            a.handleMouseOut();\n          });\n          p.push(w.set);\n          p.push(n.set);\n        }\n\n        p.push(e.set);\n        p.push(e.labelsSet);\n        a.bg.toBack();\n        a.invisibleBg.toFront();\n        a.dragger.toFront();\n        a.iconLeft.toFront();\n        a.iconRight.toFront();\n      }\n    },\n    timeZoom: function (a, b, c) {\n      this.startTime = a;\n      this.endTime = b;\n      this.timeDifference = b - a;\n      this.skipEvent = !d.toBoolean(c);\n      this.zoomScrollbar();\n      this.dispatchScrollbarEvent();\n    },\n    zoom: function (a, b) {\n      this.start = a;\n      this.end = b;\n      this.skipEvent = !0;\n      this.zoomScrollbar();\n    },\n    dispatchScrollbarEvent: function () {\n      if (this.categoryAxis && \"ValueAxis\" == this.categoryAxis.cname) d.ChartScrollbar.base.dispatchScrollbarEvent.call(this);else if (this.skipEvent) this.skipEvent = !1;else {\n        var a = this.chart.chartData,\n            b,\n            c,\n            e = this.dragger.getBBox();\n        b = e.x;\n        var h = e.y,\n            f = e.width,\n            e = e.height,\n            g = this.chart;\n        this.rotate ? (b = h, c = e) : c = f;\n        f = {\n          type: \"zoomed\",\n          target: this\n        };\n        f.chart = g;\n        var k = this.categoryAxis,\n            l = this.stepWidth,\n            h = g.minSelectedTime,\n            e = g.maxSelectedTime,\n            m = !1;\n\n        if (k.parseDates && !k.equalSpacing) {\n          if (a = g.lastTime, g = g.firstTime, k = Math.round(b / l) + g, b = this.dragging ? k + this.timeDifference : Math.round((b + c) / l) + g, k > b && (k = b), 0 < h && b - k < h && (b = Math.round(k + (b - k) / 2), m = Math.round(h / 2), k = b - m, b += m, m = !0), 0 < e && b - k > e && (b = Math.round(k + (b - k) / 2), m = Math.round(e / 2), k = b - m, b += m, m = !0), b > a && (b = a), b - h < k && (k = b - h), k < g && (k = g), k + h > b && (b = k + h), k != this.startTime || b != this.endTime) this.startTime = k, this.endTime = b, f.start = k, f.end = b, f.startDate = new Date(k), f.endDate = new Date(b), this.fire(f);\n        } else {\n          k.startOnAxis || (b += l / 2);\n          c -= this.stepWidth / 2;\n          h = k.xToIndex(b);\n          b = k.xToIndex(b + c);\n          if (h != this.start || this.end != b) k.startOnAxis && (this.resizingRight && h == b && b++, this.resizingLeft && h == b && (0 < h ? h-- : b = 1)), this.start = h, this.end = this.dragging ? this.start + this.difference : b, f.start = this.start, f.end = this.end, k.parseDates && (a[this.start] && (f.startDate = new Date(a[this.start].time)), a[this.end] && (f.endDate = new Date(a[this.end].time))), this.fire(f);\n          this.percentStart = h;\n          this.percentEnd = b;\n        }\n\n        m && this.zoomScrollbar(!0);\n      }\n    },\n    zoomScrollbar: function (a) {\n      if ((!(this.dragging || this.resizingLeft || this.resizingRight || this.animating) || a) && this.dragger && this.enabled) {\n        var b,\n            c,\n            d = this.chart;\n        a = d.chartData;\n        var h = this.categoryAxis;\n        h.parseDates && !h.equalSpacing ? (a = h.stepWidth, c = d.firstTime, b = a * (this.startTime - c), c = a * (this.endTime - c)) : (a[this.start] && (b = a[this.start].x[h.id]), a[this.end] && (c = a[this.end].x[h.id]), a = h.stepWidth, h.startOnAxis || (d = a / 2, b -= d, c += d));\n        this.stepWidth = a;\n        isNaN(b) || isNaN(c) || this.updateScrollbarSize(b, c);\n      }\n    },\n    maskGraphs: function (a, b, c, d) {\n      var h = this.selectedGraph;\n      h && h.set.clipRect(a, b, c, d);\n    },\n    handleDragStart: function () {\n      d.ChartScrollbar.base.handleDragStart.call(this);\n      this.difference = this.end - this.start;\n      this.timeDifference = this.endTime - this.startTime;\n      0 > this.timeDifference && (this.timeDifference = 0);\n    },\n    handleBackgroundClick: function () {\n      d.ChartScrollbar.base.handleBackgroundClick.call(this);\n      this.dragging || (this.difference = this.end - this.start, this.timeDifference = this.endTime - this.startTime, 0 > this.timeDifference && (this.timeDifference = 0));\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmBalloon = d.Class({\n    construct: function (a) {\n      this.cname = \"AmBalloon\";\n      this.enabled = !0;\n      this.fillColor = \"#FFFFFF\";\n      this.fillAlpha = .8;\n      this.borderThickness = 2;\n      this.borderColor = \"#FFFFFF\";\n      this.borderAlpha = 1;\n      this.cornerRadius = 0;\n      this.maxWidth = 220;\n      this.horizontalPadding = 8;\n      this.verticalPadding = 4;\n      this.pointerWidth = 6;\n      this.pointerOrientation = \"V\";\n      this.color = \"#000000\";\n      this.adjustBorderColor = !0;\n      this.show = this.follow = this.showBullet = !1;\n      this.bulletSize = 3;\n      this.shadowAlpha = .4;\n      this.shadowColor = \"#000000\";\n      this.fadeOutDuration = this.animationDuration = .3;\n      this.fixedPosition = !0;\n      this.offsetY = 6;\n      this.offsetX = 1;\n      this.textAlign = \"center\";\n      this.disableMouseEvents = !0;\n      this.deltaSignX = this.deltaSignY = 1;\n      d.isModern || (this.offsetY *= 1.5);\n      this.sdy = this.sdx = 0;\n      d.applyTheme(this, a, this.cname);\n    },\n    draw: function () {\n      var a = this.pointToX,\n          b = this.pointToY;\n      d.isModern || (this.drop = !1);\n      var c = this.chart;\n      d.VML && (this.fadeOutDuration = 0);\n      this.xAnim && c.stopAnim(this.xAnim);\n      this.yAnim && c.stopAnim(this.yAnim);\n      this.sdy = this.sdx = 0;\n\n      if (!isNaN(a)) {\n        var e = this.follow,\n            h = c.container,\n            f = this.set;\n        d.remove(f);\n        this.removeDiv();\n        f = h.set();\n        f.node.style.pointerEvents = \"none\";\n        this.set = f;\n        this.mainSet ? (this.mainSet.push(this.set), this.sdx = this.mainSet.x, this.sdy = this.mainSet.y) : c.balloonsSet.push(f);\n\n        if (this.show) {\n          var g = this.l,\n              k = this.t,\n              l = this.r,\n              m = this.b,\n              p = this.balloonColor,\n              q = this.fillColor,\n              n = this.borderColor,\n              t = q;\n          void 0 != p && (this.adjustBorderColor ? t = n = p : q = p);\n          var r = this.horizontalPadding,\n              w = this.verticalPadding,\n              z = this.pointerWidth,\n              x = this.pointerOrientation,\n              u = this.cornerRadius,\n              A = c.fontFamily,\n              y = this.fontSize;\n          void 0 == y && (y = c.fontSize);\n          var p = document.createElement(\"div\"),\n              B = c.classNamePrefix;\n          p.className = B + \"-balloon-div\";\n          this.className && (p.className = p.className + \" \" + B + \"-balloon-div-\" + this.className);\n          B = p.style;\n          this.disableMouseEvents && (B.pointerEvents = \"none\");\n          B.position = \"absolute\";\n          var D = this.minWidth,\n              C = document.createElement(\"div\");\n          p.appendChild(C);\n          var I = C.style;\n          isNaN(D) || (I.minWidth = D - 2 * r + \"px\");\n          I.textAlign = this.textAlign;\n          I.maxWidth = this.maxWidth + \"px\";\n          I.fontSize = y + \"px\";\n          I.color = this.color;\n          I.fontFamily = A;\n          C.innerHTML = this.text;\n          c.chartDiv.appendChild(p);\n          this.textDiv = p;\n          var I = p.offsetWidth,\n              H = p.offsetHeight;\n          p.clientHeight && (I = p.clientWidth, H = p.clientHeight);\n          A = H + 2 * w;\n          C = I + 2 * r;\n          !isNaN(D) && C < D && (C = D);\n          window.opera && (A += 2);\n          var Q = !1,\n              y = this.offsetY;\n          c.handDrawn && (y += c.handDrawScatter + 2);\n          \"H\" != x ? (D = a - C / 2, b < k + A + 10 && \"down\" != x ? (Q = !0, e && (b += y), y = b + z, this.deltaSignY = -1) : (e && (b -= y), y = b - A - z, this.deltaSignY = 1)) : (2 * z > A && (z = A / 2), y = b - A / 2, a < g + (l - g) / 2 ? (D = a + z, this.deltaSignX = -1) : (D = a - C - z, this.deltaSignX = 1));\n          y + A >= m && (y = m - A);\n          y < k && (y = k);\n          D < g && (D = g);\n          D + C > l && (D = l - C);\n          var k = y + w,\n              m = D + r,\n              M = this.shadowAlpha,\n              P = this.shadowColor,\n              r = this.borderThickness,\n              ia = this.bulletSize,\n              J,\n              w = this.fillAlpha,\n              aa = this.borderAlpha;\n          this.showBullet && (J = d.circle(h, ia, t, w), f.push(J));\n          this.drop ? (g = C / 1.6, l = 0, \"V\" == x && (x = \"down\"), \"H\" == x && (x = \"left\"), \"down\" == x && (D = a + 1, y = b - g - g / 3), \"up\" == x && (l = 180, D = a + 1, y = b + g + g / 3), \"left\" == x && (l = 270, D = a + g + g / 3 + 2, y = b), \"right\" == x && (l = 90, D = a - g - g / 3 + 2, y = b), k = y - H / 2 + 1, m = D - I / 2 - 1, q = d.drop(h, g, l, q, w, r, n, aa)) : 0 < u || 0 === z ? (0 < M && (a = d.rect(h, C, A, q, 0, r + 1, P, M, u), d.isModern ? a.translate(1, 1) : a.translate(4, 4), f.push(a)), q = d.rect(h, C, A, q, w, r, n, aa, u)) : (t = [], u = [], \"H\" != x ? (g = a - D, g > C - z && (g = C - z), g < z && (g = z), t = [0, g - z, a - D, g + z, C, C, 0, 0], u = Q ? [0, 0, b - y, 0, 0, A, A, 0] : [A, A, b - y, A, A, 0, 0, A]) : (x = b - y, x > A - z && (x = A - z), x < z && (x = z), u = [0, x - z, b - y, x + z, A, A, 0, 0], t = a < g + (l - g) / 2 ? [0, 0, D < a ? 0 : a - D, 0, 0, C, C, 0] : [C, C, D + C > a ? C : a - D, C, C, 0, 0, C]), 0 < M && (a = d.polygon(h, t, u, q, 0, r, P, M), a.translate(1, 1), f.push(a)), q = d.polygon(h, t, u, q, w, r, n, aa));\n          this.bg = q;\n          f.push(q);\n          q.toFront();\n          d.setCN(c, q, \"balloon-bg\");\n          this.className && d.setCN(c, q, \"balloon-bg-\" + this.className);\n          h = 1 * this.deltaSignX;\n          m += this.sdx;\n          k += this.sdy;\n          B.left = m + \"px\";\n          B.top = k + \"px\";\n          f.translate(D - h, y, 1, !0);\n          q = q.getBBox();\n          this.bottom = y + A + 1;\n          this.yPos = q.y + y;\n          J && J.translate(this.pointToX - D + h, b - y);\n          b = this.animationDuration;\n          0 < this.animationDuration && !e && !isNaN(this.prevX) && (f.translate(this.prevX, this.prevY, NaN, !0), f.animate({\n            translate: D - h + \",\" + y\n          }, b, \"easeOutSine\"), p && (B.left = this.prevTX + \"px\", B.top = this.prevTY + \"px\", this.xAnim = c.animate({\n            node: p\n          }, \"left\", this.prevTX, m, b, \"easeOutSine\", \"px\"), this.yAnim = c.animate({\n            node: p\n          }, \"top\", this.prevTY, k, b, \"easeOutSine\", \"px\")));\n          this.prevX = D - h;\n          this.prevY = y;\n          this.prevTX = m;\n          this.prevTY = k;\n        }\n      }\n    },\n    fixPrevious: function () {\n      this.rPrevX = this.prevX;\n      this.rPrevY = this.prevY;\n      this.rPrevTX = this.prevTX;\n      this.rPrevTY = this.prevTY;\n    },\n    restorePrevious: function () {\n      this.prevX = this.rPrevX;\n      this.prevY = this.rPrevY;\n      this.prevTX = this.rPrevTX;\n      this.prevTY = this.rPrevTY;\n    },\n    followMouse: function () {\n      if (this.follow && this.show) {\n        var a = this.chart.mouseX - this.offsetX * this.deltaSignX - this.sdx,\n            b = this.chart.mouseY - this.sdy;\n        this.pointToX = a;\n        this.pointToY = b;\n        if (a != this.previousX || b != this.previousY) if (this.previousX = a, this.previousY = b, 0 === this.cornerRadius) this.draw();else {\n          var c = this.set;\n\n          if (c) {\n            var d = c.getBBox(),\n                a = a - d.width / 2,\n                h = b - d.height - 10;\n            a < this.l && (a = this.l);\n            a > this.r - d.width && (a = this.r - d.width);\n            h < this.t && (h = b + 10);\n            c.translate(a, h);\n            b = this.textDiv.style;\n            b.left = a + this.horizontalPadding + \"px\";\n            b.top = h + this.verticalPadding + \"px\";\n          }\n        }\n      }\n    },\n    changeColor: function (a) {\n      this.balloonColor = a;\n    },\n    setBounds: function (a, b, c, d) {\n      this.l = a;\n      this.t = b;\n      this.r = c;\n      this.b = d;\n      this.destroyTO && clearTimeout(this.destroyTO);\n    },\n    showBalloon: function (a) {\n      if (this.text != a || this.positionChanged) this.text = a, this.isHiding = !1, this.show = !0, this.destroyTO && clearTimeout(this.destroyTO), a = this.chart, this.fadeAnim1 && a.stopAnim(this.fadeAnim1), this.fadeAnim2 && a.stopAnim(this.fadeAnim2), this.draw(), this.positionChanged = !1;\n    },\n    hide: function (a) {\n      var b = this;\n      b.text = void 0;\n      isNaN(a) && (a = b.fadeOutDuration);\n      var c = b.chart;\n\n      if (0 < a && !b.isHiding) {\n        b.isHiding = !0;\n        b.destroyTO && clearTimeout(b.destroyTO);\n        b.destroyTO = setTimeout(function () {\n          b.destroy.call(b);\n        }, 1E3 * a);\n        b.follow = !1;\n        b.show = !1;\n        var d = b.set;\n        d && (d.setAttr(\"opacity\", b.fillAlpha), b.fadeAnim1 = d.animate({\n          opacity: 0\n        }, a, \"easeInSine\"));\n        b.textDiv && (b.fadeAnim2 = c.animate({\n          node: b.textDiv\n        }, \"opacity\", 1, 0, a, \"easeInSine\", \"\"));\n      } else b.show = !1, b.follow = !1, b.destroy();\n    },\n    setPosition: function (a, b) {\n      if (a != this.pointToX || b != this.pointToY) this.previousX = this.pointToX, this.previousY = this.pointToY, this.pointToX = a, this.pointToY = b, this.positionChanged = !0;\n    },\n    followCursor: function (a) {\n      var b = this;\n      b.follow = a;\n      clearInterval(b.interval);\n      var c = b.chart.mouseX - b.sdx,\n          d = b.chart.mouseY - b.sdy;\n      !isNaN(c) && a && (b.pointToX = c - b.offsetX * b.deltaSignX, b.pointToY = d, b.followMouse(), b.interval = setInterval(function () {\n        b.followMouse.call(b);\n      }, 40));\n    },\n    removeDiv: function () {\n      if (this.textDiv) {\n        var a = this.textDiv.parentNode;\n        a && a.removeChild(this.textDiv);\n      }\n    },\n    destroy: function () {\n      clearInterval(this.interval);\n      d.remove(this.set);\n      this.removeDiv();\n      this.set = null;\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmCoordinateChart = d.Class({\n    inherits: d.AmChart,\n    construct: function (a) {\n      d.AmCoordinateChart.base.construct.call(this, a);\n      this.theme = a;\n      this.createEvents(\"rollOverGraphItem\", \"rollOutGraphItem\", \"clickGraphItem\", \"doubleClickGraphItem\", \"rightClickGraphItem\", \"clickGraph\", \"rollOverGraph\", \"rollOutGraph\");\n      this.startAlpha = 1;\n      this.startDuration = 0;\n      this.startEffect = \"elastic\";\n      this.sequencedAnimation = !0;\n      this.colors = \"#FF6600 #FCD202 #B0DE09 #0D8ECF #2A0CD0 #CD0D74 #CC0000 #00CC00 #0000CC #DDDDDD #999999 #333333 #990000\".split(\" \");\n      this.balloonDateFormat = \"MMM DD, YYYY\";\n      this.valueAxes = [];\n      this.graphs = [];\n      this.guides = [];\n      this.gridAboveGraphs = !1;\n      d.applyTheme(this, a, \"AmCoordinateChart\");\n    },\n    initChart: function () {\n      d.AmCoordinateChart.base.initChart.call(this);\n      this.drawGraphs = !0;\n      var a = this.categoryAxis;\n      a && (this.categoryAxis = d.processObject(a, d.CategoryAxis, this.theme));\n      this.processValueAxes();\n      this.createValueAxes();\n      this.processGraphs();\n      this.processGuides();\n      d.VML && (this.startAlpha = 1);\n      this.setLegendData(this.graphs);\n      this.gridAboveGraphs && (this.gridSet.toFront(), this.bulletSet.toFront(), this.balloonsSet.toFront());\n    },\n    createValueAxes: function () {\n      if (0 === this.valueAxes.length) {\n        var a = new d.ValueAxis();\n        this.addValueAxis(a);\n      }\n    },\n    parseData: function () {\n      this.processValueAxes();\n      this.processGraphs();\n    },\n    parseSerialData: function (a) {\n      this.chartData = [];\n      if (a) {\n        if (0 < this.processTimeout) {\n          1 > this.processCount && (this.processCount = 1);\n          var b = a.length / this.processCount;\n          this.parseCount = Math.ceil(b) - 1;\n\n          for (var c = 0; c < b; c++) this.delayParseSerialData(a, c);\n        } else this.parseCount = 0, this.parsePartSerialData(a, 0, a.length, 0);\n      } else this.onDataUpdated();\n    },\n    delayParseSerialData: function (a, b) {\n      var c = this,\n          d = c.processCount;\n      setTimeout(function () {\n        c.parsePartSerialData.call(c, a, b * d, (b + 1) * d, b);\n      }, c.processTimeout);\n    },\n    parsePartSerialData: function (a, b, c, e) {\n      c > a.length && (c = a.length);\n      var h = this.graphs,\n          f = {},\n          g = this.seriesIdField;\n      g || (g = this.categoryField);\n      var k = !1,\n          l,\n          m = this.categoryAxis,\n          p,\n          q,\n          n;\n      m && (k = m.parseDates, p = m.forceShowField, n = m.classNameField, q = m.labelColorField, l = m.categoryFunction);\n      var t,\n          r,\n          w = {},\n          z;\n      k && (t = d.extractPeriod(m.minPeriod), r = t.period, t = t.count, z = d.getPeriodDuration(r, t));\n      var x = {};\n      this.lookupTable = x;\n      var u,\n          A = this.dataDateFormat,\n          y = {};\n\n      for (u = b; u < c; u++) {\n        var B = {},\n            D = a[u];\n        b = D[this.categoryField];\n        B.dataContext = D;\n        B.category = l ? l(b, D, m) : String(b);\n        p && (B.forceShow = D[p]);\n        n && (B.className = D[n]);\n        q && (B.labelColor = D[q]);\n        x[D[g]] = B;\n        if (k && (m.categoryFunction ? b = m.categoryFunction(b, D, m) : (!A || b instanceof Date || (b = b.toString() + \" |\"), b = d.getDate(b, A, m.minPeriod)), b = d.resetDateToMin(b, r, t, m.firstDayOfWeek), B.category = b, B.time = b.getTime(), isNaN(B.time))) continue;\n        var C = this.valueAxes;\n        B.axes = {};\n        B.x = {};\n        var I;\n\n        for (I = 0; I < C.length; I++) {\n          var H = C[I].id;\n          B.axes[H] = {};\n          B.axes[H].graphs = {};\n          var Q;\n\n          for (Q = 0; Q < h.length; Q++) {\n            b = h[Q];\n            var M = b.id,\n                P = 1.1;\n            isNaN(b.gapPeriod) || (P = b.gapPeriod);\n            var ia = b.periodValue;\n\n            if (b.valueAxis.id == H) {\n              B.axes[H].graphs[M] = {};\n              var J = {};\n              J.index = u;\n              var aa = D;\n              b.dataProvider && (aa = f);\n              J.values = this.processValues(aa, b, ia);\n              if (!b.connect || b.forceGap && !isNaN(b.gapPeriod)) if (y && y[M] && 0 < P && B.time - w[M] >= z * P && (y[M].gap = !0), b.forceGap) {\n                var P = 0,\n                    ma;\n\n                for (ma in J.values) P++;\n\n                0 < P && (w[M] = B.time, y[M] = J);\n              } else w[M] = B.time, y[M] = J;\n              this.processFields(b, J, aa);\n              J.category = B.category;\n              J.serialDataItem = B;\n              J.graph = b;\n              B.axes[H].graphs[M] = J;\n            }\n          }\n        }\n\n        this.chartData[u] = B;\n      }\n\n      if (this.parseCount == e) {\n        for (a = 0; a < h.length; a++) b = h[a], b.dataProvider && this.parseGraphData(b);\n\n        this.dataChanged = !1;\n        this.dispatchDataUpdated = !0;\n        this.onDataUpdated();\n      }\n    },\n    processValues: function (a, b, c) {\n      var e = {},\n          h,\n          f = !1;\n      \"candlestick\" != b.type && \"ohlc\" != b.type || \"\" === c || (f = !0);\n\n      for (var g = \"value error open close low high\".split(\" \"), k = 0; k < g.length; k++) {\n        var l = g[k];\n        \"value\" != l && \"error\" != l && f && (c = l.charAt(0).toUpperCase() + l.slice(1));\n        var m = a[b[l + \"Field\"] + c];\n        null !== m && (h = Number(m), isNaN(h) || (e[l] = h), \"date\" == b.valueAxis.type && void 0 !== m && (h = d.getDate(m, b.chart.dataDateFormat), e[l] = h.getTime()));\n      }\n\n      return e;\n    },\n    parseGraphData: function (a) {\n      var b = a.dataProvider,\n          c = a.seriesIdField;\n      c || (c = this.seriesIdField);\n      c || (c = this.categoryField);\n      var d;\n\n      for (d = 0; d < b.length; d++) {\n        var h = b[d],\n            f = this.lookupTable[String(h[c])],\n            g = a.valueAxis.id;\n        f && (g = f.axes[g].graphs[a.id], g.serialDataItem = f, g.values = this.processValues(h, a, a.periodValue), this.processFields(a, g, h));\n      }\n    },\n    addValueAxis: function (a) {\n      a.chart = this;\n      this.valueAxes.push(a);\n      this.validateData();\n    },\n    removeValueAxesAndGraphs: function () {\n      var a = this.valueAxes,\n          b;\n\n      for (b = a.length - 1; -1 < b; b--) this.removeValueAxis(a[b]);\n    },\n    removeValueAxis: function (a) {\n      var b = this.graphs,\n          c;\n\n      for (c = b.length - 1; 0 <= c; c--) {\n        var d = b[c];\n        d && d.valueAxis == a && this.removeGraph(d);\n      }\n\n      b = this.valueAxes;\n\n      for (c = b.length - 1; 0 <= c; c--) b[c] == a && b.splice(c, 1);\n\n      this.validateData();\n    },\n    addGraph: function (a) {\n      this.graphs.push(a);\n      this.chooseGraphColor(a, this.graphs.length - 1);\n      this.validateData();\n    },\n    removeGraph: function (a) {\n      var b = this.graphs,\n          c;\n\n      for (c = b.length - 1; 0 <= c; c--) b[c] == a && (b.splice(c, 1), a.destroy());\n\n      this.validateData();\n    },\n    handleValueAxisZoom: function () {},\n    processValueAxes: function () {\n      var a = this.valueAxes,\n          b;\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b],\n            c = d.processObject(c, d.ValueAxis, this.theme);\n        a[b] = c;\n        c.chart = this;\n        c.init();\n        this.listenTo(c, \"axisIntZoomed\", this.handleValueAxisZoom);\n        c.id || (c.id = \"valueAxisAuto\" + b + \"_\" + new Date().getTime());\n        void 0 === c.usePrefixes && (c.usePrefixes = this.usePrefixes);\n      }\n    },\n    processGuides: function () {\n      var a = this.guides,\n          b = this.categoryAxis;\n      if (a) for (var c = 0; c < a.length; c++) {\n        var e = a[c];\n        (void 0 !== e.category || void 0 !== e.date) && b && b.addGuide(e);\n        e.id || (e.id = \"guideAuto\" + c + \"_\" + new Date().getTime());\n        var h = e.valueAxis;\n        h ? (d.isString(h) && (h = this.getValueAxisById(h)), h ? h.addGuide(e) : this.valueAxes[0].addGuide(e)) : isNaN(e.value) || this.valueAxes[0].addGuide(e);\n      }\n    },\n    processGraphs: function () {\n      var a = this.graphs,\n          b;\n      this.graphsById = {};\n\n      for (b = 0; b < a.length; b++) {\n        var c = a[b],\n            c = d.processObject(c, d.AmGraph, this.theme);\n        a[b] = c;\n        this.chooseGraphColor(c, b);\n        c.chart = this;\n        c.init();\n        d.isString(c.valueAxis) && (c.valueAxis = this.getValueAxisById(c.valueAxis));\n        c.valueAxis || (c.valueAxis = this.valueAxes[0]);\n        c.id || (c.id = \"graphAuto\" + b + \"_\" + new Date().getTime());\n        this.graphsById[c.id] = c;\n      }\n    },\n    formatString: function (a, b, c) {\n      var e = b.graph,\n          h = e.valueAxis;\n      h.duration && b.values.value && (h = d.formatDuration(b.values.value, h.duration, \"\", h.durationUnits, h.maxInterval, h.numberFormatter), a = a.split(\"[[value]]\").join(h));\n      a = d.massReplace(a, {\n        \"[[title]]\": e.title,\n        \"[[description]]\": b.description\n      });\n      a = c ? d.fixNewLines(a) : d.fixBrakes(a);\n      return a = d.cleanFromEmpty(a);\n    },\n    getBalloonColor: function (a, b, c) {\n      var e = a.lineColor,\n          h = a.balloonColor;\n      c && (h = e);\n      c = a.fillColorsR;\n      \"object\" == typeof c ? e = c[0] : void 0 !== c && (e = c);\n      b.isNegative && (c = a.negativeLineColor, a = a.negativeFillColors, \"object\" == typeof a ? c = a[0] : void 0 !== a && (c = a), void 0 !== c && (e = c));\n      void 0 !== b.color && (e = b.color);\n      void 0 !== b.lineColor && (e = b.lineColor);\n      b = b.fillColors;\n      void 0 !== b && (e = b, d.ifArray(b) && (e = b[0]));\n      void 0 === h && (h = e);\n      return h;\n    },\n    getGraphById: function (a) {\n      return d.getObjById(this.graphs, a);\n    },\n    getValueAxisById: function (a) {\n      return d.getObjById(this.valueAxes, a);\n    },\n    processFields: function (a, b, c) {\n      if (a.itemColors) {\n        var e = a.itemColors,\n            h = b.index;\n        b.color = h < e.length ? e[h] : d.randomColor();\n      }\n\n      e = \"lineColor color alpha fillColors description bullet customBullet bulletSize bulletConfig url labelColor dashLength pattern gap className columnIndex\".split(\" \");\n\n      for (h = 0; h < e.length; h++) {\n        var f = e[h],\n            g = a[f + \"Field\"];\n        g && (g = c[g], d.isDefined(g) && (b[f] = g));\n      }\n\n      b.dataContext = c;\n    },\n    chooseGraphColor: function (a, b) {\n      if (a.lineColor) a.lineColorR = a.lineColor;else {\n        var c;\n        c = this.colors.length > b ? this.colors[b] : a.lineColorR ? a.lineColorR : d.randomColor();\n        a.lineColorR = c;\n      }\n      a.fillColorsR = a.fillColors ? a.fillColors : a.lineColorR;\n      a.bulletBorderColorR = a.bulletBorderColor ? a.bulletBorderColor : a.useLineColorForBulletBorder ? a.lineColorR : a.bulletColor;\n      a.bulletColorR = a.bulletColor ? a.bulletColor : a.lineColorR;\n      if (c = this.patterns) a.pattern = c[b];\n    },\n    handleLegendEvent: function (a) {\n      var b = a.type;\n\n      if (a = a.dataItem) {\n        var c = a.hidden,\n            d = a.showBalloon;\n\n        switch (b) {\n          case \"clickMarker\":\n            this.textClickEnabled && (d ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a));\n            break;\n\n          case \"clickLabel\":\n            d ? this.hideGraphsBalloon(a) : this.showGraphsBalloon(a);\n            break;\n\n          case \"rollOverItem\":\n            c || this.highlightGraph(a);\n            break;\n\n          case \"rollOutItem\":\n            c || this.unhighlightGraph();\n            break;\n\n          case \"hideItem\":\n            this.hideGraph(a);\n            break;\n\n          case \"showItem\":\n            this.showGraph(a);\n        }\n      }\n    },\n    highlightGraph: function (a) {\n      var b = this.graphs;\n\n      if (b) {\n        var c,\n            d = .2;\n        this.legend && (d = this.legend.rollOverGraphAlpha);\n        if (1 != d) for (c = 0; c < b.length; c++) {\n          var h = b[c];\n          h != a && h.changeOpacity(d);\n        }\n      }\n    },\n    unhighlightGraph: function () {\n      var a;\n      this.legend && (a = this.legend.rollOverGraphAlpha);\n\n      if (1 != a) {\n        a = this.graphs;\n        var b;\n\n        for (b = 0; b < a.length; b++) a[b].changeOpacity(1);\n      }\n    },\n    showGraph: function (a) {\n      a.switchable && (a.hidden = !1, this.dataChanged = !0, \"xy\" != this.type && (this.marginsUpdated = !1), this.chartCreated && this.initChart());\n    },\n    hideGraph: function (a) {\n      a.switchable && (this.dataChanged = !0, \"xy\" != this.type && (this.marginsUpdated = !1), a.hidden = !0, this.chartCreated && this.initChart());\n    },\n    hideGraphsBalloon: function (a) {\n      a.showBalloon = !1;\n      this.updateLegend();\n    },\n    showGraphsBalloon: function (a) {\n      a.showBalloon = !0;\n      this.updateLegend();\n    },\n    updateLegend: function () {\n      this.legend && this.legend.invalidateSize();\n    },\n    resetAnimation: function () {\n      var a = this.graphs;\n\n      if (a) {\n        var b;\n\n        for (b = 0; b < a.length; b++) a[b].animationPlayed = !1;\n      }\n    },\n    animateAgain: function () {\n      this.resetAnimation();\n      this.validateNow();\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.TrendLine = d.Class({\n    construct: function (a) {\n      this.cname = \"TrendLine\";\n      this.createEvents(\"click\", \"rollOver\", \"rollOut\");\n      this.isProtected = !1;\n      this.dashLength = 0;\n      this.lineColor = \"#00CC00\";\n      this.lineThickness = this.lineAlpha = 1;\n      d.applyTheme(this, a, this.cname);\n    },\n    draw: function () {\n      var a = this;\n      a.destroy();\n      var b = a.chart,\n          c = b.container,\n          e,\n          h,\n          f,\n          g,\n          k = a.categoryAxis,\n          l = a.initialDate,\n          m = a.initialCategory,\n          p = a.finalDate,\n          q = a.finalCategory,\n          n = a.valueAxis,\n          t = a.valueAxisX,\n          r = a.initialXValue,\n          w = a.finalXValue,\n          z = a.initialValue,\n          x = a.finalValue,\n          u = n.recalculateToPercents,\n          A = b.dataDateFormat;\n      k && (l && (l = d.getDate(l, A, \"fff\"), a.initialDate = l, e = k.dateToCoordinate(l)), m && (e = k.categoryToCoordinate(m)), p && (p = d.getDate(p, A, \"fff\"), a.finalDate = p, h = k.dateToCoordinate(p)), q && (h = k.categoryToCoordinate(q)));\n      t && !u && (isNaN(r) || (e = t.getCoordinate(r)), isNaN(w) || (h = t.getCoordinate(w)));\n      n && !u && (isNaN(z) || (f = n.getCoordinate(z)), isNaN(x) || (g = n.getCoordinate(x)));\n\n      if (!(isNaN(e) || isNaN(h) || isNaN(f) || isNaN(f))) {\n        b.rotate ? (k = [f, g], g = [e, h]) : (k = [e, h], g = [f, g]);\n        l = a.lineColor;\n        f = d.line(c, k, g, l, a.lineAlpha, a.lineThickness, a.dashLength);\n        e = k;\n        h = g;\n        q = k[1] - k[0];\n        n = g[1] - g[0];\n        0 === q && (q = .01);\n        0 === n && (n = .01);\n        m = q / Math.abs(q);\n        p = n / Math.abs(n);\n        n = 90 * Math.PI / 180 - Math.asin(q / (q * n / Math.abs(q * n) * Math.sqrt(Math.pow(q, 2) + Math.pow(n, 2))));\n        q = Math.abs(5 * Math.cos(n));\n        n = Math.abs(5 * Math.sin(n));\n        e.push(k[1] - m * n, k[0] - m * n);\n        h.push(g[1] + p * q, g[0] + p * q);\n        g = d.polygon(c, e, h, l, .005, 0);\n        c = c.set([g, f]);\n        c.translate(b.marginLeftReal, b.marginTopReal);\n        b.trendLinesSet.push(c);\n        d.setCN(b, f, \"trend-line\");\n        d.setCN(b, f, \"trend-line-\" + a.id);\n        a.line = f;\n        a.set = c;\n        if (f = a.initialImage) f = d.processObject(f, d.Image, a.theme), f.chart = b, f.draw(), f.translate(e[0] + f.offsetX, h[0] + f.offsetY), c.push(f.set);\n        if (f = a.finalImage) f = d.processObject(f, d.Image, a.theme), f.chart = b, f.draw(), f.translate(e[1] + f.offsetX, h[1] + f.offsetY), c.push(f.set);\n        g.mouseup(function () {\n          a.handleLineClick();\n        }).mouseover(function () {\n          a.handleLineOver();\n        }).mouseout(function () {\n          a.handleLineOut();\n        });\n        g.touchend && g.touchend(function () {\n          a.handleLineClick();\n        });\n        c.clipRect(0, 0, b.plotAreaWidth, b.plotAreaHeight);\n      }\n    },\n    handleLineClick: function () {\n      this.fire({\n        type: \"click\",\n        trendLine: this,\n        chart: this.chart\n      });\n    },\n    handleLineOver: function () {\n      var a = this.rollOverColor;\n      void 0 !== a && this.line.attr({\n        stroke: a\n      });\n      this.balloonText && (clearTimeout(this.chart.hoverInt), a = this.line.getBBox(), this.chart.showBalloon(this.balloonText, this.lineColor, !0, this.x + a.x + a.width / 2, this.y + a.y + a.height / 2));\n      this.fire({\n        type: \"rollOver\",\n        trendLine: this,\n        chart: this.chart\n      });\n    },\n    handleLineOut: function () {\n      this.line.attr({\n        stroke: this.lineColor\n      });\n      this.balloonText && this.chart.hideBalloon();\n      this.fire({\n        type: \"rollOut\",\n        trendLine: this,\n        chart: this.chart\n      });\n    },\n    destroy: function () {\n      d.remove(this.set);\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.Image = d.Class({\n    construct: function (a) {\n      this.cname = \"Image\";\n      this.height = this.width = 20;\n      this.rotation = this.offsetY = this.offsetX = 0;\n      this.balloonColor = this.color = \"#000000\";\n      this.opacity = 1;\n      d.applyTheme(this, a, this.cname);\n    },\n    draw: function () {\n      var a = this;\n      a.set && a.set.remove();\n      var b = a.chart.container;\n      a.set = b.set();\n      var c, d;\n      a.url ? (c = b.image(a.url, 0, 0, a.width, a.height), d = 1) : a.svgPath && (c = b.path(a.svgPath), c.setAttr(\"fill\", a.color), c.setAttr(\"stroke\", a.outlineColor), b = c.getBBox(), d = Math.min(a.width / b.width, a.height / b.height));\n      c && (c.setAttr(\"opacity\", a.opacity), a.set.rotate(a.rotation), c.translate(-a.width / 2, -a.height / 2, d), a.balloonText && c.mouseover(function () {\n        a.chart.showBalloon(a.balloonText, a.balloonColor, !0);\n      }).mouseout(function () {\n        a.chart.hideBalloon();\n      }).touchend(function () {\n        a.chart.hideBalloon();\n      }).touchstart(function () {\n        a.chart.showBalloon(a.balloonText, a.balloonColor, !0);\n      }), a.set.push(c));\n    },\n    translate: function (a, b) {\n      this.set && this.set.translate(a, b);\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n\n  d.circle = function (a, b, c, e, h, f, g, k, l) {\n    0 >= b && (b = .001);\n    if (void 0 == h || 0 === h) h = .01;\n    void 0 === f && (f = \"#000000\");\n    void 0 === g && (g = 0);\n    e = {\n      fill: c,\n      stroke: f,\n      \"fill-opacity\": e,\n      \"stroke-width\": h,\n      \"stroke-opacity\": g\n    };\n    a = isNaN(l) ? a.circle(0, 0, b).attr(e) : a.ellipse(0, 0, b, l).attr(e);\n    k && a.gradient(\"radialGradient\", [c, d.adjustLuminosity(c, -.6)]);\n    return a;\n  };\n\n  d.text = function (a, b, c, e, h, f, g, k) {\n    f || (f = \"middle\");\n    \"right\" == f && (f = \"end\");\n    \"left\" == f && (f = \"start\");\n    isNaN(k) && (k = 1);\n    void 0 !== b && (b = String(b), d.isIE && !d.isModern && (b = b.replace(\"&amp;\", \"&\"), b = b.replace(\"&\", \"&amp;\")));\n    c = {\n      fill: c,\n      \"font-family\": e,\n      \"font-size\": h + \"px\",\n      opacity: k\n    };\n    !0 === g && (c[\"font-weight\"] = \"bold\");\n    c[\"text-anchor\"] = f;\n    return a.text(b, c);\n  };\n\n  d.polygon = function (a, b, c, e, h, f, g, k, l, m, p) {\n    isNaN(f) && (f = .01);\n    isNaN(k) && (k = h);\n    var q = e,\n        n = !1;\n    \"object\" == typeof q && 1 < q.length && (n = !0, q = q[0]);\n    void 0 === g && (g = q);\n    h = {\n      fill: q,\n      stroke: g,\n      \"fill-opacity\": h,\n      \"stroke-width\": f,\n      \"stroke-opacity\": k\n    };\n    void 0 !== p && 0 < p && (h[\"stroke-dasharray\"] = p);\n    p = d.dx;\n    f = d.dy;\n    a.handDrawn && (c = d.makeHD(b, c, a.handDrawScatter), b = c[0], c = c[1]);\n    g = Math.round;\n    m && (b[t] = d.roundTo(b[t], 5), c[t] = d.roundTo(c[t], 5), g = Number);\n    k = \"M\" + (g(b[0]) + p) + \",\" + (g(c[0]) + f);\n\n    for (var t = 1; t < b.length; t++) m && (b[t] = d.roundTo(b[t], 5), c[t] = d.roundTo(c[t], 5)), k += \" L\" + (g(b[t]) + p) + \",\" + (g(c[t]) + f);\n\n    a = a.path(k + \" Z\").attr(h);\n    n && a.gradient(\"linearGradient\", e, l);\n    return a;\n  };\n\n  d.rect = function (a, b, c, e, h, f, g, k, l, m, p) {\n    if (isNaN(b) || isNaN(c)) return a.set();\n    isNaN(f) && (f = 0);\n    void 0 === l && (l = 0);\n    void 0 === m && (m = 270);\n    isNaN(h) && (h = 0);\n    var q = e,\n        n = !1;\n    \"object\" == typeof q && (q = q[0], n = !0);\n    void 0 === g && (g = q);\n    void 0 === k && (k = h);\n    b = Math.round(b);\n    c = Math.round(c);\n    var t = 0,\n        r = 0;\n    0 > b && (b = Math.abs(b), t = -b);\n    0 > c && (c = Math.abs(c), r = -c);\n    t += d.dx;\n    r += d.dy;\n    h = {\n      fill: q,\n      stroke: g,\n      \"fill-opacity\": h,\n      \"stroke-opacity\": k\n    };\n    void 0 !== p && 0 < p && (h[\"stroke-dasharray\"] = p);\n    a = a.rect(t, r, b, c, l, f).attr(h);\n    n && a.gradient(\"linearGradient\", e, m);\n    return a;\n  };\n\n  d.bullet = function (a, b, c, e, h, f, g, k, l, m, p, q, n) {\n    var t;\n    \"circle\" == b && (b = \"round\");\n\n    switch (b) {\n      case \"round\":\n        t = d.circle(a, c / 2, e, h, f, g, k);\n        break;\n\n      case \"square\":\n        t = d.polygon(a, [-c / 2, c / 2, c / 2, -c / 2], [c / 2, c / 2, -c / 2, -c / 2], e, h, f, g, k, m - 180, void 0, n);\n        break;\n\n      case \"rectangle\":\n        t = d.polygon(a, [-c, c, c, -c], [c / 2, c / 2, -c / 2, -c / 2], e, h, f, g, k, m - 180, void 0, n);\n        break;\n\n      case \"diamond\":\n        t = d.polygon(a, [-c / 2, 0, c / 2, 0], [0, -c / 2, 0, c / 2], e, h, f, g, k);\n        break;\n\n      case \"triangleUp\":\n        t = d.triangle(a, c, 0, e, h, f, g, k);\n        break;\n\n      case \"triangleDown\":\n        t = d.triangle(a, c, 180, e, h, f, g, k);\n        break;\n\n      case \"triangleLeft\":\n        t = d.triangle(a, c, 270, e, h, f, g, k);\n        break;\n\n      case \"triangleRight\":\n        t = d.triangle(a, c, 90, e, h, f, g, k);\n        break;\n\n      case \"bubble\":\n        t = d.circle(a, c / 2, e, h, f, g, k, !0);\n        break;\n\n      case \"line\":\n        t = d.line(a, [-c / 2, c / 2], [0, 0], e, h, f, g, k);\n        break;\n\n      case \"yError\":\n        t = a.set();\n        t.push(d.line(a, [0, 0], [-c / 2, c / 2], e, h, f));\n        t.push(d.line(a, [-l, l], [-c / 2, -c / 2], e, h, f));\n        t.push(d.line(a, [-l, l], [c / 2, c / 2], e, h, f));\n        break;\n\n      case \"xError\":\n        t = a.set(), t.push(d.line(a, [-c / 2, c / 2], [0, 0], e, h, f)), t.push(d.line(a, [-c / 2, -c / 2], [-l, l], e, h, f)), t.push(d.line(a, [c / 2, c / 2], [-l, l], e, h, f));\n    }\n\n    t && t.pattern(p, NaN, q);\n    return t;\n  };\n\n  d.triangle = function (a, b, c, d, h, f, g, k) {\n    if (void 0 === f || 0 === f) f = 1;\n    void 0 === g && (g = \"#000\");\n    void 0 === k && (k = 0);\n    d = {\n      fill: d,\n      stroke: g,\n      \"fill-opacity\": h,\n      \"stroke-width\": f,\n      \"stroke-opacity\": k\n    };\n    b /= 2;\n    var l;\n    0 === c && (l = \" M\" + -b + \",\" + b + \" L0,\" + -b + \" L\" + b + \",\" + b + \" Z\");\n    180 == c && (l = \" M\" + -b + \",\" + -b + \" L0,\" + b + \" L\" + b + \",\" + -b + \" Z\");\n    90 == c && (l = \" M\" + -b + \",\" + -b + \" L\" + b + \",0 L\" + -b + \",\" + b + \" Z\");\n    270 == c && (l = \" M\" + -b + \",0 L\" + b + \",\" + b + \" L\" + b + \",\" + -b + \" Z\");\n    return a.path(l).attr(d);\n  };\n\n  d.line = function (a, b, c, e, h, f, g, k, l, m, p) {\n    if (a.handDrawn && !p) return d.handDrawnLine(a, b, c, e, h, f, g, k, l, m, p);\n    f = {\n      fill: \"none\",\n      \"stroke-width\": f\n    };\n    void 0 !== g && 0 < g && (f[\"stroke-dasharray\"] = g);\n    isNaN(h) || (f[\"stroke-opacity\"] = h);\n    e && (f.stroke = e);\n    e = Math.round;\n    m && (e = Number, b[0] = d.roundTo(b[0], 5), c[0] = d.roundTo(c[0], 5));\n    m = d.dx;\n    h = d.dy;\n    g = \"M\" + (e(b[0]) + m) + \",\" + (e(c[0]) + h);\n\n    for (k = 1; k < b.length; k++) b[k] = d.roundTo(b[k], 5), c[k] = d.roundTo(c[k], 5), g += \" L\" + (e(b[k]) + m) + \",\" + (e(c[k]) + h);\n\n    if (d.VML) return a.path(g, void 0, !0).attr(f);\n    l && (g += \" M0,0 L0,0\");\n    return a.path(g).attr(f);\n  };\n\n  d.makeHD = function (a, b, c) {\n    for (var d = [], h = [], f = 1; f < a.length; f++) for (var g = Number(a[f - 1]), k = Number(b[f - 1]), l = Number(a[f]), m = Number(b[f]), p = Math.round(Math.sqrt(Math.pow(l - g, 2) + Math.pow(m - k, 2)) / 50) + 1, l = (l - g) / p, m = (m - k) / p, q = 0; q <= p; q++) {\n      var n = k + q * m + Math.random() * c;\n      d.push(g + q * l + Math.random() * c);\n      h.push(n);\n    }\n\n    return [d, h];\n  };\n\n  d.handDrawnLine = function (a, b, c, e, h, f, g, k, l, m) {\n    var p,\n        q = a.set();\n\n    for (p = 1; p < b.length; p++) for (var n = [b[p - 1], b[p]], t = [c[p - 1], c[p]], t = d.makeHD(n, t, a.handDrawScatter), n = t[0], t = t[1], r = 1; r < n.length; r++) q.push(d.line(a, [n[r - 1], n[r]], [t[r - 1], t[r]], e, h, f + Math.random() * a.handDrawThickness - a.handDrawThickness / 2, g, k, l, m, !0));\n\n    return q;\n  };\n\n  d.doNothing = function (a) {\n    return a;\n  };\n\n  d.drop = function (a, b, c, d, h, f, g, k) {\n    var l = 1 / 180 * Math.PI,\n        m = c - 20,\n        p = Math.sin(m * l) * b,\n        q = Math.cos(m * l) * b,\n        n = Math.sin((m + 40) * l) * b,\n        t = Math.cos((m + 40) * l) * b,\n        r = .8 * b,\n        w = -b / 3,\n        z = b / 3;\n    0 === c && (w = -w, z = 0);\n    180 == c && (z = 0);\n    90 == c && (w = 0);\n    270 == c && (w = 0, z = -z);\n    c = {\n      fill: d,\n      stroke: g,\n      \"stroke-width\": f,\n      \"stroke-opacity\": k,\n      \"fill-opacity\": h\n    };\n    b = \"M\" + p + \",\" + q + \" A\" + b + \",\" + b + \",0,1,1,\" + n + \",\" + t + (\" A\" + r + \",\" + r + \",0,0,0,\" + (Math.sin((m + 20) * l) * b + z) + \",\" + (Math.cos((m + 20) * l) * b + w));\n    b += \" A\" + r + \",\" + r + \",0,0,0,\" + p + \",\" + q;\n    return a.path(b, void 0, void 0, \"1000,1000\").attr(c);\n  };\n\n  d.wedge = function (a, b, c, e, h, f, g, k, l, m, p, q, n, t) {\n    var r = Math.round;\n    f = r(f);\n    g = r(g);\n    k = r(k);\n    var w = r(g / f * k),\n        z = d.VML,\n        x = 359.5 + f / 100;\n    359.94 < x && (x = 359.94);\n    h >= x && (h = x);\n    var u = 1 / 180 * Math.PI,\n        x = b + Math.sin(e * u) * k,\n        A = c - Math.cos(e * u) * w,\n        y = b + Math.sin(e * u) * f,\n        B = c - Math.cos(e * u) * g,\n        D = b + Math.sin((e + h) * u) * f,\n        C = c - Math.cos((e + h) * u) * g,\n        I = b + Math.sin((e + h) * u) * k,\n        u = c - Math.cos((e + h) * u) * w,\n        H = {\n      fill: d.adjustLuminosity(m.fill, -.2),\n      \"stroke-opacity\": 0,\n      \"fill-opacity\": m[\"fill-opacity\"]\n    },\n        Q = 0;\n    180 < Math.abs(h) && (Q = 1);\n    e = a.set();\n    var M;\n    z && (x = r(10 * x), y = r(10 * y), D = r(10 * D), I = r(10 * I), A = r(10 * A), B = r(10 * B), C = r(10 * C), u = r(10 * u), b = r(10 * b), l = r(10 * l), c = r(10 * c), f *= 10, g *= 10, k *= 10, w *= 10, 1 > Math.abs(h) && 1 >= Math.abs(D - y) && 1 >= Math.abs(C - B) && (M = !0));\n    h = \"\";\n    var P;\n    q && (H[\"fill-opacity\"] = 0, H[\"stroke-opacity\"] = m[\"stroke-opacity\"] / 2, H.stroke = m.stroke);\n\n    if (0 < l) {\n      P = \" M\" + x + \",\" + (A + l) + \" L\" + y + \",\" + (B + l);\n      z ? (M || (P += \" A\" + (b - f) + \",\" + (l + c - g) + \",\" + (b + f) + \",\" + (l + c + g) + \",\" + y + \",\" + (B + l) + \",\" + D + \",\" + (C + l)), P += \" L\" + I + \",\" + (u + l), 0 < k && (M || (P += \" B\" + (b - k) + \",\" + (l + c - w) + \",\" + (b + k) + \",\" + (l + c + w) + \",\" + I + \",\" + (l + u) + \",\" + x + \",\" + (l + A)))) : (P += \" A\" + f + \",\" + g + \",0,\" + Q + \",1,\" + D + \",\" + (C + l) + \" L\" + I + \",\" + (u + l), 0 < k && (P += \" A\" + k + \",\" + w + \",0,\" + Q + \",0,\" + x + \",\" + (A + l)));\n      P += \" Z\";\n      var ia = l;\n      z && (ia /= 10);\n\n      for (var J = 0; J < ia; J += 10) {\n        var aa = a.path(P, void 0, void 0, \"1000,1000\").attr(H);\n        e.push(aa);\n        aa.translate(0, -J);\n      }\n\n      P = a.path(\" M\" + x + \",\" + A + \" L\" + x + \",\" + (A + l) + \" L\" + y + \",\" + (B + l) + \" L\" + y + \",\" + B + \" L\" + x + \",\" + A + \" Z\", void 0, void 0, \"1000,1000\").attr(H);\n      l = a.path(\" M\" + D + \",\" + C + \" L\" + D + \",\" + (C + l) + \" L\" + I + \",\" + (u + l) + \" L\" + I + \",\" + u + \" L\" + D + \",\" + C + \" Z\", void 0, void 0, \"1000,1000\").attr(H);\n      e.push(P);\n      e.push(l);\n    }\n\n    z ? (M || (h = \" A\" + r(b - f) + \",\" + r(c - g) + \",\" + r(b + f) + \",\" + r(c + g) + \",\" + r(y) + \",\" + r(B) + \",\" + r(D) + \",\" + r(C)), g = \" M\" + r(x) + \",\" + r(A) + \" L\" + r(y) + \",\" + r(B) + h + \" L\" + r(I) + \",\" + r(u)) : g = \" M\" + x + \",\" + A + \" L\" + y + \",\" + B + (\" A\" + f + \",\" + g + \",0,\" + Q + \",1,\" + D + \",\" + C) + \" L\" + I + \",\" + u;\n    0 < k && (z ? M || (g += \" B\" + (b - k) + \",\" + (c - w) + \",\" + (b + k) + \",\" + (c + w) + \",\" + I + \",\" + u + \",\" + x + \",\" + A) : g += \" A\" + k + \",\" + w + \",0,\" + Q + \",0,\" + x + \",\" + A);\n    a.handDrawn && (k = d.line(a, [x, y], [A, B], m.stroke, m.thickness * Math.random() * a.handDrawThickness, m[\"stroke-opacity\"]), e.push(k));\n    a = a.path(g + \" Z\", void 0, void 0, \"1000,1000\").attr(m);\n\n    if (p) {\n      k = [];\n\n      for (w = 0; w < p.length; w++) k.push(d.adjustLuminosity(m.fill, p[w]));\n\n      \"radial\" != t || d.isModern || (k = []);\n      0 < k.length && a.gradient(t + \"Gradient\", k);\n    }\n\n    d.isModern && \"radial\" == t && a.grad && (a.grad.setAttribute(\"gradientUnits\", \"userSpaceOnUse\"), a.grad.setAttribute(\"r\", f), a.grad.setAttribute(\"cx\", b), a.grad.setAttribute(\"cy\", c));\n    a.pattern(q, NaN, n);\n    e.wedge = a;\n    e.push(a);\n    return e;\n  };\n\n  d.rgb2hex = function (a) {\n    return (a = a.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i)) && 4 === a.length ? \"#\" + (\"0\" + parseInt(a[1], 10).toString(16)).slice(-2) + (\"0\" + parseInt(a[2], 10).toString(16)).slice(-2) + (\"0\" + parseInt(a[3], 10).toString(16)).slice(-2) : \"\";\n  };\n\n  d.adjustLuminosity = function (a, b) {\n    a && -1 != a.indexOf(\"rgb\") && (a = d.rgb2hex(a));\n    a = String(a).replace(/[^0-9a-f]/gi, \"\");\n    6 > a.length && (a = String(a[0]) + String(a[0]) + String(a[1]) + String(a[1]) + String(a[2]) + String(a[2]));\n    b = b || 0;\n    var c = \"#\",\n        e,\n        h;\n\n    for (h = 0; 3 > h; h++) e = parseInt(a.substr(2 * h, 2), 16), e = Math.round(Math.min(Math.max(0, e + e * b), 255)).toString(16), c += (\"00\" + e).substr(e.length);\n\n    return c;\n  };\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.Bezier = d.Class({\n    construct: function (a, b, c, e, h, f, g, k, l, m, p) {\n      var q = a.chart,\n          n = d.bezierX,\n          t = d.bezierY;\n      isNaN(q.bezierX) || (n = q.bezierX);\n      isNaN(q.bezierY) || (t = q.bezierY);\n      isNaN(n) && (q.rotate ? (n = 20, t = 4) : (t = 20, n = 4));\n      var r, w;\n      \"object\" == typeof g && 1 < g.length && (w = !0, r = g, g = g[0]);\n      \"object\" == typeof k && (k = k[0]);\n      0 === k && (g = \"none\");\n      f = {\n        fill: g,\n        \"fill-opacity\": k,\n        \"stroke-width\": f\n      };\n      void 0 !== l && 0 < l && (f[\"stroke-dasharray\"] = l);\n      isNaN(h) || (f[\"stroke-opacity\"] = h);\n      e && (f.stroke = e);\n      e = \"M\" + Math.round(b[0]) + \",\" + Math.round(c[0]) + \" \";\n      h = [];\n\n      for (l = 0; l < b.length; l++) isNaN(b[l]) || isNaN(c[l]) ? (e += this.drawSegment(h, n, t), l < b.length - 1 && (e += \"L\" + b[l + 1] + \",\" + c[l + 1] + \" \"), h = []) : h.push({\n        x: Number(b[l]),\n        y: Number(c[l])\n      });\n\n      e += this.drawSegment(h, n, t);\n      m ? e += m : d.VML || (e += \"M0,0 L0,0\");\n      this.path = a.path(e).attr(f);\n      this.node = this.path.node;\n      w && this.path.gradient(\"linearGradient\", r, p);\n    },\n    drawSegment: function (a, b, c) {\n      var d = \"\";\n      if (2 < a.length) for (var h = 0; h < a.length - 1; h++) {\n        var f = [],\n            g = a[h - 1],\n            k = a[h],\n            l = a[h + 1],\n            m = a[h + 2];\n        0 === h ? (f.push({\n          x: k.x,\n          y: k.y\n        }), f.push({\n          x: k.x,\n          y: k.y\n        }), f.push({\n          x: l.x,\n          y: l.y\n        }), f.push({\n          x: m.x,\n          y: m.y\n        })) : h >= a.length - 2 ? (f.push({\n          x: g.x,\n          y: g.y\n        }), f.push({\n          x: k.x,\n          y: k.y\n        }), f.push({\n          x: l.x,\n          y: l.y\n        }), f.push({\n          x: l.x,\n          y: l.y\n        })) : (f.push({\n          x: g.x,\n          y: g.y\n        }), f.push({\n          x: k.x,\n          y: k.y\n        }), f.push({\n          x: l.x,\n          y: l.y\n        }), f.push({\n          x: m.x,\n          y: m.y\n        }));\n        g = [];\n        k = Math.round;\n        g.push({\n          x: k(f[1].x),\n          y: k(f[1].y)\n        });\n        g.push({\n          x: k((-f[0].x + b * f[1].x + f[2].x) / b),\n          y: k((-f[0].y + c * f[1].y + f[2].y) / c)\n        });\n        g.push({\n          x: k((f[1].x + b * f[2].x - f[3].x) / b),\n          y: k((f[1].y + c * f[2].y - f[3].y) / c)\n        });\n        g.push({\n          x: k(f[2].x),\n          y: k(f[2].y)\n        });\n        d += \"C\" + g[1].x + \",\" + g[1].y + \",\" + g[2].x + \",\" + g[2].y + \",\" + g[3].x + \",\" + g[3].y + \" \";\n      } else 1 < a.length && (d += \"L\" + a[1].x + \",\" + a[1].y);\n      return d;\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmDraw = d.Class({\n    construct: function (a, b, c, e) {\n      d.SVG_NS = \"http://www.w3.org/2000/svg\";\n      d.SVG_XLINK = \"http://www.w3.org/1999/xlink\";\n      d.hasSVG = !!document.createElementNS && !!document.createElementNS(d.SVG_NS, \"svg\").createSVGRect;\n      1 > b && (b = 10);\n      1 > c && (c = 10);\n      this.div = a;\n      this.width = b;\n      this.height = c;\n      this.rBin = document.createElement(\"div\");\n      d.hasSVG ? (d.SVG = !0, b = this.createSvgElement(\"svg\"), a.appendChild(b), this.container = b, this.addDefs(e), this.R = new d.SVGRenderer(this)) : d.isIE && d.VMLRenderer && (d.VML = !0, d.vmlStyleSheet || (document.namespaces.add(\"amvml\", \"urn:schemas-microsoft-com:vml\"), 31 > document.styleSheets.length ? (b = document.createStyleSheet(), b.addRule(\".amvml\", \"behavior:url(#default#VML); display:inline-block; antialias:true\"), d.vmlStyleSheet = b) : document.styleSheets[0].addRule(\".amvml\", \"behavior:url(#default#VML); display:inline-block; antialias:true\")), this.container = a, this.R = new d.VMLRenderer(this, e), this.R.disableSelection(a));\n    },\n    createSvgElement: function (a) {\n      return document.createElementNS(d.SVG_NS, a);\n    },\n    circle: function (a, b, c, e) {\n      var h = new d.AmDObject(\"circle\", this);\n      h.attr({\n        r: c,\n        cx: a,\n        cy: b\n      });\n      this.addToContainer(h.node, e);\n      return h;\n    },\n    ellipse: function (a, b, c, e, h) {\n      var f = new d.AmDObject(\"ellipse\", this);\n      f.attr({\n        rx: c,\n        ry: e,\n        cx: a,\n        cy: b\n      });\n      this.addToContainer(f.node, h);\n      return f;\n    },\n    setSize: function (a, b) {\n      0 < a && 0 < b && (this.container.style.width = a + \"px\", this.container.style.height = b + \"px\");\n    },\n    rect: function (a, b, c, e, h, f, g) {\n      var k = new d.AmDObject(\"rect\", this);\n      d.VML && (h = Math.round(100 * h / Math.min(c, e)), c += 2 * f, e += 2 * f, k.bw = f, k.node.style.marginLeft = -f, k.node.style.marginTop = -f);\n      1 > c && (c = 1);\n      1 > e && (e = 1);\n      k.attr({\n        x: a,\n        y: b,\n        width: c,\n        height: e,\n        rx: h,\n        ry: h,\n        \"stroke-width\": f\n      });\n      this.addToContainer(k.node, g);\n      return k;\n    },\n    image: function (a, b, c, e, h, f) {\n      var g = new d.AmDObject(\"image\", this);\n      g.attr({\n        x: b,\n        y: c,\n        width: e,\n        height: h\n      });\n      this.R.path(g, a);\n      this.addToContainer(g.node, f);\n      return g;\n    },\n    addToContainer: function (a, b) {\n      b || (b = this.container);\n      b.appendChild(a);\n    },\n    text: function (a, b, c) {\n      return this.R.text(a, b, c);\n    },\n    path: function (a, b, c, e) {\n      var h = new d.AmDObject(\"path\", this);\n      e || (e = \"100,100\");\n      h.attr({\n        cs: e\n      });\n      c ? h.attr({\n        dd: a\n      }) : h.attr({\n        d: a\n      });\n      this.addToContainer(h.node, b);\n      return h;\n    },\n    set: function (a) {\n      return this.R.set(a);\n    },\n    remove: function (a) {\n      if (a) {\n        var b = this.rBin;\n        b.appendChild(a);\n        b.innerHTML = \"\";\n      }\n    },\n    renderFix: function () {\n      var a = this.container,\n          b = a.style;\n      b.top = \"0px\";\n      b.left = \"0px\";\n\n      try {\n        var c = a.getBoundingClientRect(),\n            d = c.left - Math.round(c.left),\n            h = c.top - Math.round(c.top);\n        d && (b.left = d + \"px\");\n        h && (b.top = h + \"px\");\n      } catch (f) {}\n    },\n    update: function () {\n      this.R.update();\n    },\n    addDefs: function (a) {\n      if (d.hasSVG) {\n        var b = this.createSvgElement(\"desc\"),\n            c = this.container;\n        c.setAttribute(\"version\", \"1.1\");\n        c.style.position = \"absolute\";\n        this.setSize(this.width, this.height);\n\n        if (a.accessibleTitle) {\n          var e = this.createSvgElement(\"text\");\n          c.appendChild(e);\n          e.innerHTML = a.accessibleTitle;\n          e.style.opacity = 0;\n        }\n\n        d.rtl && (c.setAttribute(\"direction\", \"rtl\"), c.style.left = \"auto\", c.style.right = \"0px\");\n        a && (a.addCodeCredits && b.appendChild(document.createTextNode(\"JavaScript chart by amCharts \" + a.version)), c.appendChild(b), a.defs && (b = this.createSvgElement(\"defs\"), c.appendChild(b), d.parseDefs(a.defs, b), this.defs = b));\n      }\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmDObject = d.Class({\n    construct: function (a, b) {\n      this.D = b;\n      this.R = b.R;\n      this.node = this.R.create(this, a);\n      this.y = this.x = 0;\n      this.scale = 1;\n    },\n    attr: function (a) {\n      this.R.attr(this, a);\n      return this;\n    },\n    getAttr: function (a) {\n      return this.node.getAttribute(a);\n    },\n    setAttr: function (a, b) {\n      this.R.setAttr(this, a, b);\n      return this;\n    },\n    clipRect: function (a, b, c, d) {\n      this.R.clipRect(this, a, b, c, d);\n    },\n    translate: function (a, b, c, d) {\n      d || (a = Math.round(a), b = Math.round(b));\n      this.R.move(this, a, b, c);\n      this.x = a;\n      this.y = b;\n      this.scale = c;\n      this.angle && this.rotate(this.angle);\n    },\n    rotate: function (a, b) {\n      this.R.rotate(this, a, b);\n      this.angle = a;\n    },\n    animate: function (a, b, c) {\n      for (var e in a) if (a.hasOwnProperty(e)) {\n        var h = e,\n            f = a[e];\n        c = d.getEffect(c);\n        this.R.animate(this, h, f, b, c);\n      }\n    },\n    push: function (a) {\n      if (a) {\n        var b = this.node;\n        b.appendChild(a.node);\n        var c = a.clipPath;\n        c && b.appendChild(c);\n        (a = a.grad) && b.appendChild(a);\n      }\n    },\n    text: function (a) {\n      this.R.setText(this, a);\n    },\n    remove: function () {\n      this.stop();\n      this.R.remove(this);\n    },\n    clear: function () {\n      var a = this.node;\n      if (a.hasChildNodes()) for (; 1 <= a.childNodes.length;) a.removeChild(a.firstChild);\n    },\n    hide: function () {\n      this.setAttr(\"visibility\", \"hidden\");\n    },\n    show: function () {\n      this.setAttr(\"visibility\", \"visible\");\n    },\n    getBBox: function () {\n      return this.R.getBBox(this);\n    },\n    toFront: function () {\n      var a = this.node;\n\n      if (a) {\n        this.prevNextNode = a.nextSibling;\n        var b = a.parentNode;\n        b && b.appendChild(a);\n      }\n    },\n    toPrevious: function () {\n      var a = this.node;\n      a && this.prevNextNode && (a = a.parentNode) && a.insertBefore(this.prevNextNode, null);\n    },\n    toBack: function () {\n      var a = this.node;\n\n      if (a) {\n        this.prevNextNode = a.nextSibling;\n        var b = a.parentNode;\n\n        if (b) {\n          var c = b.firstChild;\n          c && b.insertBefore(a, c);\n        }\n      }\n    },\n    mouseover: function (a) {\n      this.R.addListener(this, \"mouseover\", a);\n      return this;\n    },\n    mouseout: function (a) {\n      this.R.addListener(this, \"mouseout\", a);\n      return this;\n    },\n    click: function (a) {\n      this.R.addListener(this, \"click\", a);\n      return this;\n    },\n    dblclick: function (a) {\n      this.R.addListener(this, \"dblclick\", a);\n      return this;\n    },\n    mousedown: function (a) {\n      this.R.addListener(this, \"mousedown\", a);\n      return this;\n    },\n    mouseup: function (a) {\n      this.R.addListener(this, \"mouseup\", a);\n      return this;\n    },\n    touchmove: function (a) {\n      this.R.addListener(this, \"touchmove\", a);\n      return this;\n    },\n    touchstart: function (a) {\n      this.R.addListener(this, \"touchstart\", a);\n      return this;\n    },\n    touchend: function (a) {\n      this.R.addListener(this, \"touchend\", a);\n      return this;\n    },\n    keyup: function (a) {\n      this.R.addListener(this, \"keyup\", a);\n      return this;\n    },\n    focus: function (a) {\n      this.R.addListener(this, \"focus\", a);\n      return this;\n    },\n    blur: function (a) {\n      this.R.addListener(this, \"blur\", a);\n      return this;\n    },\n    contextmenu: function (a) {\n      this.node.addEventListener ? this.node.addEventListener(\"contextmenu\", a, !0) : this.R.addListener(this, \"contextmenu\", a);\n      return this;\n    },\n    stop: function () {\n      d.removeFromArray(this.R.animations, this.an_translate);\n      d.removeFromArray(this.R.animations, this.an_y);\n      d.removeFromArray(this.R.animations, this.an_x);\n    },\n    length: function () {\n      return this.node.childNodes.length;\n    },\n    gradient: function (a, b, c) {\n      this.R.gradient(this, a, b, c);\n    },\n    pattern: function (a, b, c) {\n      a && this.R.pattern(this, a, b, c);\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.VMLRenderer = d.Class({\n    construct: function (a, b) {\n      this.chart = b;\n      this.D = a;\n      this.cNames = {\n        circle: \"oval\",\n        ellipse: \"oval\",\n        rect: \"roundrect\",\n        path: \"shape\"\n      };\n      this.styleMap = {\n        x: \"left\",\n        y: \"top\",\n        width: \"width\",\n        height: \"height\",\n        \"font-family\": \"fontFamily\",\n        \"font-size\": \"fontSize\",\n        visibility: \"visibility\"\n      };\n    },\n    create: function (a, b) {\n      var c;\n      if (\"group\" == b) c = document.createElement(\"div\"), a.type = \"div\";else if (\"text\" == b) c = document.createElement(\"div\"), a.type = \"text\";else if (\"image\" == b) c = document.createElement(\"img\"), a.type = \"image\";else {\n        a.type = \"shape\";\n        a.shapeType = this.cNames[b];\n        c = document.createElement(\"amvml:\" + this.cNames[b]);\n        var d = document.createElement(\"amvml:stroke\");\n        c.appendChild(d);\n        a.stroke = d;\n        var h = document.createElement(\"amvml:fill\");\n        c.appendChild(h);\n        a.fill = h;\n        h.className = \"amvml\";\n        d.className = \"amvml\";\n        c.className = \"amvml\";\n      }\n      c.style.position = \"absolute\";\n      c.style.top = 0;\n      c.style.left = 0;\n      return c;\n    },\n    path: function (a, b) {\n      a.node.setAttribute(\"src\", b);\n    },\n    setAttr: function (a, b, c) {\n      if (void 0 !== c) {\n        var e;\n        8 === document.documentMode && (e = !0);\n        var h = a.node,\n            f = a.type,\n            g = h.style;\n        \"r\" == b && (g.width = 2 * c, g.height = 2 * c);\n        \"oval\" == a.shapeType && (\"rx\" == b && (g.width = 2 * c), \"ry\" == b && (g.height = 2 * c));\n        \"roundrect\" == a.shapeType && (\"width\" != b && \"height\" != b || --c);\n        \"cursor\" == b && (g.cursor = c);\n        \"cx\" == b && (g.left = c - d.removePx(g.width) / 2);\n        \"cy\" == b && (g.top = c - d.removePx(g.height) / 2);\n        var k = this.styleMap[b];\n        \"width\" == k && 0 > c && (c = 0);\n        void 0 !== k && (g[k] = c);\n        \"text\" == f && (\"text-anchor\" == b && (a.anchor = c, k = h.clientWidth, \"end\" == c && (g.marginLeft = -k + \"px\"), \"middle\" == c && (g.marginLeft = -(k / 2) + \"px\", g.textAlign = \"center\"), \"start\" == c && (g.marginLeft = \"0px\")), \"fill\" == b && (g.color = c), \"font-weight\" == b && (g.fontWeight = c));\n        if (g = a.children) for (k = 0; k < g.length; k++) g[k].setAttr(b, c);\n\n        if (\"shape\" == f) {\n          \"cs\" == b && (h.style.width = \"100px\", h.style.height = \"100px\", h.setAttribute(\"coordsize\", c));\n          \"d\" == b && h.setAttribute(\"path\", this.svgPathToVml(c));\n          \"dd\" == b && h.setAttribute(\"path\", c);\n          f = a.stroke;\n          a = a.fill;\n          \"stroke\" == b && (e ? f.color = c : f.setAttribute(\"color\", c));\n          \"stroke-width\" == b && (e ? f.weight = c : f.setAttribute(\"weight\", c));\n          \"stroke-opacity\" == b && (e ? f.opacity = c : f.setAttribute(\"opacity\", c));\n          \"stroke-dasharray\" == b && (g = \"solid\", 0 < c && 3 > c && (g = \"dot\"), 3 <= c && 6 >= c && (g = \"dash\"), 6 < c && (g = \"longdash\"), e ? f.dashstyle = g : f.setAttribute(\"dashstyle\", g));\n          if (\"fill-opacity\" == b || \"opacity\" == b) 0 === c ? e ? a.on = !1 : a.setAttribute(\"on\", !1) : e ? a.opacity = c : a.setAttribute(\"opacity\", c);\n          \"fill\" == b && (e ? a.color = c : a.setAttribute(\"color\", c));\n          \"rx\" == b && (e ? h.arcSize = c + \"%\" : h.setAttribute(\"arcsize\", c + \"%\"));\n        }\n      }\n    },\n    attr: function (a, b) {\n      for (var c in b) b.hasOwnProperty(c) && this.setAttr(a, c, b[c]);\n    },\n    text: function (a, b, c) {\n      var e = new d.AmDObject(\"text\", this.D),\n          h = e.node;\n      h.style.whiteSpace = \"pre\";\n      h.innerHTML = a;\n      this.D.addToContainer(h, c);\n      this.attr(e, b);\n      return e;\n    },\n    getBBox: function (a) {\n      return this.getBox(a.node);\n    },\n    getBox: function (a) {\n      var b = a.offsetLeft,\n          c = a.offsetTop,\n          d = a.offsetWidth,\n          h = a.offsetHeight,\n          f;\n\n      if (a.hasChildNodes()) {\n        var g, k, l;\n\n        for (l = 0; l < a.childNodes.length; l++) {\n          f = this.getBox(a.childNodes[l]);\n          var m = f.x;\n          isNaN(m) || (isNaN(g) ? g = m : m < g && (g = m));\n          var p = f.y;\n          isNaN(p) || (isNaN(k) ? k = p : p < k && (k = p));\n          m = f.width + m;\n          isNaN(m) || (d = Math.max(d, m));\n          f = f.height + p;\n          isNaN(f) || (h = Math.max(h, f));\n        }\n\n        0 > g && (b += g);\n        0 > k && (c += k);\n      }\n\n      return {\n        x: b,\n        y: c,\n        width: d,\n        height: h\n      };\n    },\n    setText: function (a, b) {\n      var c = a.node;\n      c && (c.innerHTML = b);\n      this.setAttr(a, \"text-anchor\", a.anchor);\n    },\n    addListener: function (a, b, c) {\n      a.node[\"on\" + b] = c;\n    },\n    move: function (a, b, c) {\n      var e = a.node,\n          h = e.style;\n      \"text\" == a.type && (c -= d.removePx(h.fontSize) / 2 - 1);\n      \"oval\" == a.shapeType && (b -= d.removePx(h.width) / 2, c -= d.removePx(h.height) / 2);\n      a = a.bw;\n      isNaN(a) || (b -= a, c -= a);\n      isNaN(b) || isNaN(c) || (e.style.left = b + \"px\", e.style.top = c + \"px\");\n    },\n    svgPathToVml: function (a) {\n      var b = a.split(\" \");\n      a = \"\";\n      var c,\n          d = Math.round,\n          h;\n\n      for (h = 0; h < b.length; h++) {\n        var f = b[h],\n            g = f.substring(0, 1),\n            f = f.substring(1),\n            k = f.split(\",\"),\n            l = d(k[0]) + \",\" + d(k[1]);\n        \"M\" == g && (a += \" m \" + l);\n        \"L\" == g && (a += \" l \" + l);\n        \"Z\" == g && (a += \" x e\");\n\n        if (\"Q\" == g) {\n          var m = c.length,\n              p = c[m - 1],\n              q = k[0],\n              n = k[1],\n              l = k[2],\n              t = k[3];\n          c = d(c[m - 2] / 3 + 2 / 3 * q);\n          p = d(p / 3 + 2 / 3 * n);\n          q = d(2 / 3 * q + l / 3);\n          n = d(2 / 3 * n + t / 3);\n          a += \" c \" + c + \",\" + p + \",\" + q + \",\" + n + \",\" + l + \",\" + t;\n        }\n\n        \"C\" == g && (a += \" c \" + k[0] + \",\" + k[1] + \",\" + k[2] + \",\" + k[3] + \",\" + k[4] + \",\" + k[5]);\n        \"A\" == g && (a += \" wa \" + f);\n        \"B\" == g && (a += \" at \" + f);\n        c = k;\n      }\n\n      return a;\n    },\n    animate: function (a, b, c, d, h) {\n      var f = a.node,\n          g = this.chart;\n      a.animationFinished = !1;\n\n      if (\"translate\" == b) {\n        b = c.split(\",\");\n        c = b[1];\n        var k = f.offsetTop;\n        g.animate(a, \"left\", f.offsetLeft, b[0], d, h, \"px\");\n        g.animate(a, \"top\", k, c, d, h, \"px\");\n      }\n    },\n    clipRect: function (a, b, c, d, h) {\n      a = a.node;\n      0 === b && 0 === c ? (a.style.width = d + \"px\", a.style.height = h + \"px\", a.style.overflow = \"hidden\") : a.style.clip = \"rect(\" + c + \"px \" + (b + d) + \"px \" + (c + h) + \"px \" + b + \"px)\";\n    },\n    rotate: function (a, b, c) {\n      if (0 !== Number(b)) {\n        var e = a.node;\n        a = e.style;\n        c || (c = this.getBGColor(e.parentNode));\n        a.backgroundColor = c;\n        a.paddingLeft = 1;\n        c = b * Math.PI / 180;\n        var h = Math.cos(c),\n            f = Math.sin(c),\n            g = d.removePx(a.left),\n            k = d.removePx(a.top),\n            l = e.offsetWidth,\n            e = e.offsetHeight;\n        b /= Math.abs(b);\n        a.left = g + l / 2 - l / 2 * Math.cos(c) - b * e / 2 * Math.sin(c) + 3;\n        a.top = k - b * l / 2 * Math.sin(c) + b * e / 2 * Math.sin(c);\n        a.cssText = a.cssText + \"; filter:progid:DXImageTransform.Microsoft.Matrix(M11='\" + h + \"', M12='\" + -f + \"', M21='\" + f + \"', M22='\" + h + \"', sizingmethod='auto expand');\";\n      }\n    },\n    getBGColor: function (a) {\n      var b = \"#FFFFFF\";\n\n      if (a.style) {\n        var c = a.style.backgroundColor;\n        \"\" !== c ? b = c : a.parentNode && (b = this.getBGColor(a.parentNode));\n      }\n\n      return b;\n    },\n    set: function (a) {\n      var b = new d.AmDObject(\"group\", this.D);\n      this.D.container.appendChild(b.node);\n\n      if (a) {\n        var c;\n\n        for (c = 0; c < a.length; c++) b.push(a[c]);\n      }\n\n      return b;\n    },\n    gradient: function (a, b, c, d) {\n      var h = \"\";\n      \"radialGradient\" == b && (b = \"gradientradial\", c.reverse());\n      \"linearGradient\" == b && (b = \"gradient\");\n      var f;\n\n      for (f = 0; f < c.length; f++) h += Math.round(100 * f / (c.length - 1)) + \"% \" + c[f], f < c.length - 1 && (h += \",\");\n\n      a = a.fill;\n      90 == d ? d = 0 : 270 == d ? d = 180 : 180 == d ? d = 90 : 0 === d && (d = 270);\n      8 === document.documentMode ? (a.type = b, a.angle = d) : (a.setAttribute(\"type\", b), a.setAttribute(\"angle\", d));\n      h && (a.colors.value = h);\n    },\n    remove: function (a) {\n      a.clipPath && this.D.remove(a.clipPath);\n      this.D.remove(a.node);\n    },\n    disableSelection: function (a) {\n      a.onselectstart = function () {\n        return !1;\n      };\n\n      a.style.cursor = \"default\";\n    },\n    pattern: function (a, b, c, e) {\n      c = a.node;\n      a = a.fill;\n      var h = \"none\";\n      b.color && (h = b.color);\n      c.fillColor = h;\n      b = b.url;\n      d.isAbsolute(b) || (b = e + b);\n      8 === document.documentMode ? (a.type = \"tile\", a.src = b) : (a.setAttribute(\"type\", \"tile\"), a.setAttribute(\"src\", b));\n    },\n    update: function () {}\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.SVGRenderer = d.Class({\n    construct: function (a) {\n      this.D = a;\n      this.animations = [];\n    },\n    create: function (a, b) {\n      return document.createElementNS(d.SVG_NS, b);\n    },\n    attr: function (a, b) {\n      for (var c in b) b.hasOwnProperty(c) && this.setAttr(a, c, b[c]);\n    },\n    setAttr: function (a, b, c) {\n      void 0 !== c && a.node.setAttribute(b, c);\n    },\n    animate: function (a, b, c, e, h) {\n      a.animationFinished = !1;\n      var f = a.node;\n      a[\"an_\" + b] && d.removeFromArray(this.animations, a[\"an_\" + b]);\n      \"translate\" == b ? (f = (f = f.getAttribute(\"transform\")) ? String(f).substring(10, f.length - 1) : \"0,0\", f = f.split(\", \").join(\" \"), f = f.split(\" \").join(\",\"), 0 === f && (f = \"0,0\")) : f = Number(f.getAttribute(b));\n      c = {\n        obj: a,\n        frame: 0,\n        attribute: b,\n        from: f,\n        to: c,\n        time: e,\n        effect: h\n      };\n      this.animations.push(c);\n      a[\"an_\" + b] = c;\n    },\n    update: function () {\n      var a,\n          b = this.animations;\n\n      for (a = b.length - 1; 0 <= a; a--) {\n        var c = b[a],\n            e = c.time * d.updateRate,\n            h = c.frame + 1,\n            f = c.obj,\n            g = c.attribute,\n            k,\n            l,\n            m;\n\n        if (h <= e) {\n          c.frame++;\n\n          if (\"translate\" == g) {\n            k = c.from.split(\",\");\n            g = Number(k[0]);\n            k = Number(k[1]);\n            isNaN(k) && (k = 0);\n            l = c.to.split(\",\");\n            m = Number(l[0]);\n            l = Number(l[1]);\n            m = 0 === m - g ? m : Math.round(d[c.effect](0, h, g, m - g, e));\n            c = 0 === l - k ? l : Math.round(d[c.effect](0, h, k, l - k, e));\n            g = \"transform\";\n            if (isNaN(m) || isNaN(c)) continue;\n            c = \"translate(\" + m + \",\" + c + \")\";\n          } else l = Number(c.from), k = Number(c.to), m = k - l, c = d[c.effect](0, h, l, m, e), isNaN(c) && (c = k), 0 === m && this.animations.splice(a, 1);\n\n          this.setAttr(f, g, c);\n        } else \"translate\" == g ? (l = c.to.split(\",\"), m = Number(l[0]), l = Number(l[1]), f.translate(m, l)) : (k = Number(c.to), this.setAttr(f, g, k)), f.animationFinished = !0, this.animations.splice(a, 1);\n      }\n    },\n    getBBox: function (a) {\n      if (a = a.node) try {\n        return a.getBBox();\n      } catch (b) {}\n      return {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n    },\n    path: function (a, b) {\n      a.node.setAttributeNS(d.SVG_XLINK, \"xlink:href\", b);\n    },\n    clipRect: function (a, b, c, e, h) {\n      var f = a.node,\n          g = a.clipPath;\n      g && this.D.remove(g);\n      var k = f.parentNode;\n      k && (f = document.createElementNS(d.SVG_NS, \"clipPath\"), g = d.getUniqueId(), f.setAttribute(\"id\", g), this.D.rect(b, c, e, h, 0, 0, f), k.appendChild(f), b = \"#\", d.baseHref && !d.isIE && (b = this.removeTarget(window.location.href) + b), this.setAttr(a, \"clip-path\", \"url(\" + b + g + \")\"), this.clipPathC++, a.clipPath = f);\n    },\n    text: function (a, b, c) {\n      var e = new d.AmDObject(\"text\", this.D);\n      a = String(a).split(\"\\n\");\n      var h = d.removePx(b[\"font-size\"]),\n          f;\n\n      for (f = 0; f < a.length; f++) {\n        var g = this.create(null, \"tspan\");\n        g.appendChild(document.createTextNode(a[f]));\n        g.setAttribute(\"y\", (h + 2) * f + Math.round(h / 2));\n        g.setAttribute(\"x\", 0);\n        e.node.appendChild(g);\n      }\n\n      e.node.setAttribute(\"y\", Math.round(h / 2));\n      this.attr(e, b);\n      this.D.addToContainer(e.node, c);\n      return e;\n    },\n    setText: function (a, b) {\n      var c = a.node;\n      c && (c.removeChild(c.firstChild), c.appendChild(document.createTextNode(b)));\n    },\n    move: function (a, b, c, d) {\n      isNaN(b) && (b = 0);\n      isNaN(c) && (c = 0);\n      b = \"translate(\" + b + \",\" + c + \")\";\n      d && (b = b + \" scale(\" + d + \")\");\n      this.setAttr(a, \"transform\", b);\n    },\n    rotate: function (a, b) {\n      var c = a.node.getAttribute(\"transform\"),\n          d = \"rotate(\" + b + \")\";\n      c && (d = c + \" \" + d);\n      this.setAttr(a, \"transform\", d);\n    },\n    set: function (a) {\n      var b = new d.AmDObject(\"g\", this.D);\n      this.D.container.appendChild(b.node);\n\n      if (a) {\n        var c;\n\n        for (c = 0; c < a.length; c++) b.push(a[c]);\n      }\n\n      return b;\n    },\n    addListener: function (a, b, c) {\n      a.node[\"on\" + b] = c;\n    },\n    gradient: function (a, b, c, e) {\n      var h = a.node,\n          f = a.grad;\n      f && this.D.remove(f);\n      b = document.createElementNS(d.SVG_NS, b);\n      f = d.getUniqueId();\n      b.setAttribute(\"id\", f);\n\n      if (!isNaN(e)) {\n        var g = 0,\n            k = 0,\n            l = 0,\n            m = 0;\n        90 == e ? l = 100 : 270 == e ? m = 100 : 180 == e ? g = 100 : 0 === e && (k = 100);\n        b.setAttribute(\"x1\", g + \"%\");\n        b.setAttribute(\"x2\", k + \"%\");\n        b.setAttribute(\"y1\", l + \"%\");\n        b.setAttribute(\"y2\", m + \"%\");\n      }\n\n      for (e = 0; e < c.length; e++) g = document.createElementNS(d.SVG_NS, \"stop\"), k = 100 * e / (c.length - 1), 0 === e && (k = 0), g.setAttribute(\"offset\", k + \"%\"), g.setAttribute(\"stop-color\", c[e]), b.appendChild(g);\n\n      h.parentNode.appendChild(b);\n      c = \"#\";\n      d.baseHref && !d.isIE && (c = this.removeTarget(window.location.href) + c);\n      h.setAttribute(\"fill\", \"url(\" + c + f + \")\");\n      a.grad = b;\n    },\n    removeTarget: function (a) {\n      return a.split(\"#\")[0];\n    },\n    pattern: function (a, b, c, e) {\n      var h = a.node;\n      isNaN(c) && (c = 1);\n      var f = a.patternNode;\n      f && this.D.remove(f);\n      var f = document.createElementNS(d.SVG_NS, \"pattern\"),\n          g = d.getUniqueId(),\n          k = b;\n      b.url && (k = b.url);\n      d.isAbsolute(k) || -1 != k.indexOf(\"data:image\") || (k = e + k);\n      e = Number(b.width);\n      isNaN(e) && (e = 4);\n      var l = Number(b.height);\n      isNaN(l) && (l = 4);\n      e /= c;\n      l /= c;\n      c = b.x;\n      isNaN(c) && (c = 0);\n      var m = -Math.random() * Number(b.randomX);\n      isNaN(m) || (c = m);\n      m = b.y;\n      isNaN(m) && (m = 0);\n      var p = -Math.random() * Number(b.randomY);\n      isNaN(p) || (m = p);\n      f.setAttribute(\"id\", g);\n      f.setAttribute(\"width\", e);\n      f.setAttribute(\"height\", l);\n      f.setAttribute(\"patternUnits\", \"userSpaceOnUse\");\n      f.setAttribute(\"xlink:href\", k);\n      b.color && (p = document.createElementNS(d.SVG_NS, \"rect\"), p.setAttributeNS(null, \"height\", e), p.setAttributeNS(null, \"width\", l), p.setAttributeNS(null, \"fill\", b.color), f.appendChild(p));\n      this.D.image(k, 0, 0, e, l, f).translate(c, m);\n      k = \"#\";\n      d.baseHref && !d.isIE && (k = this.removeTarget(window.location.href) + k);\n      h.setAttribute(\"fill\", \"url(\" + k + g + \")\");\n      a.patternNode = f;\n      h.parentNode.appendChild(f);\n    },\n    remove: function (a) {\n      a.clipPath && this.D.remove(a.clipPath);\n      a.grad && this.D.remove(a.grad);\n      a.patternNode && this.D.remove(a.patternNode);\n      this.D.remove(a.node);\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n  d.AmLegend = d.Class({\n    construct: function (a) {\n      this.enabled = !0;\n      this.cname = \"AmLegend\";\n      this.createEvents(\"rollOverMarker\", \"rollOverItem\", \"rollOutMarker\", \"rollOutItem\", \"showItem\", \"hideItem\", \"clickMarker\", \"clickLabel\");\n      this.position = \"bottom\";\n      this.borderColor = this.color = \"#000000\";\n      this.borderAlpha = 0;\n      this.markerLabelGap = 5;\n      this.verticalGap = 10;\n      this.align = \"left\";\n      this.horizontalGap = 0;\n      this.spacing = 10;\n      this.markerDisabledColor = \"#AAB3B3\";\n      this.markerType = \"square\";\n      this.markerSize = 16;\n      this.markerBorderThickness = this.markerBorderAlpha = 1;\n      this.marginBottom = this.marginTop = 0;\n      this.marginLeft = this.marginRight = 20;\n      this.autoMargins = !0;\n      this.valueWidth = 50;\n      this.switchable = !0;\n      this.switchType = \"x\";\n      this.switchColor = \"#FFFFFF\";\n      this.rollOverColor = \"#CC0000\";\n      this.reversedOrder = !1;\n      this.labelText = \"[[title]]\";\n      this.valueText = \"[[value]]\";\n      this.accessibleLabel = \"[[title]]\";\n      this.useMarkerColorForLabels = !1;\n      this.rollOverGraphAlpha = 1;\n      this.textClickEnabled = !1;\n      this.equalWidths = !0;\n      this.backgroundColor = \"#FFFFFF\";\n      this.backgroundAlpha = 0;\n      this.useGraphSettings = !1;\n      this.showEntries = !0;\n      this.labelDx = 0;\n      d.applyTheme(this, a, this.cname);\n    },\n    setData: function (a) {\n      this.legendData = a;\n      this.invalidateSize();\n    },\n    invalidateSize: function () {\n      this.destroy();\n      this.entries = [];\n      this.valueLabels = [];\n      var a = this.legendData;\n      this.enabled && (d.ifArray(a) || d.ifArray(this.data)) && this.drawLegend();\n    },\n    drawLegend: function () {\n      var a = this.chart,\n          b = this.position,\n          c = this.width,\n          e = a.divRealWidth,\n          h = a.divRealHeight,\n          f = this.div,\n          g = this.legendData;\n      this.data && (g = this.combineLegend ? this.legendData.concat(this.data) : this.data);\n      isNaN(this.fontSize) && (this.fontSize = a.fontSize);\n      this.maxColumnsReal = this.maxColumns;\n      if (\"right\" == b || \"left\" == b) this.maxColumnsReal = 1, this.autoMargins && (this.marginLeft = this.marginRight = 10);else if (this.autoMargins) {\n        this.marginRight = a.marginRight;\n        this.marginLeft = a.marginLeft;\n        var k = a.autoMarginOffset;\n        \"bottom\" == b ? (this.marginBottom = k, this.marginTop = 0) : (this.marginTop = k, this.marginBottom = 0);\n      }\n      c = void 0 !== c ? d.toCoordinate(c, e) : \"right\" != b && \"left\" != b ? a.realWidth : 0 < this.ieW ? this.ieW : a.realWidth;\n      \"outside\" == b ? (c = f.offsetWidth, h = f.offsetHeight, f.clientHeight && (c = f.clientWidth, h = f.clientHeight)) : (isNaN(c) || (f.style.width = c + \"px\"), f.className = \"amChartsLegend \" + a.classNamePrefix + \"-legend-div\");\n      this.divWidth = c;\n      (b = this.container) ? (b.container.innerHTML = \"\", f.appendChild(b.container), b.width = c, b.height = h, b.setSize(c, h), b.addDefs(a)) : b = new d.AmDraw(f, c, h, a);\n      this.container = b;\n      this.lx = 0;\n      this.ly = 8;\n      h = this.markerSize;\n      h > this.fontSize && (this.ly = h / 2 - 1);\n      0 < h && (this.lx += h + this.markerLabelGap);\n      this.titleWidth = 0;\n      if (h = this.title) h = d.text(this.container, h, this.color, a.fontFamily, this.fontSize, \"start\", !0), d.setCN(a, h, \"legend-title\"), h.translate(this.marginLeft, this.marginTop + this.verticalGap + this.ly + 1), a = h.getBBox(), this.titleWidth = a.width + 15, this.titleHeight = a.height + 6;\n      this.index = this.maxLabelWidth = 0;\n\n      if (this.showEntries) {\n        for (a = 0; a < g.length; a++) this.createEntry(g[a]);\n\n        for (a = this.index = 0; a < g.length; a++) this.createValue(g[a]);\n      }\n\n      this.arrangeEntries();\n      this.updateValues();\n    },\n    arrangeEntries: function () {\n      var a = this.position,\n          b = this.marginLeft + this.titleWidth,\n          c = this.marginRight,\n          e = this.marginTop,\n          h = this.marginBottom,\n          f = this.horizontalGap,\n          g = this.div,\n          k = this.divWidth,\n          l = this.maxColumnsReal,\n          m = this.verticalGap,\n          p = this.spacing,\n          q = k - c - b,\n          n = 0,\n          t = 0,\n          r = this.container;\n      this.set && this.set.remove();\n      var w = r.set();\n      this.set = w;\n      var z = r.set();\n      w.push(z);\n      var x = this.entries,\n          u,\n          A;\n\n      for (A = 0; A < x.length; A++) {\n        u = x[A].getBBox();\n        var y = u.width;\n        y > n && (n = y);\n        u = u.height;\n        u > t && (t = u);\n      }\n\n      var y = t = 0,\n          B = f,\n          D = 0,\n          C = 0;\n\n      for (A = 0; A < x.length; A++) {\n        var I = x[A];\n        this.reversedOrder && (I = x[x.length - A - 1]);\n        u = I.getBBox();\n        var H;\n        this.equalWidths ? H = y * (n + p + this.markerLabelGap) : (H = B, B = B + u.width + f + p);\n        H + u.width > q && 0 < A && 0 !== y && (t++, H = y = 0, B = H + u.width + f + p, D = D + C + m, C = 0);\n        u.height > C && (C = u.height);\n        I.translate(H, D);\n        y++;\n        !isNaN(l) && y >= l && (y = 0, t++, D = D + C + m, B = f, C = 0);\n        z.push(I);\n      }\n\n      u = z.getBBox();\n      l = u.height + 2 * m - 1;\n      \"left\" == a || \"right\" == a ? (p = u.width + 2 * f, k = p + b + c, g.style.width = k + \"px\", this.ieW = k) : p = k - b - c - 1;\n      c = d.polygon(this.container, [0, p, p, 0], [0, 0, l, l], this.backgroundColor, this.backgroundAlpha, 1, this.borderColor, this.borderAlpha);\n      d.setCN(this.chart, c, \"legend-bg\");\n      w.push(c);\n      w.translate(b, e);\n      c.toBack();\n      b = f;\n      if (\"top\" == a || \"bottom\" == a || \"absolute\" == a || \"outside\" == a) \"center\" == this.align ? b = f + (p - u.width) / 2 : \"right\" == this.align && (b = f + p - u.width);\n      z.translate(b, m + 1);\n      this.titleHeight > l && (l = this.titleHeight);\n      e = l + e + h + 1;\n      0 > e && (e = 0);\n      \"absolute\" != a && \"outside\" != a && e > this.chart.divRealHeight && (g.style.top = \"0px\");\n      g.style.height = Math.round(e) + \"px\";\n      r.setSize(this.divWidth, e);\n    },\n    createEntry: function (a) {\n      if (!1 !== a.visibleInLegend && !a.hideFromLegend) {\n        var b = this,\n            c = b.chart,\n            e = b.useGraphSettings,\n            h = a.markerType;\n        h && (e = !1);\n        a.legendEntryWidth = b.markerSize;\n        h || (h = b.markerType);\n        var f = a.color,\n            g = a.alpha;\n        a.legendKeyColor && (f = a.legendKeyColor());\n        a.legendKeyAlpha && (g = a.legendKeyAlpha());\n        var k;\n        !0 === a.hidden && (k = f = b.markerDisabledColor);\n        var l = a.pattern,\n            m,\n            p = a.customMarker;\n        p || (p = b.customMarker);\n        var q = b.container,\n            n = b.markerSize,\n            t = 0,\n            r = 0,\n            w = n / 2;\n\n        if (e) {\n          e = a.type;\n          b.switchType = void 0;\n          if (\"line\" == e || \"step\" == e || \"smoothedLine\" == e || \"ohlc\" == e) m = q.set(), a.hidden || (f = a.lineColorR, k = a.bulletBorderColorR), t = d.line(q, [0, 2 * n], [n / 2, n / 2], f, a.lineAlpha, a.lineThickness, a.dashLength), d.setCN(c, t, \"graph-stroke\"), m.push(t), a.bullet && (a.hidden || (f = a.bulletColorR), t = d.bullet(q, a.bullet, a.bulletSize, f, a.bulletAlpha, a.bulletBorderThickness, k, a.bulletBorderAlpha)) && (d.setCN(c, t, \"graph-bullet\"), t.translate(n + 1, n / 2), m.push(t)), w = 0, t = n, r = n / 3;else {\n            a.getGradRotation && (m = a.getGradRotation(), 0 === m && (m = 180));\n            t = a.fillColorsR;\n            !0 === a.hidden && (t = f);\n            if (m = b.createMarker(\"rectangle\", t, a.fillAlphas, a.lineThickness, f, a.lineAlpha, m, l, a.dashLength)) w = n, m.translate(w, n / 2);\n            t = n;\n          }\n          d.setCN(c, m, \"graph-\" + e);\n          d.setCN(c, m, \"graph-\" + a.id);\n        } else if (p) m = q.image(p, 0, 0, n, n);else {\n          var z;\n          isNaN(b.gradientRotation) || (z = 180 + b.gradientRotation);\n          (m = b.createMarker(h, f, g, void 0, void 0, void 0, z, l)) && m.translate(n / 2, n / 2);\n        }\n\n        d.setCN(c, m, \"legend-marker\");\n        b.addListeners(m, a);\n        q = q.set([m]);\n        b.switchable && a.switchable && q.setAttr(\"cursor\", \"pointer\");\n        void 0 !== a.id && d.setCN(c, q, \"legend-item-\" + a.id);\n        d.setCN(c, q, a.className, !0);\n        k = b.switchType;\n        var x;\n        k && \"none\" != k && 0 < n && (\"x\" == k ? (x = b.createX(), x.translate(n / 2, n / 2)) : x = b.createV(), x.dItem = a, !0 !== a.hidden ? \"x\" == k ? x.hide() : x.show() : \"x\" != k && x.hide(), b.switchable || x.hide(), b.addListeners(x, a), a.legendSwitch = x, q.push(x), d.setCN(c, x, \"legend-switch\"));\n        k = b.color;\n        a.showBalloon && b.textClickEnabled && void 0 !== b.selectedColor && (k = b.selectedColor);\n        b.useMarkerColorForLabels && !l && (k = f);\n        !0 === a.hidden && (k = b.markerDisabledColor);\n        f = d.massReplace(b.labelText, {\n          \"[[title]]\": a.title\n        });\n        void 0 !== b.tabIndex && (q.setAttr(\"tabindex\", b.tabIndex), q.setAttr(\"role\", \"menuitem\"), q.keyup(function (c) {\n          13 == c.keyCode && b.clickMarker(a, c);\n        }));\n        c.accessible && b.accessibleLabel && (l = d.massReplace(b.accessibleLabel, {\n          \"[[title]]\": a.title\n        }), c.makeAccessible(q, l));\n        l = b.fontSize;\n        m && (n <= l && (n = n / 2 + b.ly - l / 2 + (l + 2 - n) / 2 - r, m.translate(w, n), x && x.translate(x.x, n)), a.legendEntryWidth = m.getBBox().width);\n        var u;\n        f && (f = d.fixBrakes(f), a.legendTextReal = f, u = b.labelWidth, u = isNaN(u) ? d.text(b.container, f, k, c.fontFamily, l, \"start\") : d.wrappedText(b.container, f, k, c.fontFamily, l, \"start\", !1, u, 0), d.setCN(c, u, \"legend-label\"), u.translate(b.lx + t, b.ly), q.push(u), b.labelDx = t, c = u.getBBox().width, b.maxLabelWidth < c && (b.maxLabelWidth = c));\n        b.entries[b.index] = q;\n        a.legendEntry = b.entries[b.index];\n        a.legendMarker = m;\n        a.legendLabel = u;\n        b.index++;\n      }\n    },\n    addListeners: function (a, b) {\n      var c = this;\n      a && a.mouseover(function (a) {\n        c.rollOverMarker(b, a);\n      }).mouseout(function (a) {\n        c.rollOutMarker(b, a);\n      }).click(function (a) {\n        c.clickMarker(b, a);\n      });\n    },\n    rollOverMarker: function (a, b) {\n      this.switchable && this.dispatch(\"rollOverMarker\", a, b);\n      this.dispatch(\"rollOverItem\", a, b);\n    },\n    rollOutMarker: function (a, b) {\n      this.switchable && this.dispatch(\"rollOutMarker\", a, b);\n      this.dispatch(\"rollOutItem\", a, b);\n    },\n    clickMarker: function (a, b) {\n      this.switchable && (!0 === a.hidden ? this.dispatch(\"showItem\", a, b) : this.dispatch(\"hideItem\", a, b));\n      this.dispatch(\"clickMarker\", a, b);\n    },\n    rollOverLabel: function (a, b) {\n      a.hidden || this.textClickEnabled && a.legendLabel && a.legendLabel.attr({\n        fill: this.rollOverColor\n      });\n      this.dispatch(\"rollOverItem\", a, b);\n    },\n    rollOutLabel: function (a, b) {\n      if (!a.hidden && this.textClickEnabled && a.legendLabel) {\n        var c = this.color;\n        void 0 !== this.selectedColor && a.showBalloon && (c = this.selectedColor);\n        this.useMarkerColorForLabels && (c = a.lineColor, void 0 === c && (c = a.color));\n        a.legendLabel.attr({\n          fill: c\n        });\n      }\n\n      this.dispatch(\"rollOutItem\", a, b);\n    },\n    clickLabel: function (a, b) {\n      this.textClickEnabled ? a.hidden || this.dispatch(\"clickLabel\", a, b) : this.switchable && (!0 === a.hidden ? this.dispatch(\"showItem\", a, b) : this.dispatch(\"hideItem\", a, b));\n    },\n    dispatch: function (a, b, c) {\n      a = {\n        type: a,\n        dataItem: b,\n        target: this,\n        event: c,\n        chart: this.chart\n      };\n      this.chart && this.chart.handleLegendEvent(a);\n      this.fire(a);\n    },\n    createValue: function (a) {\n      var b = this,\n          c = b.fontSize,\n          e = b.chart;\n\n      if (!1 !== a.visibleInLegend && !a.hideFromLegend) {\n        var h = b.maxLabelWidth;\n        b.forceWidth && (h = b.labelWidth);\n        b.equalWidths || (b.valueAlign = \"left\");\n        \"left\" == b.valueAlign && a.legendLabel && (h = a.legendLabel.getBBox().width);\n        var f = h;\n\n        if (b.valueText && 0 < b.valueWidth) {\n          var g = b.color;\n          b.useMarkerColorForValues && (g = a.color, a.legendKeyColor && (g = a.legendKeyColor()));\n          !0 === a.hidden && (g = b.markerDisabledColor);\n          var k = b.valueText,\n              h = h + b.lx + b.labelDx + b.markerLabelGap + b.valueWidth,\n              l = \"end\";\n          \"left\" == b.valueAlign && (h -= b.valueWidth, l = \"start\");\n          g = d.text(b.container, k, g, b.chart.fontFamily, c, l);\n          d.setCN(e, g, \"legend-value\");\n          g.translate(h, b.ly);\n          b.entries[b.index].push(g);\n          f += b.valueWidth + 2 * b.markerLabelGap;\n          g.dItem = a;\n          b.valueLabels.push(g);\n        }\n\n        b.index++;\n        e = b.markerSize;\n        e < c + 7 && (e = c + 7, d.VML && (e += 3));\n        c = b.container.rect(a.legendEntryWidth, 0, f, e, 0, 0).attr({\n          stroke: \"none\",\n          fill: \"#fff\",\n          \"fill-opacity\": .005\n        });\n        c.dItem = a;\n        b.entries[b.index - 1].push(c);\n        c.mouseover(function (c) {\n          b.rollOverLabel(a, c);\n        }).mouseout(function (c) {\n          b.rollOutLabel(a, c);\n        }).click(function (c) {\n          b.clickLabel(a, c);\n        });\n      }\n    },\n    createV: function () {\n      var a = this.markerSize;\n      return d.polygon(this.container, [a / 5, a / 2, a - a / 5, a / 2], [a / 3, a - a / 5, a / 5, a / 1.7], this.switchColor);\n    },\n    createX: function () {\n      var a = (this.markerSize - 4) / 2,\n          b = {\n        stroke: this.switchColor,\n        \"stroke-width\": 3\n      },\n          c = this.container,\n          e = d.line(c, [-a, a], [-a, a]).attr(b),\n          a = d.line(c, [-a, a], [a, -a]).attr(b);\n      return this.container.set([e, a]);\n    },\n    createMarker: function (a, b, c, e, h, f, g, k, l) {\n      var m = this.markerSize,\n          p = this.container;\n      h || (h = this.markerBorderColor);\n      h || (h = b);\n      isNaN(e) && (e = this.markerBorderThickness);\n      isNaN(f) && (f = this.markerBorderAlpha);\n      return d.bullet(p, a, m, b, c, e, h, f, m, g, k, this.chart.path, l);\n    },\n    validateNow: function () {\n      this.invalidateSize();\n    },\n    updateValues: function () {\n      var a = this.valueLabels,\n          b = this.chart,\n          c,\n          e = this.data;\n      if (a) for (c = 0; c < a.length; c++) {\n        var h = a[c],\n            f = h.dItem;\n        f.periodDataItem = void 0;\n        f.periodPercentDataItem = void 0;\n        var g = \" \";\n        if (e) f.value ? h.text(f.value) : h.text(\"\");else {\n          var k = null;\n\n          if (void 0 !== f.type) {\n            var k = f.currentDataItem,\n                l = this.periodValueText;\n            f.legendPeriodValueText && (l = f.legendPeriodValueText);\n            f.legendPeriodValueTextR && (l = f.legendPeriodValueTextR);\n            k ? (g = this.valueText, f.legendValueText && (g = f.legendValueText), f.legendValueTextR && (g = f.legendValueTextR), g = b.formatString(g, k)) : l && b.formatPeriodString && (l = d.massReplace(l, {\n              \"[[title]]\": f.title\n            }), g = b.formatPeriodString(l, f));\n          } else g = b.formatString(this.valueText, f);\n\n          l = f;\n          k && (l = k);\n          var m = this.valueFunction;\n          m && (g = m(l, g, b.periodDataItem));\n          var p;\n          this.useMarkerColorForLabels && !k && f.lastDataItem && (k = f.lastDataItem);\n          k ? p = b.getBalloonColor(f, k) : f.legendKeyColor && (p = f.legendKeyColor());\n          f.legendColorFunction && (p = f.legendColorFunction(l, g, f.periodDataItem, f.periodPercentDataItem));\n          h.text(g);\n\n          if (!f.pattern && (this.useMarkerColorForValues && h.setAttr(\"fill\", p), this.useMarkerColorForLabels)) {\n            if (h = f.legendMarker) h.setAttr(\"fill\", p), h.setAttr(\"stroke\", p);\n            (f = f.legendLabel) && f.setAttr(\"fill\", p);\n          }\n        }\n      }\n    },\n    renderFix: function () {\n      if (!d.VML && this.enabled) {\n        var a = this.container;\n        a && a.renderFix();\n      }\n    },\n    destroy: function () {\n      this.div.innerHTML = \"\";\n      d.remove(this.set);\n    }\n  });\n})();\n\n(function () {\n  var d = window.AmCharts;\n\n  d.formatMilliseconds = function (a, b) {\n    if (-1 != a.indexOf(\"fff\")) {\n      var c = b.getMilliseconds(),\n          d = String(c);\n      10 > c && (d = \"00\" + c);\n      10 <= c && 100 > c && (d = \"0\" + c);\n      a = a.replace(/fff/g, d);\n    }\n\n    return a;\n  };\n\n  d.extractPeriod = function (a) {\n    var b = d.stripNumbers(a),\n        c = 1;\n    b != a && (c = Number(a.slice(0, a.indexOf(b))));\n    return {\n      period: b,\n      count: c\n    };\n  };\n\n  d.getDate = function (a, b, c) {\n    return a instanceof Date ? d.newDate(a, c) : b && isNaN(a) ? d.stringToDate(a, b) : new Date(a);\n  };\n\n  d.daysInMonth = function (a) {\n    return new Date(a.getYear(), a.getMonth() + 1, 0).getDate();\n  };\n\n  d.newDate = function (a, b) {\n    return b && -1 == b.indexOf(\"fff\") ? new Date(a) : new Date(a.getFullYear(), a.getMonth(), a.getDate(), a.getHours(), a.getMinutes(), a.getSeconds(), a.getMilliseconds());\n  };\n\n  d.resetDateToMin = function (a, b, c, e) {\n    void 0 === e && (e = 1);\n    var h, f, g, k, l, m, p;\n    d.useUTC ? (h = a.getUTCFullYear(), f = a.getUTCMonth(), g = a.getUTCDate(), k = a.getUTCHours(), l = a.getUTCMinutes(), m = a.getUTCSeconds(), p = a.getUTCMilliseconds(), a = a.getUTCDay()) : (h = a.getFullYear(), f = a.getMonth(), g = a.getDate(), k = a.getHours(), l = a.getMinutes(), m = a.getSeconds(), p = a.getMilliseconds(), a = a.getDay());\n\n    switch (b) {\n      case \"YYYY\":\n        h = Math.floor(h / c) * c;\n        f = 0;\n        g = 1;\n        p = m = l = k = 0;\n        break;\n\n      case \"MM\":\n        f = Math.floor(f / c) * c;\n        g = 1;\n        p = m = l = k = 0;\n        break;\n\n      case \"WW\":\n        g = a >= e ? g - a + e : g - (7 + a) + e;\n        p = m = l = k = 0;\n        break;\n\n      case \"DD\":\n        p = m = l = k = 0;\n        break;\n\n      case \"hh\":\n        k = Math.floor(k / c) * c;\n        p = m = l = 0;\n        break;\n\n      case \"mm\":\n        l = Math.floor(l / c) * c;\n        p = m = 0;\n        break;\n\n      case \"ss\":\n        m = Math.floor(m / c) * c;\n        p = 0;\n        break;\n\n      case \"fff\":\n        p = Math.floor(p / c) * c;\n    }\n\n    d.useUTC ? (a = new Date(), a.setUTCFullYear(h, f, g), a.setUTCHours(k, l, m, p)) : a = new Date(h, f, g, k, l, m, p);\n    return a;\n  };\n\n  d.getPeriodDuration = function (a, b) {\n    void 0 === b && (b = 1);\n    var c;\n\n    switch (a) {\n      case \"YYYY\":\n        c = 316224E5;\n        break;\n\n      case \"MM\":\n        c = 26784E5;\n        break;\n\n      case \"WW\":\n        c = 6048E5;\n        break;\n\n      case \"DD\":\n        c = 864E5;\n        break;\n\n      case \"hh\":\n        c = 36E5;\n        break;\n\n      case \"mm\":\n        c = 6E4;\n        break;\n\n      case \"ss\":\n        c = 1E3;\n        break;\n\n      case \"fff\":\n        c = 1;\n    }\n\n    return c * b;\n  };\n\n  d.intervals = {\n    s: {\n      nextInterval: \"ss\",\n      contains: 1E3\n    },\n    ss: {\n      nextInterval: \"mm\",\n      contains: 60,\n      count: 0\n    },\n    mm: {\n      nextInterval: \"hh\",\n      contains: 60,\n      count: 1\n    },\n    hh: {\n      nextInterval: \"DD\",\n      contains: 24,\n      count: 2\n    },\n    DD: {\n      nextInterval: \"\",\n      contains: Infinity,\n      count: 3\n    }\n  };\n\n  d.getMaxInterval = function (a, b) {\n    var c = d.intervals;\n    return a >= c[b].contains ? (a = Math.round(a / c[b].contains), b = c[b].nextInterval, d.getMaxInterval(a, b)) : \"ss\" == b ? c[b].nextInterval : b;\n  };\n\n  d.dayNames = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \");\n  d.shortDayNames = \"Sun Mon Tue Wed Thu Fri Sat\".split(\" \");\n  d.monthNames = \"January February March April May June July August September October November December\".split(\" \");\n  d.shortMonthNames = \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \");\n\n  d.getWeekNumber = function (a) {\n    a = new Date(a);\n    a.setHours(0, 0, 0);\n    a.setDate(a.getDate() + 4 - (a.getDay() || 7));\n    var b = new Date(a.getFullYear(), 0, 1);\n    return Math.ceil(((a - b) / 864E5 + 1) / 7);\n  };\n\n  d.stringToDate = function (a, b) {\n    var c = {},\n        e = [{\n      pattern: \"YYYY\",\n      period: \"year\"\n    }, {\n      pattern: \"YY\",\n      period: \"year\"\n    }, {\n      pattern: \"MM\",\n      period: \"month\"\n    }, {\n      pattern: \"M\",\n      period: \"month\"\n    }, {\n      pattern: \"DD\",\n      period: \"date\"\n    }, {\n      pattern: \"D\",\n      period: \"date\"\n    }, {\n      pattern: \"JJ\",\n      period: \"hours\"\n    }, {\n      pattern: \"J\",\n      period: \"hours\"\n    }, {\n      pattern: \"HH\",\n      period: \"hours\"\n    }, {\n      pattern: \"H\",\n      period: \"hours\"\n    }, {\n      pattern: \"KK\",\n      period: \"hours\"\n    }, {\n      pattern: \"K\",\n      period: \"hours\"\n    }, {\n      pattern: \"LL\",\n      period: \"hours\"\n    }, {\n      pattern: \"L\",\n      period: \"hours\"\n    }, {\n      pattern: \"NN\",\n      period: \"minutes\"\n    }, {\n      pattern: \"N\",\n      period: \"minutes\"\n    }, {\n      pattern: \"SS\",\n      period: \"seconds\"\n    }, {\n      pattern: \"S\",\n      period: \"seconds\"\n    }, {\n      pattern: \"QQQ\",\n      period: \"milliseconds\"\n    }, {\n      pattern: \"QQ\",\n      period: \"milliseconds\"\n    }, {\n      pattern: \"Q\",\n      period: \"milliseconds\"\n    }],\n        h = !0,\n        f = b.indexOf(\"AA\");\n    -1 != f && (a.substr(f, 2), \"pm\" == a.toLowerCase && (h = !1));\n    var f = b,\n        g,\n        k,\n        l;\n\n    for (l = 0; l < e.length; l++) k = e[l].period, c[k] = 0, \"date\" == k && (c[k] = 1);\n\n    for (l = 0; l < e.length; l++) if (g = e[l].pattern, k = e[l].period, -1 != b.indexOf(g)) {\n      var m = d.getFromDateString(g, a, f);\n      b = b.replace(g, \"\");\n      if (\"KK\" == g || \"K\" == g || \"LL\" == g || \"L\" == g) h || (m += 12);\n      c[k] = m;\n    }\n\n    d.useUTC ? (e = new Date(), e.setUTCFullYear(c.year, c.month, c.date), e.setUTCHours(c.hours, c.minutes, c.seconds, c.milliseconds)) : e = new Date(c.year, c.month, c.date, c.hours, c.minutes, c.seconds, c.milliseconds);\n    return e;\n  };\n\n  d.getFromDateString = function (a, b, c) {\n    if (void 0 !== b) return c = c.indexOf(a), b = String(b), b = b.substr(c, a.length), \"0\" == b.charAt(0) && (b = b.substr(1, b.length - 1)), b = Number(b), isNaN(b) && (b = 0), -1 != a.indexOf(\"M\") && b--, b;\n  };\n\n  d.formatDate = function (a, b, c) {\n    c || (c = d);\n    var e,\n        h,\n        f,\n        g,\n        k,\n        l,\n        m,\n        p,\n        q = d.getWeekNumber(a);\n    d.useUTC ? (e = a.getUTCFullYear(), h = a.getUTCMonth(), f = a.getUTCDate(), g = a.getUTCDay(), k = a.getUTCHours(), l = a.getUTCMinutes(), m = a.getUTCSeconds(), p = a.getUTCMilliseconds()) : (e = a.getFullYear(), h = a.getMonth(), f = a.getDate(), g = a.getDay(), k = a.getHours(), l = a.getMinutes(), m = a.getSeconds(), p = a.getMilliseconds());\n    var n = String(e).substr(2, 2),\n        t = \"0\" + g;\n    b = b.replace(/W/g, q);\n    q = k;\n    24 == q && (q = 0);\n    var r = q;\n    10 > r && (r = \"0\" + r);\n    b = b.replace(/JJ/g, r);\n    b = b.replace(/J/g, q);\n    r = k;\n    0 === r && (r = 24, -1 != b.indexOf(\"H\") && (f--, 0 === f && (e = new Date(a), e.setDate(e.getDate() - 1), h = e.getMonth(), f = e.getDate(), e = e.getFullYear())));\n    a = h + 1;\n    9 > h && (a = \"0\" + a);\n    q = f;\n    10 > f && (q = \"0\" + f);\n    var w = r;\n    10 > w && (w = \"0\" + w);\n    b = b.replace(/HH/g, w);\n    b = b.replace(/H/g, r);\n    r = k;\n    11 < r && (r -= 12);\n    w = r;\n    10 > w && (w = \"0\" + w);\n    b = b.replace(/KK/g, w);\n    b = b.replace(/K/g, r);\n    r = k;\n    0 === r && (r = 12);\n    12 < r && (r -= 12);\n    w = r;\n    10 > w && (w = \"0\" + w);\n    b = b.replace(/LL/g, w);\n    b = b.replace(/L/g, r);\n    r = l;\n    10 > r && (r = \"0\" + r);\n    b = b.replace(/NN/g, r);\n    b = b.replace(/N/g, l);\n    l = m;\n    10 > l && (l = \"0\" + l);\n    b = b.replace(/SS/g, l);\n    b = b.replace(/S/g, m);\n    m = p;\n    10 > m ? m = \"00\" + m : 100 > m && (m = \"0\" + m);\n    l = p;\n    10 > l && (l = \"00\" + l);\n    b = b.replace(/A/g, \"@A@\");\n    b = b.replace(/QQQ/g, m);\n    b = b.replace(/QQ/g, l);\n    b = b.replace(/Q/g, p);\n    b = b.replace(/YYYY/g, \"@IIII@\");\n    b = b.replace(/YY/g, \"@II@\");\n    b = b.replace(/MMMM/g, \"@XXXX@\");\n    b = b.replace(/MMM/g, \"@XXX@\");\n    b = b.replace(/MM/g, \"@XX@\");\n    b = b.replace(/M/g, \"@X@\");\n    b = b.replace(/DD/g, \"@RR@\");\n    b = b.replace(/D/g, \"@R@\");\n    b = b.replace(/EEEE/g, \"@PPPP@\");\n    b = b.replace(/EEE/g, \"@PPP@\");\n    b = b.replace(/EE/g, \"@PP@\");\n    b = b.replace(/E/g, \"@P@\");\n    b = b.replace(/@IIII@/g, e);\n    b = b.replace(/@II@/g, n);\n    b = b.replace(/@XXXX@/g, c.monthNames[h]);\n    b = b.replace(/@XXX@/g, c.shortMonthNames[h]);\n    b = b.replace(/@XX@/g, a);\n    b = b.replace(/@X@/g, h + 1);\n    b = b.replace(/@RR@/g, q);\n    b = b.replace(/@R@/g, f);\n    b = b.replace(/@PPPP@/g, c.dayNames[g]);\n    b = b.replace(/@PPP@/g, c.shortDayNames[g]);\n    b = b.replace(/@PP@/g, t);\n    b = b.replace(/@P@/g, g);\n    return b = 12 > k ? b.replace(/@A@/g, c.amString) : b.replace(/@A@/g, c.pmString);\n  };\n\n  d.changeDate = function (a, b, c, e, h) {\n    if (d.useUTC) return d.changeUTCDate(a, b, c, e, h);\n    var f = -1;\n    void 0 === e && (e = !0);\n    void 0 === h && (h = !1);\n    !0 === e && (f = 1);\n\n    switch (b) {\n      case \"YYYY\":\n        a.setFullYear(a.getFullYear() + c * f);\n        e || h || a.setDate(a.getDate() + 1);\n        break;\n\n      case \"MM\":\n        b = a.getMonth();\n        a.setMonth(a.getMonth() + c * f);\n        a.getMonth() > b + c * f && a.setDate(a.getDate() - 1);\n        e || h || a.setDate(a.getDate() + 1);\n        break;\n\n      case \"DD\":\n        a.setDate(a.getDate() + c * f);\n        break;\n\n      case \"WW\":\n        a.setDate(a.getDate() + c * f * 7);\n        break;\n\n      case \"hh\":\n        a.setHours(a.getHours() + c * f);\n        break;\n\n      case \"mm\":\n        a.setMinutes(a.getMinutes() + c * f);\n        break;\n\n      case \"ss\":\n        a.setSeconds(a.getSeconds() + c * f);\n        break;\n\n      case \"fff\":\n        a.setMilliseconds(a.getMilliseconds() + c * f);\n    }\n\n    return a;\n  };\n\n  d.changeUTCDate = function (a, b, c, d, h) {\n    var f = -1;\n    void 0 === d && (d = !0);\n    void 0 === h && (h = !1);\n    !0 === d && (f = 1);\n\n    switch (b) {\n      case \"YYYY\":\n        a.setUTCFullYear(a.getUTCFullYear() + c * f);\n        d || h || a.setUTCDate(a.getUTCDate() + 1);\n        break;\n\n      case \"MM\":\n        b = a.getUTCMonth();\n        a.setUTCMonth(a.getUTCMonth() + c * f);\n        a.getUTCMonth() > b + c * f && a.setUTCDate(a.getUTCDate() - 1);\n        d || h || a.setUTCDate(a.getUTCDate() + 1);\n        break;\n\n      case \"DD\":\n        a.setUTCDate(a.getUTCDate() + c * f);\n        break;\n\n      case \"WW\":\n        a.setUTCDate(a.getUTCDate() + c * f * 7);\n        break;\n\n      case \"hh\":\n        a.setUTCHours(a.getUTCHours() + c * f);\n        break;\n\n      case \"mm\":\n        a.setUTCMinutes(a.getUTCMinutes() + c * f);\n        break;\n\n      case \"ss\":\n        a.setUTCSeconds(a.getUTCSeconds() + c * f);\n        break;\n\n      case \"fff\":\n        a.setUTCMilliseconds(a.getUTCMilliseconds() + c * f);\n    }\n\n    return a;\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}